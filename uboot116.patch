diff -urN u-boot-1.1.6/board/100ask24x0/100ask24x0.c u-boot-1.1.6_jz2440/board/100ask24x0/100ask24x0.c
--- u-boot-1.1.6/board/100ask24x0/100ask24x0.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_jz2440/board/100ask24x0/100ask24x0.c	2010-11-26 12:54:37.034090906 +0800
@@ -0,0 +1,96 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <s3c2410.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+    S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+    S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+
+    /* set up the I/O ports */
+    gpio->GPACON = 0x007FFFFF;
+    gpio->GPBCON = 0x00044555;
+    gpio->GPBUP = 0x000007FF;
+    gpio->GPCCON = 0xAAAAAAAA;
+    gpio->GPCUP = 0x0000FFFF;
+    gpio->GPDCON = 0xAAAAAAAA;
+    gpio->GPDUP = 0x0000FFFF;
+    gpio->GPECON = 0xAAAAAAAA;
+    gpio->GPEUP = 0x0000FFFF;
+    gpio->GPFCON = 0x000055AA;
+    gpio->GPFUP = 0x000000FF;
+    gpio->GPGCON = 0xFF95FFBA;
+    gpio->GPGUP = 0x0000FFFF;
+    gpio->GPHCON = 0x002AFAAA;
+    gpio->GPHUP = 0x000007FF;
+
+    /* support both of S3C2410 and S3C2440, by www.100ask.net */
+    if (isS3C2410)
+    {
+        /* arch number of SMDK2410-Board */
+        gd->bd->bi_arch_number = MACH_TYPE_SMDK2410;
+    }
+    else
+    {
+        /* arch number of SMDK2440-Board */
+        gd->bd->bi_arch_number = MACH_TYPE_S3C2440;
+    }
+
+    /* adress of boot parameters */
+    gd->bd->bi_boot_params = 0x30000100;
+#if 0
+    icache_enable();
+    dcache_enable();
+#endif
+    return 0;
+}
+
+int dram_init (void)
+{
+    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+    return 0;
+}
+
+ulong board_flash_get_legacy(ulong base, int banknum, flash_info_t *info)
+{	
+	info->portwidth = CFG_FLASH_CFI_WIDTH;
+	info->chipwidth = CFG_FLASH_CFI_WIDTH;
+	info->interface = FLASH_CFI_X16;
+	return 1;
+}
+
+
diff -urN u-boot-1.1.6/board/100ask24x0/boot_init.c u-boot-1.1.6_jz2440/board/100ask24x0/boot_init.c
--- u-boot-1.1.6/board/100ask24x0/boot_init.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_jz2440/board/100ask24x0/boot_init.c	2010-11-26 12:54:37.042080086 +0800
@@ -0,0 +1,566 @@
+#include <common.h>
+#include <s3c2410.h>
+
+#define BUSY            1
+
+#define NAND_SECTOR_SIZE    512
+#define NAND_BLOCK_MASK     (NAND_SECTOR_SIZE - 1)
+
+#define NAND_SECTOR_SIZE_LP    2048
+#define NAND_BLOCK_MASK_LP     (NAND_SECTOR_SIZE_LP - 1)
+
+/* 供外部调用的函数 */
+void nand_init_ll(void);
+void nand_read_ll(unsigned char *buf, unsigned long start_addr, int size);
+
+/* NAND Flash操作的总入口, 它们将调用S3C2410或S3C2440的相应函数 */
+static void nand_reset(void);
+static void wait_idle(void);
+static void nand_select_chip(void);
+static void nand_deselect_chip(void);
+static void write_cmd(int cmd);
+static void write_addr(unsigned int addr);
+static unsigned char read_data(void);
+
+/* S3C2410的NAND Flash处理函数 */
+static void s3c2410_nand_reset(void);
+static void s3c2410_wait_idle(void);
+static void s3c2410_nand_select_chip(void);
+static void s3c2410_nand_deselect_chip(void);
+static void s3c2410_write_cmd(int cmd);
+static void s3c2410_write_addr(unsigned int addr);
+static unsigned char s3c2410_read_data(void);
+
+/* S3C2440的NAND Flash处理函数 */
+static void s3c2440_nand_reset(void);
+static void s3c2440_wait_idle(void);
+static void s3c2440_nand_select_chip(void);
+static void s3c2440_nand_deselect_chip(void);
+static void s3c2440_write_cmd(int cmd);
+static void s3c2440_write_addr(unsigned int addr);
+static unsigned char s3c2440_read_data(void);
+
+/* S3C2410的NAND Flash操作函数 */
+
+/* 复位 */
+static void s3c2410_nand_reset(void)
+{
+    s3c2410_nand_select_chip();
+    s3c2410_write_cmd(0xff);  // 复位命令
+    s3c2410_wait_idle();
+    s3c2410_nand_deselect_chip();
+}
+
+/* 等待NAND Flash就绪 */
+static void s3c2410_wait_idle(void)
+{
+    int i;
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+	
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2410nand->NFSTAT;
+    while(!(*p & BUSY))
+        for(i=0; i<10; i++);
+}
+
+/* 发出片选信号 */
+static void s3c2410_nand_select_chip(void)
+{
+    int i;
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+
+    s3c2410nand->NFCONF &= ~(1<<11);
+    for(i=0; i<10; i++);    
+}
+
+/* 取消片选信号 */
+static void s3c2410_nand_deselect_chip(void)
+{
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+
+    s3c2410nand->NFCONF |= (1<<11);
+}
+
+/* 发出命令 */
+static void s3c2410_write_cmd(int cmd)
+{
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2410nand->NFCMD;
+    *p = cmd;
+}
+
+/* 发出地址 */
+static void s3c2410_write_addr(unsigned int addr)
+{
+    int i;
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2410nand->NFADDR;
+    
+    *p = addr & 0xff;
+    for(i=0; i<10; i++);
+    *p = (addr >> 9) & 0xff;
+    for(i=0; i<10; i++);
+    *p = (addr >> 17) & 0xff;
+    for(i=0; i<10; i++);
+    *p = (addr >> 25) & 0xff;
+    for(i=0; i<10; i++);
+}
+
+/* 读取数据 */
+static unsigned char s3c2410_read_data(void)
+{
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2410nand->NFDATA;
+    return *p;
+}
+
+/* S3C2440的NAND Flash操作函数 */
+
+/* 复位 */
+static void s3c2440_nand_reset(void)
+{
+    s3c2440_nand_select_chip();
+    s3c2440_write_cmd(0xff);  // 复位命令
+    s3c2440_wait_idle();
+    s3c2440_nand_deselect_chip();
+}
+
+/* 等待NAND Flash就绪 */
+static void s3c2440_wait_idle(void)
+{
+    int i;
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFSTAT;
+
+    while(!(*p & BUSY))
+        for(i=0; i<10; i++);
+}
+
+/* 发出片选信号 */
+static void s3c2440_nand_select_chip(void)
+{
+    int i;
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+
+    s3c2440nand->NFCONT &= ~(1<<1);
+    for(i=0; i<10; i++);    
+}
+
+/* 取消片选信号 */
+static void s3c2440_nand_deselect_chip(void)
+{
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+
+    s3c2440nand->NFCONT |= (1<<1);
+}
+
+/* 发出命令 */
+static void s3c2440_write_cmd(int cmd)
+{
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFCMD;
+    *p = cmd;
+}
+
+/* 发出地址 */
+static void s3c2440_write_addr(unsigned int addr)
+{
+    int i;
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
+    
+    *p = addr & 0xff;
+    for(i=0; i<10; i++);
+    *p = (addr >> 9) & 0xff;
+    for(i=0; i<10; i++);
+    *p = (addr >> 17) & 0xff;
+    for(i=0; i<10; i++);
+    *p = (addr >> 25) & 0xff;
+    for(i=0; i<10; i++);
+}
+
+
+/* 发出地址 */
+static void s3c2440_write_addr_lp(unsigned int addr)
+{
+    int i;
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
+	int col, page;
+
+	col = addr & NAND_BLOCK_MASK_LP;
+	page = addr / NAND_SECTOR_SIZE_LP;
+	
+    *p = col & 0xff;			/* Column Address A0~A7 */
+    for(i=0; i<10; i++);		
+    *p = (col >> 8) & 0x0f;		/* Column Address A8~A11 */
+    for(i=0; i<10; i++);
+    *p = page & 0xff;			/* Row Address A12~A19 */
+    for(i=0; i<10; i++);
+    *p = (page >> 8) & 0xff;	/* Row Address A20~A27 */
+    for(i=0; i<10; i++);
+    *p = (page >> 16) & 0x03;	/* Row Address A28~A29 */
+    for(i=0; i<10; i++);
+}
+
+/* 读取数据 */
+static unsigned char s3c2440_read_data(void)
+{
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFDATA;
+    return *p;
+}
+
+
+/* 在第一次使用NAND Flash前，复位一下NAND Flash */
+static void nand_reset(void)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_nand_reset();
+	}
+	else
+	{
+	    s3c2440_nand_reset();
+	}
+}
+
+static void wait_idle(void)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_wait_idle();
+	}
+	else
+	{
+	    s3c2440_wait_idle();
+	}
+}
+
+static void nand_select_chip(void)
+{
+    int i;
+	
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_nand_select_chip();
+	}
+	else
+	{
+	    s3c2440_nand_select_chip();
+	}
+	
+    for(i=0; i<10; i++);
+}
+
+static void nand_deselect_chip(void)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_nand_deselect_chip();
+	}
+	else
+	{
+	    s3c2440_nand_deselect_chip();
+	}	
+}
+
+static void write_cmd(int cmd)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_write_cmd(cmd);
+	}
+	else
+	{
+	    s3c2440_write_cmd(cmd);
+	}	
+}
+static void write_addr(unsigned int addr)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_write_addr(addr);
+	}
+	else
+	{
+	    s3c2440_write_addr(addr);
+	}	
+}
+
+static void write_addr_lp(unsigned int addr)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_write_addr(addr);
+	}
+	else
+	{
+	    s3c2440_write_addr_lp(addr);
+	}	
+}
+
+static unsigned char read_data(void)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    return s3c2410_read_data();
+	}
+	else
+	{
+	    return s3c2440_read_data();
+	}	
+}
+
+/* 初始化NAND Flash */
+void nand_init_ll(void)
+{
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+
+#define TACLS   0
+#define TWRPH0  3
+#define TWRPH1  0
+
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+    {
+		/* 使能NAND Flash控制器, 初始化ECC, 禁止片选, 设置时序 */
+        s3c2410nand->NFCONF = (1<<15)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0);
+    }
+    else
+    {
+		/* 设置时序 */
+        s3c2440nand->NFCONF = (TACLS<<12)|(TWRPH0<<8)|(TWRPH1<<4);
+        /* 使能NAND Flash控制器, 初始化ECC, 禁止片选 */
+        s3c2440nand->NFCONT = (1<<4)|(1<<1)|(1<<0);
+    }
+
+	/* 复位NAND Flash */
+	nand_reset();
+}
+
+
+/* 读函数 */
+void nand_read_ll(unsigned char *buf, unsigned long start_addr, int size)
+{
+    int i, j;
+    
+    if ((start_addr & NAND_BLOCK_MASK) || (size & NAND_BLOCK_MASK)) {
+        return ;    /* 地址或长度不对齐 */
+    }
+
+    /* 选中芯片 */
+    nand_select_chip();
+
+    for(i=start_addr; i < (start_addr + size);) {
+      /* 发出READ0命令 */
+      write_cmd(0);
+
+      /* Write Address */
+      write_addr(i);
+      wait_idle();
+
+      for(j=0; j < NAND_SECTOR_SIZE; j++, i++) {
+          *buf = read_data();
+          buf++;
+      }
+    }
+
+    /* 取消片选信号 */
+    nand_deselect_chip();
+    
+    return ;
+}
+
+
+/* 读函数 
+  * Large Page
+  */
+void nand_read_ll_lp(unsigned char *buf, unsigned long start_addr, int size)
+{
+    int i, j;
+    
+    if ((start_addr & NAND_BLOCK_MASK_LP) || (size & NAND_BLOCK_MASK_LP)) {
+        return ;    /* 地址或长度不对齐 */
+    }
+
+    /* 选中芯片 */
+    nand_select_chip();
+
+    for(i=start_addr; i < (start_addr + size);) {
+      /* 发出READ0命令 */
+      write_cmd(0);
+
+      /* Write Address */
+      write_addr_lp(i);
+	  write_cmd(0x30);
+      wait_idle();
+
+      for(j=0; j < NAND_SECTOR_SIZE_LP; j++, i++) {
+          *buf = read_data();
+          buf++;
+      }
+    }
+
+    /* 取消片选信号 */
+    nand_deselect_chip();
+    
+    return ;
+}
+
+int bBootFrmNORFlash(void)
+{
+    volatile unsigned int *pdw = (volatile unsigned int *)0;
+    unsigned int dwVal;
+    
+    /*
+     * 无论是从NOR Flash还是从NAND Flash启动，
+     * 地址0处为指令"b	Reset", 机器码为0xEA00000B，
+     * 对于从NAND Flash启动的情况，其开始4KB的代码会复制到CPU内部4K内存中，
+     * 对于从NOR Flash启动的情况，NOR Flash的开始地址即为0。
+     * 对于NOR Flash，必须通过一定的命令序列才能写数据，
+     * 所以可以根据这点差别来分辨是从NAND Flash还是NOR Flash启动:
+     * 向地址0写入一个数据，然后读出来，如果没有改变的话就是NOR Flash
+     */
+
+    dwVal = *pdw;       
+    *pdw = 0x12345678;
+    if (*pdw != 0x12345678)
+    {
+        return 1;
+    }
+    else
+    {
+        *pdw = dwVal;
+        return 0;
+    }
+}
+
+int CopyCode2Ram(unsigned long start_addr, unsigned char *buf, int size)
+{
+    unsigned int *pdwDest;
+    unsigned int *pdwSrc;
+    int i;
+
+    if (bBootFrmNORFlash())
+    {
+        pdwDest = (unsigned int *)buf;
+        pdwSrc  = (unsigned int *)start_addr;
+        /* 从 NOR Flash启动 */
+        for (i = 0; i < size / 4; i++)
+        {
+            pdwDest[i] = pdwSrc[i];
+        }
+        return 0;
+    }
+    else
+    {
+        /* 初始化NAND Flash */
+		nand_init_ll();
+        /* 从 NAND Flash启动 */
+        nand_read_ll_lp(buf, start_addr, (size + NAND_BLOCK_MASK_LP)&~(NAND_BLOCK_MASK_LP));
+		return 0;
+    }
+}
+
+static inline void delay (unsigned long loops)
+{
+    __asm__ volatile ("1:\n"
+      "subs %0, %1, #1\n"
+      "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/* S3C2440: Mpll = (2*m * Fin) / (p * 2^s), UPLL = (m * Fin) / (p * 2^s)
+ * m = M (the value for divider M)+ 8, p = P (the value for divider P) + 2
+ */
+#define S3C2440_MPLL_400MHZ     ((0x5c<<12)|(0x01<<4)|(0x01))
+#define S3C2440_MPLL_200MHZ     ((0x5c<<12)|(0x01<<4)|(0x02))
+#define S3C2440_MPLL_100MHZ     ((0x5c<<12)|(0x01<<4)|(0x03))
+#define S3C2440_UPLL_96MHZ      ((0x38<<12)|(0x02<<4)|(0x01))
+#define S3C2440_UPLL_48MHZ      ((0x38<<12)|(0x02<<4)|(0x02))
+#define S3C2440_CLKDIV          (0x05) // | (1<<3))    /* FCLK:HCLK:PCLK = 1:4:8, UCLK = UPLL/2 */
+#define S3C2440_CLKDIV188       0x04    /* FCLK:HCLK:PCLK = 1:8:8 */
+#define S3C2440_CAMDIVN188      ((0<<8)|(1<<9)) /* FCLK:HCLK:PCLK = 1:8:8 */
+
+/* Fin = 16.9344MHz */
+#define S3C2440_MPLL_399MHz_Fin16MHz	((0x6e<<12)|(0x03<<4)|(0x01))
+#define S3C2440_UPLL_48MHZ_Fin16MHz     ((60<<12)|(4<<4)|(2))
+
+/* S3C2410: Mpll,Upll = (m * Fin) / (p * 2^s)
+ * m = M (the value for divider M)+ 8, p = P (the value for divider P) + 2
+ */
+#define S3C2410_MPLL_200MHZ     ((0x5c<<12)|(0x04<<4)|(0x00))
+#define S3C2410_UPLL_48MHZ      ((0x28<<12)|(0x01<<4)|(0x02))
+#define S3C2410_CLKDIV          0x03    /* FCLK:HCLK:PCLK = 1:2:4 */
+void clock_init(void)
+{
+	S3C24X0_CLOCK_POWER *clk_power = (S3C24X0_CLOCK_POWER *)0x4C000000;
+
+    /* support both of S3C2410 and S3C2440, by www.100ask.net */
+    if (isS3C2410)
+    {
+        /* FCLK:HCLK:PCLK = 1:2:4 */
+        clk_power->CLKDIVN = S3C2410_CLKDIV;
+
+        /* change to asynchronous bus mod */
+        __asm__(    "mrc    p15, 0, r1, c1, c0, 0\n"    /* read ctrl register   */  
+                    "orr    r1, r1, #0xc0000000\n"      /* Asynchronous         */  
+                    "mcr    p15, 0, r1, c1, c0, 0\n"    /* write ctrl register  */  
+                    :::"r1"
+                    );
+        
+        /* to reduce PLL lock time, adjust the LOCKTIME register */
+        clk_power->LOCKTIME = 0xFFFFFFFF;
+
+        /* configure UPLL */
+        clk_power->UPLLCON = S3C2410_UPLL_48MHZ;
+
+        /* some delay between MPLL and UPLL */
+        delay (4000);
+
+        /* configure MPLL */
+        clk_power->MPLLCON = S3C2410_MPLL_200MHZ;
+
+        /* some delay between MPLL and UPLL */
+        delay (8000);
+    }
+    else
+    {
+        /* FCLK:HCLK:PCLK = 1:4:8 */
+        clk_power->CLKDIVN = S3C2440_CLKDIV;
+
+        /* change to asynchronous bus mod */
+        __asm__(    "mrc    p15, 0, r1, c1, c0, 0\n"    /* read ctrl register   */  
+                    "orr    r1, r1, #0xc0000000\n"      /* Asynchronous         */  
+                    "mcr    p15, 0, r1, c1, c0, 0\n"    /* write ctrl register  */  
+                    :::"r1"
+                    );
+
+        /* to reduce PLL lock time, adjust the LOCKTIME register */
+        clk_power->LOCKTIME = 0xFFFFFFFF;
+
+        /* configure UPLL */
+        clk_power->UPLLCON = S3C2440_UPLL_48MHZ;
+
+        /* some delay between MPLL and UPLL */
+        delay (4000);
+
+        /* configure MPLL */
+        clk_power->MPLLCON = S3C2440_MPLL_400MHZ;
+
+        /* some delay between MPLL and UPLL */
+        delay (8000);
+    }
+}
+
diff -urN u-boot-1.1.6/board/100ask24x0/config.mk u-boot-1.1.6_jz2440/board/100ask24x0/config.mk
--- u-boot-1.1.6/board/100ask24x0/config.mk	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_jz2440/board/100ask24x0/config.mk	2010-11-26 12:54:37.022042833 +0800
@@ -0,0 +1,25 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# SAMSUNG SMDK2410 board with S3C2410X (ARM920T) cpu
+#
+# see http://www.samsung.com/ for more information on SAMSUNG
+#
+
+#
+# SMDK2410 has 1 bank of 64 MB DRAM
+#
+# 3000'0000 to 3400'0000
+#
+# Linux-Kernel is expected to be at 3000'8000, entry 3000'8000
+# optionally with a ramdisk at 3080'0000
+#
+# we load ourself to 33F8'0000
+#
+# download area is 3300'0000
+#
+
+
+TEXT_BASE = 0x33F80000
diff -urN u-boot-1.1.6/board/100ask24x0/flash.c u-boot-1.1.6_jz2440/board/100ask24x0/flash.c
--- u-boot-1.1.6/board/100ask24x0/flash.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_jz2440/board/100ask24x0/flash.c	2010-11-26 12:54:37.022042833 +0800
@@ -0,0 +1,433 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+ulong myflush (void);
+
+
+#define FLASH_BANK_SIZE	PHYS_FLASH_SIZE
+#define MAIN_SECT_SIZE  0x10000	/* 64 KB */
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+
+#define CMD_READ_ARRAY		0x000000F0
+#define CMD_UNLOCK1		0x000000AA
+#define CMD_UNLOCK2		0x00000055
+#define CMD_ERASE_SETUP		0x00000080
+#define CMD_ERASE_CONFIRM	0x00000030
+#define CMD_PROGRAM		0x000000A0
+#define CMD_UNLOCK_BYPASS	0x00000020
+
+#define MEM_FLASH_ADDR1		(*(volatile u16 *)(CFG_FLASH_BASE + (0x00000555 << 1)))
+#define MEM_FLASH_ADDR2		(*(volatile u16 *)(CFG_FLASH_BASE + (0x000002AA << 1)))
+
+#define BIT_ERASE_DONE		0x00000080
+#define BIT_RDY_MASK		0x00000080
+#define BIT_PROGRAM_ERROR	0x00000020
+#define BIT_TIMEOUT		0x80000000	/* our flag */
+
+#define READY 1
+#define ERR   2
+#define TMO   4
+
+/*-----------------------------------------------------------------------
+ */
+
+ulong flash_init (void)
+{
+	int i, j;
+	ulong size = 0;
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		ulong flashbase = 0;
+
+		flash_info[i].flash_id =
+#if defined(CONFIG_AMD_LV400)
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV400B & FLASH_TYPEMASK);
+#elif defined(CONFIG_AMD_LV800)
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV800B & FLASH_TYPEMASK);
+#else
+#error "Unknown flash configured"
+#endif
+			flash_info[i].size = FLASH_BANK_SIZE;
+		flash_info[i].sector_count = CFG_MAX_FLASH_SECT;
+		memset (flash_info[i].protect, 0, CFG_MAX_FLASH_SECT);
+		if (i == 0)
+			flashbase = PHYS_FLASH_1;
+		else
+			panic ("configured too many flash banks!\n");
+		for (j = 0; j < flash_info[i].sector_count; j++) {
+			if (j <= 3) {
+				/* 1st one is 16 KB */
+				if (j == 0) {
+					flash_info[i].start[j] =
+						flashbase + 0;
+				}
+
+				/* 2nd and 3rd are both 8 KB */
+				if ((j == 1) || (j == 2)) {
+					flash_info[i].start[j] =
+						flashbase + 0x4000 + (j -
+								      1) *
+						0x2000;
+				}
+
+				/* 4th 32 KB */
+				if (j == 3) {
+					flash_info[i].start[j] =
+						flashbase + 0x8000;
+				}
+			} else {
+				flash_info[i].start[j] =
+					flashbase + (j - 3) * MAIN_SECT_SIZE;
+			}
+		}
+		size += flash_info[i].size;
+	}
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CFG_FLASH_BASE,
+		       CFG_FLASH_BASE + monitor_flash_len - 1,
+		       &flash_info[0]);
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CFG_ENV_ADDR,
+		       CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		printf ("AMD: ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (AMD_ID_LV400B & FLASH_TYPEMASK):
+		printf ("1x Amd29LV400BB (4Mbit)\n");
+		break;
+	case (AMD_ID_LV800B & FLASH_TYPEMASK):
+		printf ("1x Amd29LV800BB (8Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		goto Done;
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+			info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+
+      Done:;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	ushort result;
+	int iflag, cflag, prot, sect;
+	int rc = ERR_OK;
+	int chip;
+
+	/* first look for protection bits */
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+	    (AMD_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+		printf ("Erasing sector %2d ... ", sect);
+
+		/* arm simple, non interrupt dependent timer */
+		reset_timer_masked ();
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			vu_short *addr = (vu_short *) (info->start[sect]);
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			MEM_FLASH_ADDR1 = CMD_ERASE_SETUP;
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			*addr = CMD_ERASE_CONFIRM;
+
+			/* wait until flash is ready */
+			chip = 0;
+
+			do {
+				result = *addr;
+
+				/* check timeout */
+				if (get_timer_masked () >
+				    CFG_FLASH_ERASE_TOUT) {
+					MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+					chip = TMO;
+					break;
+				}
+
+				if (!chip
+				    && (result & 0xFFFF) & BIT_ERASE_DONE)
+					chip = READY;
+
+				if (!chip
+				    && (result & 0xFFFF) & BIT_PROGRAM_ERROR)
+					chip = ERR;
+
+			} while (!chip);
+
+			MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+
+			if (chip == ERR) {
+				rc = ERR_PROG_ERROR;
+				goto outahere;
+			}
+			if (chip == TMO) {
+				rc = ERR_TIMOUT;
+				goto outahere;
+			}
+
+			printf ("ok.\n");
+		} else {	/* it was protected */
+
+			printf ("protected!\n");
+		}
+	}
+
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+      outahere:
+	/* allow flash to settle - wait 10 ms */
+	udelay_masked (10000);
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+volatile static int write_hword (flash_info_t * info, ulong dest, ushort data)
+{
+	vu_short *addr = (vu_short *) dest;
+	ushort result;
+	int rc = ERR_OK;
+	int cflag, iflag;
+	int chip;
+
+	/*
+	 * Check if Flash is (sufficiently) erased
+	 */
+	result = *addr;
+	if ((result & data) != data)
+		return ERR_NOT_ERASED;
+
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+	MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+	MEM_FLASH_ADDR1 = CMD_UNLOCK_BYPASS;
+	*addr = CMD_PROGRAM;
+	*addr = data;
+
+	/* arm simple, non interrupt dependent timer */
+	reset_timer_masked ();
+
+	/* wait until flash is ready */
+	chip = 0;
+	do {
+		result = *addr;
+
+		/* check timeout */
+		if (get_timer_masked () > CFG_FLASH_ERASE_TOUT) {
+			chip = ERR | TMO;
+			break;
+		}
+		if (!chip && ((result & 0x80) == (data & 0x80)))
+			chip = READY;
+
+		if (!chip && ((result & 0xFFFF) & BIT_PROGRAM_ERROR)) {
+			result = *addr;
+
+			if ((result & 0x80) == (data & 0x80))
+				chip = READY;
+			else
+				chip = ERR;
+		}
+
+	} while (!chip);
+
+	*addr = CMD_READ_ARRAY;
+
+	if (chip == ERR || *addr != data)
+		rc = ERR_PROG_ERROR;
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	int l;
+	int i, rc;
+	ushort data;
+
+	wp = (addr & ~1);	/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+		for (; i < 2 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 8);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 2; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+
+		if ((rc = write_hword (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 2) {
+		data = *((vu_short *) src);
+		if ((rc = write_hword (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 8);
+		--cnt;
+	}
+	for (; i < 2; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 8);
+	}
+
+	return write_hword (info, wp, data);
+}
diff -urN u-boot-1.1.6/board/100ask24x0/lowlevel_init.S u-boot-1.1.6_jz2440/board/100ask24x0/lowlevel_init.S
--- u-boot-1.1.6/board/100ask24x0/lowlevel_init.S	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_jz2440/board/100ask24x0/lowlevel_init.S	2010-11-26 12:54:37.042080086 +0800
@@ -0,0 +1,168 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+
+/* some parameters for the board */
+
+/*
+ *
+ * Taken from linux/arch/arm/boot/compressed/head-s3c2410.S
+ *
+ * Copyright (C) 2002 Samsung Electronics SW.LEE  <hitchcar@sec.samsung.com>
+ *
+ */
+
+#define BWSCON	0x48000000
+
+/* BWSCON */
+#define DW8		 	(0x0)
+#define DW16		 	(0x1)
+#define DW32		 	(0x2)
+#define WAIT		 	(0x1<<2)
+#define UBLB		 	(0x1<<3)
+
+#define B1_BWSCON	  	(DW16)
+#define B2_BWSCON	  	(DW16)
+//#define B3_BWSCON	  	(DW16 + WAIT + UBLB)
+#define B3_BWSCON	  	(DW16 + UBLB)
+#define B4_BWSCON	  	(DW16 + WAIT + UBLB)
+#define B5_BWSCON	  	(DW8)
+#define B6_BWSCON	  	(DW32)
+#define B7_BWSCON	  	(DW32)
+
+/* BANK0CON */
+#define B0_Tacs		 	0x0	/*  0clk */
+#define B0_Tcos		 	0x0	/*  0clk */
+#define B0_Tacc		 	0x7	/* 14clk */
+#define B0_Tcoh		 	0x0	/*  0clk */
+#define B0_Tah		 	0x0	/*  0clk */
+#define B0_Tacp		 	0x0
+#define B0_PMC		 	0x0	/* normal */
+
+/* BANK1CON */
+#define B1_Tacs		 	0x0	/*  0clk */
+#define B1_Tcos		 	0x0	/*  0clk */
+#define B1_Tacc		 	0x7	/* 14clk */
+#define B1_Tcoh		 	0x0	/*  0clk */
+#define B1_Tah		 	0x0	/*  0clk */
+#define B1_Tacp		 	0x0
+#define B1_PMC		 	0x0
+
+#define B2_Tacs		 	0x0
+#define B2_Tcos		 	0x0
+#define B2_Tacc		 	0x7
+#define B2_Tcoh		 	0x0
+#define B2_Tah		 	0x0
+#define B2_Tacp		 	0x0
+#define B2_PMC		 	0x0
+
+#define B3_Tacs		 	0x0	/*  0clk */
+#define B3_Tcos		 	0x3	/*  4clk */
+#define B3_Tacc		 	0x7	/* 14clk */
+#define B3_Tcoh		 	0x1	/*  1clk */
+#define B3_Tah		 	0x0	/*  0clk */
+#define B3_Tacp		 	0x3     /*  6clk */
+#define B3_PMC		 	0x0	/* normal */
+
+#define B4_Tacs		 	0x0	/*  0clk */
+#define B4_Tcos		 	0x3	/*  4clk */
+#define B4_Tacc		 	0x7	/* 14clk */
+#define B4_Tcoh		 	0x1	/*  1clk */
+#define B4_Tah		 	0x3	/*  4clk */
+#define B4_Tacp		 	0x6 /*  6clk */
+#define B4_PMC		 	0x0	/* normal */
+
+#define B5_Tacs		 	0x0	/*  0clk */
+#define B5_Tcos		 	0x0	/*  0clk */
+#define B5_Tacc		 	0x7	/* 14clk */
+#define B5_Tcoh		 	0x0	/*  0clk */
+#define B5_Tah		 	0x0	/*  0clk */
+#define B5_Tacp		 	0x0
+#define B5_PMC		 	0x0	/* normal */
+
+#define B6_MT		 	0x3	/* SDRAM */
+#define B6_Trcd	 	 	0x1
+#define B6_SCAN		 	0x1	/* 9bit */
+
+#define B7_MT		 	0x3	/* SDRAM */
+#define B7_Trcd		 	0x1	/* 3clk */
+#define B7_SCAN		 	0x1	/* 9bit */
+
+/* REFRESH parameter */
+#define REFEN		 	0x1	/* Refresh enable */
+#define TREFMD		 	0x0	/* CBR(CAS before RAS)/Auto refresh */
+#define Trp		 	    0x0	/* 2clk */
+#define Trc		    	0x3	/* 7clk */
+#define Tchr		 	0x2	/* 3clk */
+#define REFCNT		 	0x4f4	/* period=7.8125us, HCLK=100Mhz, (2048+1-7.8125*100) */
+/**************************************/
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+.globl lowlevel_init
+lowlevel_init:
+	/* memory control configuration */
+	/* make r0 relative the current location so that it */
+	/* reads SMRDATA out of FLASH rather than memory ! */
+	ldr     r0, =SMRDATA
+	ldr	r1, _TEXT_BASE
+	sub	r0, r0, r1
+	ldr	r1, =BWSCON	/* Bus Width Status Controller */
+	add     r2, r0, #13*4
+0:
+	ldr     r3, [r0], #4
+	str     r3, [r1], #4
+	cmp     r2, r0
+	bne     0b
+
+	/* everything is fine now */
+	mov	pc, lr
+
+	.ltorg
+/* the literal pools origin */
+
+SMRDATA:
+    .word (0+(B1_BWSCON<<4)+(B2_BWSCON<<8)+(B3_BWSCON<<12)+(B4_BWSCON<<16)+(B5_BWSCON<<20)+(B6_BWSCON<<24)+(B7_BWSCON<<28)) 
+    .word ((B0_Tacs<<13)+(B0_Tcos<<11)+(B0_Tacc<<8)+(B0_Tcoh<<6)+(B0_Tah<<4)+(B0_Tacp<<2)+(B0_PMC))
+    .word ((B1_Tacs<<13)+(B1_Tcos<<11)+(B1_Tacc<<8)+(B1_Tcoh<<6)+(B1_Tah<<4)+(B1_Tacp<<2)+(B1_PMC))
+    .word ((B2_Tacs<<13)+(B2_Tcos<<11)+(B2_Tacc<<8)+(B2_Tcoh<<6)+(B2_Tah<<4)+(B2_Tacp<<2)+(B2_PMC))
+    .word ((B3_Tacs<<13)+(B3_Tcos<<11)+(B3_Tacc<<8)+(B3_Tcoh<<6)+(B3_Tah<<4)+(B3_Tacp<<2)+(B3_PMC))
+    .word ((B4_Tacs<<13)+(B4_Tcos<<11)+(B4_Tacc<<8)+(B4_Tcoh<<6)+(B4_Tah<<4)+(B4_Tacp<<2)+(B4_PMC))
+    .word ((B5_Tacs<<13)+(B5_Tcos<<11)+(B5_Tacc<<8)+(B5_Tcoh<<6)+(B5_Tah<<4)+(B5_Tacp<<2)+(B5_PMC))
+    .word ((B6_MT<<15)+(B6_Trcd<<2)+(B6_SCAN))
+    .word ((B7_MT<<15)+(B7_Trcd<<2)+(B7_SCAN))
+    .word ((REFEN<<23)+(TREFMD<<22)+(Trp<<20)+(Trc<<18)+(Tchr<<16)+REFCNT)
+    .word 0xb1
+    .word 0x30
+    .word 0x30
diff -urN u-boot-1.1.6/board/100ask24x0/Makefile u-boot-1.1.6_jz2440/board/100ask24x0/Makefile
--- u-boot-1.1.6/board/100ask24x0/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_jz2440/board/100ask24x0/Makefile	2010-11-26 12:54:37.030096240 +0800
@@ -0,0 +1,51 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= 100ask24x0.o boot_init.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN u-boot-1.1.6/board/100ask24x0/u-boot.lds u-boot-1.1.6_jz2440/board/100ask24x0/u-boot.lds
--- u-boot-1.1.6/board/100ask24x0/u-boot.lds	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_jz2440/board/100ask24x0/u-boot.lds	2010-11-26 12:54:37.042080086 +0800
@@ -0,0 +1,58 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/arm920t/start.o	(.text)
+          board/100ask24x0/boot_init.o (.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -urN u-boot-1.1.6/cpu/arm920t/s3c24x0/Makefile u-boot-1.1.6_jz2440/cpu/arm920t/s3c24x0/Makefile
--- u-boot-1.1.6/cpu/arm920t/s3c24x0/Makefile	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_jz2440/cpu/arm920t/s3c24x0/Makefile	2010-11-26 12:54:37.726297356 +0800
@@ -26,7 +26,7 @@
 LIB	= $(obj)lib$(SOC).a
 
 COBJS	= i2c.o interrupts.o serial.o speed.o \
-	  usb_ohci.o
+	  usb_ohci.o nand_flash.o
 
 SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
diff -urN u-boot-1.1.6/cpu/arm920t/s3c24x0/nand_flash.c u-boot-1.1.6_jz2440/cpu/arm920t/s3c24x0/nand_flash.c
--- u-boot-1.1.6/cpu/arm920t/s3c24x0/nand_flash.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_jz2440/cpu/arm920t/s3c24x0/nand_flash.c	2010-11-26 12:54:37.726297356 +0800
@@ -0,0 +1,186 @@
+/*
+ * Nand flash interface of s3c2410/s3c2440, by www.100ask.net
+ * Changed from drivers/mtd/nand/s3c2410.c of kernel 2.6.13
+ */
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND) && !defined(CFG_NAND_LEGACY)
+#include <s3c2410.h>
+#include <nand.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define S3C2410_NFSTAT_READY    (1<<0)
+#define S3C2410_NFCONF_nFCE     (1<<11)
+
+#define S3C2440_NFSTAT_READY    (1<<0)
+#define S3C2440_NFCONT_nFCE     (1<<1)
+
+
+/* select chip, for s3c2410 */
+static void s3c2410_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+
+    if (chip == -1) {
+        s3c2410nand->NFCONF |= S3C2410_NFCONF_nFCE;
+    } else {
+        s3c2410nand->NFCONF &= ~S3C2410_NFCONF_nFCE;
+    }
+}
+
+/* command and control functions, for s3c2410 
+ *
+ * Note, these all use tglx's method of changing the IO_ADDR_W field
+ * to make the code simpler, and use the nand layer's code to issue the
+ * command and address sequences via the proper IO ports.
+ *
+*/
+static void s3c2410_nand_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+    struct nand_chip *chip = mtd->priv;
+
+    switch (cmd) {
+    case NAND_CTL_SETNCE:
+    case NAND_CTL_CLRNCE:
+        printf("%s: called for NCE\n", __FUNCTION__);
+        break;
+
+    case NAND_CTL_SETCLE:
+        chip->IO_ADDR_W = (void *)&s3c2410nand->NFCMD;
+        break;
+
+    case NAND_CTL_SETALE:
+        chip->IO_ADDR_W = (void *)&s3c2410nand->NFADDR;
+        break;
+
+        /* NAND_CTL_CLRCLE: */
+        /* NAND_CTL_CLRALE: */
+    default:
+        chip->IO_ADDR_W = (void *)&s3c2410nand->NFDATA;
+        break;
+    }
+}
+
+/* s3c2410_nand_devready()
+ *
+ * returns 0 if the nand is busy, 1 if it is ready
+ */
+static int s3c2410_nand_devready(struct mtd_info *mtd)
+{
+    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+
+    return (s3c2410nand->NFSTAT & S3C2410_NFSTAT_READY);
+}
+
+
+/* select chip, for s3c2440 */
+static void s3c2440_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (chip == -1) {
+        s3c2440nand->NFCONT |= S3C2440_NFCONT_nFCE;
+    } else {
+        s3c2440nand->NFCONT &= ~S3C2440_NFCONT_nFCE;
+    }
+}
+
+/* command and control functions */
+static void s3c2440_nand_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+    struct nand_chip *chip = mtd->priv;
+
+    switch (cmd) {
+    case NAND_CTL_SETNCE:
+    case NAND_CTL_CLRNCE:
+        printf("%s: called for NCE\n", __FUNCTION__);
+        break;
+
+    case NAND_CTL_SETCLE:
+        chip->IO_ADDR_W = (void *)&s3c2440nand->NFCMD;
+        break;
+
+    case NAND_CTL_SETALE:
+        chip->IO_ADDR_W = (void *)&s3c2440nand->NFADDR;
+        break;
+
+        /* NAND_CTL_CLRCLE: */
+        /* NAND_CTL_CLRALE: */
+    default:
+        chip->IO_ADDR_W = (void *)&s3c2440nand->NFDATA;
+        break;
+    }
+}
+
+/* s3c2440_nand_devready()
+ *
+ * returns 0 if the nand is busy, 1 if it is ready
+ */
+static int s3c2440_nand_devready(struct mtd_info *mtd)
+{
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    return (s3c2440nand->NFSTAT & S3C2440_NFSTAT_READY);
+}
+
+/*
+ * Nand flash hardware initialization:
+ * Set the timing, enable NAND flash controller
+ */
+static void s3c24x0_nand_inithw(void)
+{
+    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+#define TACLS   0
+#define TWRPH0  4
+#define TWRPH1  2
+
+    if (isS3C2410)
+    {
+        /* Enable NAND flash controller, Initialize ECC, enable chip select, Set flash memory timing */
+        s3c2410nand->NFCONF = (1<<15)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0);
+    }
+    else
+    {
+        /* Set flash memory timing */
+        s3c2440nand->NFCONF = (TACLS<<12)|(TWRPH0<<8)|(TWRPH1<<4);
+        /* Initialize ECC, enable chip select, NAND flash controller enable */
+        s3c2440nand->NFCONT = (1<<4)|(0<<1)|(1<<0);
+    }
+}
+
+/*
+ * Called by drivers/nand/nand.c, initialize the interface of nand flash
+ */
+void board_nand_init(struct nand_chip *chip)
+{
+    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    s3c24x0_nand_inithw();
+
+    if (isS3C2410) {
+        chip->IO_ADDR_R    = (void *)&s3c2410nand->NFDATA;
+        chip->IO_ADDR_W    = (void *)&s3c2410nand->NFDATA;
+        chip->hwcontrol    = s3c2410_nand_hwcontrol;
+        chip->dev_ready    = s3c2410_nand_devready;
+        chip->select_chip  = s3c2410_nand_select_chip;
+        chip->options      = 0;
+    } else {
+        chip->IO_ADDR_R    = (void *)&s3c2440nand->NFDATA;
+        chip->IO_ADDR_W    = (void *)&s3c2440nand->NFDATA;
+        chip->hwcontrol    = s3c2440_nand_hwcontrol;
+        chip->dev_ready    = s3c2440_nand_devready;
+        chip->select_chip  = s3c2440_nand_select_chip;
+        chip->options      = 0;
+    }
+
+    chip->eccmode       = NAND_ECC_SOFT;
+}
+
+#endif
diff -urN u-boot-1.1.6/cpu/arm920t/s3c24x0/nand_flash_legacy.c u-boot-1.1.6_jz2440/cpu/arm920t/s3c24x0/nand_flash_legacy.c
--- u-boot-1.1.6/cpu/arm920t/s3c24x0/nand_flash_legacy.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_jz2440/cpu/arm920t/s3c24x0/nand_flash_legacy.c	2010-11-26 12:54:37.726297356 +0800
@@ -0,0 +1,222 @@
+/* add by www.100ask.net */
+/*-----------------------------------------------------------------------
+ * NAND flash settings
+ */
+#include <common.h>
+#include <s3c2410.h>
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* only has two value: NFCE_LOW, NFCE_HIGH */
+#define NFCE_STATE  int 
+
+void NF_Conf(u16 conf)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	s3c2410nand->NFCONF = conf;
+    else
+        s3c2440nand->NFCONF = conf;
+}
+
+/* only for s3c2440 */
+void NF_Cont(u16 cont)
+{
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number != MACH_TYPE_SMDK2410)
+        s3c2440nand->NFCONT = cont;
+}
+
+void NF_Cmd(u8 cmd)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	s3c2410nand->NFCMD = cmd;
+    else
+    	s3c2440nand->NFCMD = cmd;
+}
+
+void NF_CmdW(u8 cmd)
+{
+	NF_Cmd(cmd);
+    udelay(1);
+}
+
+void NF_Addr(u8 addr)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	s3c2410nand->NFADDR = addr;
+    else
+    	s3c2440nand->NFADDR = addr;
+    udelay(15);
+}
+
+void NF_SetCE(NFCE_STATE s)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+	switch (s) {
+		case NFCE_LOW:
+            if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+		    	s3c2410nand->NFCONF &= ~(1<<11);
+            else
+		    	s3c2440nand->NFCONT &= ~(1<<1);                
+			break;
+
+		case NFCE_HIGH:
+            if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    			s3c2410nand->NFCONF |= (1<<11);
+            else
+		    	s3c2440nand->NFCONT |= (1<<1);
+			break;
+	}
+}
+
+/* only for s3c2440 */
+void NF_ClrRB(void)
+{
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number != MACH_TYPE_SMDK2410)
+    {
+        s3c2440nand->NFSTAT |= (1<<2);
+    }
+}
+
+void NF_WaitRB(void)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    {
+    	while (!(s3c2410nand->NFSTAT & (1<<0)));
+    }
+    else
+    {
+    	while (!(s3c2440nand->NFSTAT & (1<<0)));
+        s3c2440nand->NFSTAT |= (1<<2);
+    }
+}
+
+void NF_Write(u8 data)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+    volatile unsigned char *puc = (volatile unsigned char *)&s3c2440nand->NFDATA;
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	s3c2410nand->NFDATA = data;
+    else
+    	*puc = data;    /* s3c2440's NFDATA must be accessed by 'u8*', www.100ask.net */
+    
+}
+
+u8 NF_Read(void)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+    volatile unsigned char *puc = (volatile unsigned char *)&s3c2440nand->NFDATA;
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	return(s3c2410nand->NFDATA);
+    else
+    	return(*puc);   /* s3c2440's NFDATA must be accessed by 'u8*', www.100ask.net */
+}
+
+void NF_Init_ECC(void)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	s3c2410nand->NFCONF |= (1<<12);
+    else
+    {
+        s3c2440nand->NFCONT |= (1<<4);   // Reset ECC
+        s3c2440nand->NFCONT &= ~(1<<5);  // UnLock MECC
+    }
+}
+
+u32 NF_Read_ECC(void)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	return(s3c2410nand->NFECC);
+    else
+    {
+        s3c2440nand->NFCONT |= (1<<5);  // Lock MECC
+        return(s3c2440nand->NFMECC0);   // Read MECC
+    }
+}
+
+extern ulong
+nand_probe(ulong physadr);
+
+
+static inline void NF_Reset(void)
+{
+    int i;
+
+    NF_Cont((1<<4)|(0<<1)|(1<<0));  /* only for s3c2440, Initialize ECC, enable chip select, NAND flash controller enable */
+    NF_SetCE(NFCE_LOW); /* enable chip select */
+    NF_ClrRB();         /* only for s3c2440 */
+    NF_Cmd(0xFF);		/* reset command */
+    for(i = 0; i < 10; i++);	/* tWB = 100ns. */
+    NF_WaitRB();		/* wait 200~500us; */
+    NF_SetCE(NFCE_HIGH);
+}
+
+static inline void NF_Init(void)
+{
+#if 0 /* a little bit too optimistic */
+#define TACLS   0
+#define TWRPH0  3
+#define TWRPH1  0
+#else
+#define TACLS   0
+#define TWRPH0  4
+#define TWRPH1  2
+#endif
+
+    /* Set flash memory timing */
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    {
+        NF_Conf((1<<15)|(0<<14)|(0<<13)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0));
+        /*nand->NFCONF = (1<<15)|(1<<14)|(1<<13)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0); */
+        /* 1  1    1     1,   1      xxx,  r xxx,   r xxx */
+        /* En 512B 4step ECCR nFCE=H tACLS   tWRPH0   tWRPH1 */
+    }
+    else
+    {
+        NF_Conf((3<<12)|(7<<8)|(7<<4));
+    }
+
+    NF_Reset();
+}
+
+void
+nand_init(void)
+{
+	S3C2410_NAND * const nand = S3C2410_GetBase_NAND();
+
+	NF_Init();
+#ifdef DEBUG
+	printf("NAND flash probing at 0x%.8lX\n", (ulong)nand);
+#endif
+	printf ("%4lu MB\n", nand_probe((ulong)nand) >> 20);
+}
+#endif	/* CONFIG_COMMANDS & CFG_CMD_NAND */
+
diff -urN u-boot-1.1.6/cpu/arm920t/s3c24x0/speed.c u-boot-1.1.6_jz2440/cpu/arm920t/s3c24x0/speed.c
--- u-boot-1.1.6/cpu/arm920t/s3c24x0/speed.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_jz2440/cpu/arm920t/s3c24x0/speed.c	2010-11-26 12:54:37.730289845 +0800
@@ -38,6 +38,8 @@
 #include <s3c2410.h>
 #endif
 
+DECLARE_GLOBAL_DATA_PTR;
+
 #define MPLL 0
 #define UPLL 1
 
@@ -57,17 +59,21 @@
     ulong r, m, p, s;
 
     if (pllreg == MPLL)
-	r = clk_power->MPLLCON;
+    r = clk_power->MPLLCON;
     else if (pllreg == UPLL)
-	r = clk_power->UPLLCON;
+    r = clk_power->UPLLCON;
     else
-	hang();
+    hang();
 
     m = ((r & 0xFF000) >> 12) + 8;
     p = ((r & 0x003F0) >> 4) + 2;
     s = r & 0x3;
 
-    return((CONFIG_SYS_CLK_FREQ * m) / (p << s));
+    /* support both of S3C2410 and S3C2440, by www.100ask.net */
+    if (isS3C2410)
+        return((CONFIG_SYS_CLK_FREQ * m) / (p << s));
+    else
+        return((CONFIG_SYS_CLK_FREQ * m * 2) / (p << s));   /* S3C2440 */
 }
 
 /* return FCLK frequency */
@@ -76,20 +82,99 @@
     return(get_PLLCLK(MPLL));
 }
 
+/* for s3c2440 */
+#define S3C2440_CLKDIVN_PDIVN        (1<<0)
+#define S3C2440_CLKDIVN_HDIVN_MASK   (3<<1)
+#define S3C2440_CLKDIVN_HDIVN_1      (0<<1)
+#define S3C2440_CLKDIVN_HDIVN_2      (1<<1)
+#define S3C2440_CLKDIVN_HDIVN_4_8    (2<<1)
+#define S3C2440_CLKDIVN_HDIVN_3_6    (3<<1)
+#define S3C2440_CLKDIVN_UCLK         (1<<3)
+
+#define S3C2440_CAMDIVN_CAMCLK_MASK  (0xf<<0)
+#define S3C2440_CAMDIVN_CAMCLK_SEL   (1<<4)
+#define S3C2440_CAMDIVN_HCLK3_HALF   (1<<8)
+#define S3C2440_CAMDIVN_HCLK4_HALF   (1<<9)
+#define S3C2440_CAMDIVN_DVSEN        (1<<12)
+
 /* return HCLK frequency */
 ulong get_HCLK(void)
 {
     S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+    unsigned long clkdiv;
+    unsigned long camdiv;
+    int hdiv = 1;
+
+    /* support both of S3C2410 and S3C2440, by www.100ask.net */
+    if (isS3C2410)
+        return((clk_power->CLKDIVN & 0x2) ? get_FCLK()/2 : get_FCLK());
+    else
+    {
+        clkdiv = clk_power->CLKDIVN;
+        camdiv = clk_power->CAMDIVN;
+
+        /* work out clock scalings */
+
+        switch (clkdiv & S3C2440_CLKDIVN_HDIVN_MASK) {
+        case S3C2440_CLKDIVN_HDIVN_1:
+            hdiv = 1;
+            break;
+
+        case S3C2440_CLKDIVN_HDIVN_2:
+            hdiv = 2;
+            break;
+
+        case S3C2440_CLKDIVN_HDIVN_4_8:
+            hdiv = (camdiv & S3C2440_CAMDIVN_HCLK4_HALF) ? 8 : 4;
+            break;
+
+        case S3C2440_CLKDIVN_HDIVN_3_6:
+            hdiv = (camdiv & S3C2440_CAMDIVN_HCLK3_HALF) ? 6 : 3;
+            break;
+        }
 
-    return((clk_power->CLKDIVN & 0x2) ? get_FCLK()/2 : get_FCLK());
+        return get_FCLK() / hdiv;
+    }
 }
 
 /* return PCLK frequency */
 ulong get_PCLK(void)
 {
     S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+    unsigned long clkdiv;
+    unsigned long camdiv;
+    int hdiv = 1;
+
+    /* support both of S3C2410 and S3C2440, by www.100ask.net */
+    if (isS3C2410)
+        return((clk_power->CLKDIVN & 0x1) ? get_HCLK()/2 : get_HCLK());
+    else
+    {   
+        clkdiv = clk_power->CLKDIVN;
+        camdiv = clk_power->CAMDIVN;
+
+        /* work out clock scalings */
+
+        switch (clkdiv & S3C2440_CLKDIVN_HDIVN_MASK) {
+        case S3C2440_CLKDIVN_HDIVN_1:
+            hdiv = 1;
+            break;
+
+        case S3C2440_CLKDIVN_HDIVN_2:
+            hdiv = 2;
+            break;
+
+        case S3C2440_CLKDIVN_HDIVN_4_8:
+            hdiv = (camdiv & S3C2440_CAMDIVN_HCLK4_HALF) ? 8 : 4;
+            break;
+
+        case S3C2440_CLKDIVN_HDIVN_3_6:
+            hdiv = (camdiv & S3C2440_CAMDIVN_HCLK3_HALF) ? 6 : 3;
+            break;
+        }
 
-    return((clk_power->CLKDIVN & 0x1) ? get_HCLK()/2 : get_HCLK());
+        return get_FCLK() / hdiv / ((clkdiv & S3C2440_CLKDIVN_PDIVN)? 2:1);
+    }        
 }
 
 /* return UCLK frequency */
diff -urN u-boot-1.1.6/cpu/arm920t/start.S u-boot-1.1.6_jz2440/cpu/arm920t/start.S
--- u-boot-1.1.6/cpu/arm920t/start.S	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_jz2440/cpu/arm920t/start.S	2010-11-26 12:54:37.718042180 +0800
@@ -90,6 +90,18 @@
 _bss_end:
 	.word _end
 
+.globl FREE_RAM_END
+FREE_RAM_END:
+	.word	0x0badc0de
+
+.globl FREE_RAM_SIZE
+FREE_RAM_SIZE:
+	.word	0x0badc0de
+
+.globl PreLoadedONRAM
+PreLoadedONRAM:
+	.word	0
+
 #ifdef CONFIG_USE_IRQ
 /* IRQ stack memory (calculated at run-time) */
 .globl IRQ_STACK_START
@@ -123,6 +135,7 @@
 # define CLKDIVN	0x14800014	/* clock divisor register */
 #elif defined(CONFIG_S3C2410)
 # define pWTCON		0x53000000
+# define INTMOD     0X4A000004
 # define INTMSK		0x4A000008	/* Interupt-Controller base addresses */
 # define INTSUBMSK	0x4A00001C
 # define CLKDIVN	0x4C000014	/* clock divisor register */
@@ -145,11 +158,13 @@
 	str	r1, [r0]
 # endif
 
+#if 0
 	/* FCLK:HCLK:PCLK = 1:2:4 */
 	/* default FCLK is 120 MHz ! */
 	ldr	r0, =CLKDIVN
 	mov	r1, #3
 	str	r1, [r0]
+#endif
 #endif	/* CONFIG_S3C2400 || CONFIG_S3C2410 */
 
 	/*
@@ -157,19 +172,40 @@
 	 * not when booting from ram!
 	 */
 #ifndef CONFIG_SKIP_LOWLEVEL_INIT
-	bl	cpu_init_crit
+	adr	r0, _start		/* r0 <- current position of code   */
+	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
+	cmp     r0, r1                  /* don't reloc during debug         */
+	blne	cpu_init_crit
+#endif
+
+	/* Set up the stack						    */
+stack_setup:
+	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
+	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
+	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
+
+#ifdef CONFIG_USE_IRQ
+	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
 #endif
+	sub	sp, r0, #12		/* leave 3 words for abort-stack    */
+
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+    bl clock_init
+#endif    
 
 #ifndef CONFIG_SKIP_RELOCATE_UBOOT
 relocate:				/* relocate U-Boot to RAM	    */
 	adr	r0, _start		/* r0 <- current position of code   */
 	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
 	cmp     r0, r1                  /* don't reloc during debug         */
-	beq     stack_setup
-
+	beq     clear_bss
+	
 	ldr	r2, _armboot_start
 	ldr	r3, _bss_start
 	sub	r2, r3, r2		/* r2 <- size of armboot            */
+#if 1
+	bl  CopyCode2Ram	/* r0: source, r1: dest, r2: size */
+#else
 	add	r2, r0, r2		/* r2 <- source end address         */
 
 copy_loop:
@@ -177,17 +213,8 @@
 	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
 	cmp	r0, r2			/* until source end addreee [r2]    */
 	ble	copy_loop
-#endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
-
-	/* Set up the stack						    */
-stack_setup:
-	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
-	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
-	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
-#ifdef CONFIG_USE_IRQ
-	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
 #endif
-	sub	sp, r0, #12		/* leave 3 words for abort-stack    */
+#endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
 
 clear_bss:
 	ldr	r0, _bss_start		/* find start of bss segment        */
@@ -199,6 +226,15 @@
 	cmp	r0, r1
 	ble	clbss_l
 
+SetLoadFlag:
+	/* Set a global flag, PreLoadedONRAM */
+	adr	r0, _start		/* r0 <- current position of code   */
+	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
+	cmp     r0, r1                  /* don't reloc during debug         */
+	ldr r2, =PreLoadedONRAM
+	mov r3, #1
+	streq r3, [r2]
+
 #if 0
 	/* try doing this stuff after the relocation */
 	ldr     r0, =pWTCON
@@ -400,14 +436,88 @@
 	bad_save_user_regs
 	bl 	do_not_used
 
+@ thisway.diy, 2006.06.24
+.globl Launch
+    .align	4
+Launch:    
+    mov r7, r0
+    @ diable interrupt
+	@ disable watch dog timer
+	mov	r1, #0x53000000
+	mov	r2, #0x0
+	str	r2, [r1]
+
+    ldr r1,=INTMSK
+    ldr r2,=0xffffffff  @ all interrupt disable
+    str r2,[r1]
+
+    ldr r1,=INTSUBMSK
+    ldr r2,=0x7ff       @ all sub interrupt disable
+    str r2,[r1]
+
+    ldr     r1, = INTMOD
+    mov r2, #0x0        @ set all interrupt as IRQ (not FIQ)
+    str     r2, [r1]
+
+    @ 
+	mov	ip, #0
+	mcr	p15, 0, ip, c13, c0, 0      @	/* zero PID */
+	mcr	p15, 0, ip, c7, c7, 0       @	/* invalidate I,D caches */
+	mcr	p15, 0, ip, c7, c10, 4      @	/* drain write buffer */
+	mcr	p15, 0, ip, c8, c7, 0       @	/* invalidate I,D TLBs */
+	mrc	p15, 0, ip, c1, c0, 0       @	/* get control register */
+	bic	ip, ip, #0x0001             @	/* disable MMU */
+	mcr	p15, 0, ip, c1, c0, 0       @	/* write control register */
+
+    @ MMU_EnableICache
+    @mrc p15,0,r1,c1,c0,0
+    @orr r1,r1,#(1<<12)
+    @mcr p15,0,r1,c1,c0,0
+
+    @ clear SDRAM: the end of free mem(has wince on it now) to the end of SDRAM
+    ldr     r3, FREE_RAM_END
+    ldr     r4, =PHYS_SDRAM_1+PHYS_SDRAM_1_SIZE    @ must clear all the memory unused to zero
+    mov     r5, #0
+
+    ldr     r1, _armboot_start
+    ldr     r2, =On_Steppingstone
+    sub     r2, r2, r1
+    mov     pc, r2
+On_Steppingstone:
+2:  stmia   r3!, {r5}
+    cmp     r3, r4
+    bne     2b
+
+    @ set sp = 0 on sys mode
+    mov sp, #0
+
+    @ add by thisway.diy 2006.06.26, switch to SVC mode
+	msr	cpsr_c,	#0xdf	@ set the I-bit = 1, diable the IRQ interrupt
+	msr	cpsr_c,	#0xd3	@ set the I-bit = 1, diable the IRQ interrupt
+    ldr sp, =0x31ff5800	
+    
+    nop
+	nop
+    nop
+	nop
+
+	mov     pc, r7  @ Jump to PhysicalAddress
+	nop
+    mov pc, lr
+
 #ifdef CONFIG_USE_IRQ
 
 	.align	5
 irq:
-	get_irq_stack
-	irq_save_user_regs
-	bl 	do_irq
-	irq_restore_user_regs
+///* add by www.100ask.net to use IRQ for USB and DMA */
+//	sub	lr, lr, #4			        @ the return address
+//	ldr	sp, IRQ_STACK_START	        @ the stack for irq
+//	stmdb	sp!, 	{ r0-r12,lr }	@ save registers
+//	
+//	ldr	lr,	=int_return		        @ set the return addr
+//	ldr	pc, =IRQ_Handle		        @ call the isr
+//int_return:
+//	ldmia	sp!, 	{ r0-r12,pc }^	@ return from interrupt
 
 	.align	5
 fiq:
diff -urN u-boot-1.1.6/include/configs/100ask24x0.h u-boot-1.1.6_jz2440/include/configs/100ask24x0.h
--- u-boot-1.1.6/include/configs/100ask24x0.h	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_jz2440/include/configs/100ask24x0.h	2010-11-26 12:54:37.958266315 +0800
@@ -0,0 +1,237 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ * Gary Jennejohn <gj@denx.de>
+ * David Mueller <d.mueller@elsoft.ch>
+ *
+ * Configuation settings for the SAMSUNG SMDK2410 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM920T		1	/* This is an ARM920T Core	*/
+#define	CONFIG_S3C2410		1	/* in a SAMSUNG S3C2410 SoC     */
+#define CONFIG_SMDK2410		1	/* on a SAMSUNG SMDK2410 Board  */
+
+/* input clock of PLL */
+#define CONFIG_SYS_CLK_FREQ	12000000 /* the SMDK2410 has 12MHz input clock */
+//#define CONFIG_SYS_CLK_FREQ	16934400 /* the SMDK2410 has 12MHz input clock */
+
+
+#define USE_920T_MMU		1
+
+#define CONFIG_USB_DEVICE   1
+
+#ifdef CONFIG_USB_DEVICE
+#define CONFIG_USE_IRQ		1
+#endif
+
+#define CONFIG_JFFS2_CMDLINE 1
+#define CONFIG_JFFS2_NAND    1
+
+#define MTDIDS_DEFAULT "nand0=nandflash0"
+#define MTDPARTS_DEFAULT "mtdparts=nandflash0:256k@0(bootloader)," \
+                            "128k(params)," \
+                            "2m(kernel)," \
+                            "-(root)"
+
+/*
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN		(CFG_ENV_SIZE + 128*1024)
+#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Hardware drivers
+ */
+#if 1
+#if 0
+#define CONFIG_DRIVER_CS8900	1	/* we have a CS8900 on-board */
+#define CS8900_BASE		0x19000300
+#define CS8900_BUS16		1 /* the Linux driver does accesses as shorts */
+#endif
+
+#if !defined(CONFIG_DRIVER_CS8900)
+#define CONFIG_DRIVER_DM9000		1
+#define CONFIG_DM9000_USE_16BIT 	1
+#define CONFIG_DM9000_BASE			0x20000000
+#define DM9000_IO					0x20000000  
+#define DM9000_DATA					0x20000004
+#endif
+#endif
+/*
+ * select serial console configuration
+ */
+#define CONFIG_SERIAL1          1	/* we use SERIAL 1 on SMDK2410 */
+
+/************************************************************
+ * RTC
+ ************************************************************/
+#define	CONFIG_RTC_S3C24X0	1
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE		115200
+
+/* for tag(s) to transfer message to kernel, www.100ask.net */
+#define CONFIG_SETUP_MEMORY_TAGS    1
+#define CONFIG_CMDLINE_TAG          1
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+#define CONFIG_COMMANDS \
+                        ((CONFIG_CMD_DFL | \
+                        CFG_CMD_CACHE    | \
+                    /* Start: by www.100ask.net */ \
+                        CFG_CMD_PING     | \
+                        CFG_CMD_JFFS2    | \
+                        CFG_CMD_NAND     | \
+                    /* End: by www.100ask.net */ \
+                        /*CFG_CMD_EEPROM |*/ \
+                        /*CFG_CMD_I2C    |*/ \
+                        /*CFG_CMD_USB    |*/ \
+                        CFG_CMD_REGINFO  | \
+                        CFG_CMD_DATE     | \
+                        CFG_CMD_ELF))
+
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	2
+#define CONFIG_BOOTARGS    	"noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0"
+#define CONFIG_ETHADDR	    08:00:3e:26:0a:5b
+#define CONFIG_NETMASK      255.255.255.0
+#define CONFIG_IPADDR		192.168.7.17
+#define CONFIG_SERVERIP		192.168.7.11
+/*#define CONFIG_BOOTFILE	"elinos-lart" */
+#define CONFIG_BOOTCOMMAND	"nand read.jffs2 0x30007FC0 kernel; bootm 0x30007FC0"
+
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200		/* speed to run kgdb serial port */
+/* what's this ? it's not used anywhere */
+#define CONFIG_KGDB_SER_INDEX	1		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory		*/
+#define	CFG_PROMPT		"OpenJTAG> "	/* Monitor Command Prompt	*/
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_BARGSIZE		CFG_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CFG_MEMTEST_START	0x30000000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0x33F00000	/* 63 MB in DRAM	*/
+
+#undef  CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define	CFG_LOAD_ADDR		0x33000000	/* default load address	*/
+
+/* the PWM TImer 4 uses a counter of 15625 for 10 ms, so we need */
+/* it to wrap 100 times (total 1562500) to get 1 sec. */
+#define	CFG_HZ			1562500
+
+/* valid baudrates */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   /* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x30000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x04000000 /* 64 MB */
+
+#define PHYS_FLASH_1		0x00000000 /* Flash Bank #1 */
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+#define CFG_MONITOR_BASE	PHYS_FLASH_1
+
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+#if 0
+#define CONFIG_AMD_LV400	1	/* uncomment this if you have a LV400 flash */
+#endif
+//#define CONFIG_AMD_LV800	1	/* uncomment this if you have a LV800 flash */
+
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#ifdef CONFIG_AMD_LV800
+#define PHYS_FLASH_SIZE		0x00100000 /* 1MB */
+#define CFG_MAX_FLASH_SECT	(19)	/* max number of sectors on one chip */
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + 0x0F0000) /* addr of environment */
+#endif
+#ifdef CONFIG_AMD_LV400
+#define PHYS_FLASH_SIZE		0x00080000 /* 512KB */
+#define CFG_MAX_FLASH_SECT	(11)	/* max number of sectors on one chip */
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + 0x070000) /* addr of environment */
+#endif
+
+#define CFG_FLASH_CFI				1
+#define CFG_FLASH_CFI_DRIVER 		1
+#define CFG_FLASH_USE_BUFFER_WRITE	1
+#define CONFIG_FLASH_CFI_LEGACY		1
+
+#ifdef CFG_FLASH_CFI_DRIVER
+#define CFG_MAX_FLASH_SECT	 512   /* max number of sectors on one chip */
+#define CFG_FLASH_CFI_WIDTH  0x02  /* FLASH_CFI_16BIT */
+#endif
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(5*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(5*CFG_HZ) /* Timeout for Flash Write */
+
+//#define	CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_IS_IN_NAND  1
+#define CFG_ENV_OFFSET      0x40000
+#define CFG_ENV_SIZE		0x20000	/* Total Size of Environment Sector */
+
+/*-----------------------------------------------------------------------
+ * NAND flash settings
+ */
+#define CFG_NAND_BASE           0
+#define CFG_MAX_NAND_DEVICE     1
+#define NAND_MAX_CHIPS          1
+
+#endif	/* __CONFIG_H */
+++ u-boot-1.1.6_jz2440/include/nand.h	2010-11-26 12:54:38.062126185 +0800
@@ -78,6 +78,14 @@
 	int pad;		/* pad to page size */
 	int blockalign;		/* 1|2|4 set multiple of eraseblocks
 				 * to align to */
+    int skipfirstblk;   /* if true, skip the first good block,  
+                         * set true when write the yaffs image, 
+                         * add by www.100ask.net
+                         */                    
+    int nocheckbadblk;  /* if true, don't check bad blockes,
+                         * use them as good blockes
+                         * add by www.100ask.net
+                         */                    
 };
 
 typedef struct nand_write_options nand_write_options_t;
@@ -88,6 +96,11 @@
 	ulong offset;		/* start address in NAND */
 	int quiet;		/* don't display progress messages */
 	int readoob;		/* put oob data in image */
+	int noecc;		/* read without ecc */
+    int nocheckbadblk;  /* if true, don't check bad blockes,
+                         * use them as good blockes
+                         * add by www.100ask.net
+                         */                    
 };
 
 typedef struct nand_read_options nand_read_options_t;
diff -urN u-boot-1.1.6/include/s3c2410.h u-boot-1.1.6_jz2440/include/s3c2410.h
--- u-boot-1.1.6/include/s3c2410.h	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_jz2440/include/s3c2410.h	2010-11-26 12:54:37.994099919 +0800
@@ -22,7 +22,7 @@
  */
 
 /************************************************
- * NAME	    : s3c2410.h
+ * NAME     : s3c2410.h
  * Version  : 31.3.2003
  *
  * Based on S3C2410X User's manual Rev 1.1
@@ -31,38 +31,38 @@
 #ifndef __S3C2410_H__
 #define __S3C2410_H__
 
-#define S3C24X0_UART_CHANNELS	3
-#define S3C24X0_SPI_CHANNELS	2
+#define S3C24X0_UART_CHANNELS   3
+#define S3C24X0_SPI_CHANNELS    2
 
 /* S3C2410 only supports 512 Byte HW ECC */
-#define S3C2410_ECCSIZE		512
-#define S3C2410_ECCBYTES	3
+#define S3C2410_ECCSIZE     512
+#define S3C2410_ECCBYTES    3
 
 typedef enum {
-	S3C24X0_UART0,
-	S3C24X0_UART1,
-	S3C24X0_UART2
+    S3C24X0_UART0,
+    S3C24X0_UART1,
+    S3C24X0_UART2
 } S3C24X0_UARTS_NR;
 
 /* S3C2410 device base addresses */
-#define S3C24X0_MEMCTL_BASE		0x48000000
-#define S3C24X0_USB_HOST_BASE		0x49000000
-#define S3C24X0_INTERRUPT_BASE		0x4A000000
-#define S3C24X0_DMA_BASE		0x4B000000
-#define S3C24X0_CLOCK_POWER_BASE	0x4C000000
-#define S3C24X0_LCD_BASE		0x4D000000
-#define S3C2410_NAND_BASE		0x4E000000
-#define S3C24X0_UART_BASE		0x50000000
-#define S3C24X0_TIMER_BASE		0x51000000
-#define S3C24X0_USB_DEVICE_BASE		0x52000140
-#define S3C24X0_WATCHDOG_BASE		0x53000000
-#define S3C24X0_I2C_BASE		0x54000000
-#define S3C24X0_I2S_BASE		0x55000000
-#define S3C24X0_GPIO_BASE		0x56000000
-#define S3C24X0_RTC_BASE		0x57000000
-#define S3C2410_ADC_BASE		0x58000000
-#define S3C24X0_SPI_BASE		0x59000000
-#define S3C2410_SDI_BASE		0x5A000000
+#define S3C24X0_MEMCTL_BASE     0x48000000
+#define S3C24X0_USB_HOST_BASE       0x49000000
+#define S3C24X0_INTERRUPT_BASE      0x4A000000
+#define S3C24X0_DMA_BASE        0x4B000000
+#define S3C24X0_CLOCK_POWER_BASE    0x4C000000
+#define S3C24X0_LCD_BASE        0x4D000000
+#define S3C2410_NAND_BASE       0x4E000000
+#define S3C24X0_UART_BASE       0x50000000
+#define S3C24X0_TIMER_BASE      0x51000000
+#define S3C24X0_USB_DEVICE_BASE     0x52000140
+#define S3C24X0_WATCHDOG_BASE       0x53000000
+#define S3C24X0_I2C_BASE        0x54000000
+#define S3C24X0_I2S_BASE        0x55000000
+#define S3C24X0_GPIO_BASE       0x56000000
+#define S3C24X0_RTC_BASE        0x57000000
+#define S3C2410_ADC_BASE        0x58000000
+#define S3C24X0_SPI_BASE        0x59000000
+#define S3C2410_SDI_BASE        0x5A000000
 
 
 /* include common stuff */
@@ -71,130 +71,172 @@
 
 static inline S3C24X0_MEMCTL * const S3C24X0_GetBase_MEMCTL(void)
 {
-	return (S3C24X0_MEMCTL * const)S3C24X0_MEMCTL_BASE;
+    return (S3C24X0_MEMCTL * const)S3C24X0_MEMCTL_BASE;
 }
 static inline S3C24X0_USB_HOST * const S3C24X0_GetBase_USB_HOST(void)
 {
-	return (S3C24X0_USB_HOST * const)S3C24X0_USB_HOST_BASE;
+    return (S3C24X0_USB_HOST * const)S3C24X0_USB_HOST_BASE;
 }
 static inline S3C24X0_INTERRUPT * const S3C24X0_GetBase_INTERRUPT(void)
 {
-	return (S3C24X0_INTERRUPT * const)S3C24X0_INTERRUPT_BASE;
+    return (S3C24X0_INTERRUPT * const)S3C24X0_INTERRUPT_BASE;
 }
 static inline S3C24X0_DMAS * const S3C24X0_GetBase_DMAS(void)
 {
-	return (S3C24X0_DMAS * const)S3C24X0_DMA_BASE;
+    return (S3C24X0_DMAS * const)S3C24X0_DMA_BASE;
 }
 static inline S3C24X0_CLOCK_POWER * const S3C24X0_GetBase_CLOCK_POWER(void)
 {
-	return (S3C24X0_CLOCK_POWER * const)S3C24X0_CLOCK_POWER_BASE;
+    return (S3C24X0_CLOCK_POWER * const)S3C24X0_CLOCK_POWER_BASE;
 }
 static inline S3C24X0_LCD * const S3C24X0_GetBase_LCD(void)
 {
-	return (S3C24X0_LCD * const)S3C24X0_LCD_BASE;
+    return (S3C24X0_LCD * const)S3C24X0_LCD_BASE;
 }
 static inline S3C2410_NAND * const S3C2410_GetBase_NAND(void)
 {
-	return (S3C2410_NAND * const)S3C2410_NAND_BASE;
+    return (S3C2410_NAND * const)S3C2410_NAND_BASE;
+}
+
+/* for s3c2440, www.100ask.net */
+static inline S3C2440_NAND * const S3C2440_GetBase_NAND(void)
+{
+    return (S3C2440_NAND * const)S3C2410_NAND_BASE;
 }
 static inline S3C24X0_UART * const S3C24X0_GetBase_UART(S3C24X0_UARTS_NR nr)
 {
-	return (S3C24X0_UART * const)(S3C24X0_UART_BASE + (nr * 0x4000));
+    return (S3C24X0_UART * const)(S3C24X0_UART_BASE + (nr * 0x4000));
 }
 static inline S3C24X0_TIMERS * const S3C24X0_GetBase_TIMERS(void)
 {
-	return (S3C24X0_TIMERS * const)S3C24X0_TIMER_BASE;
+    return (S3C24X0_TIMERS * const)S3C24X0_TIMER_BASE;
 }
 static inline S3C24X0_USB_DEVICE * const S3C24X0_GetBase_USB_DEVICE(void)
 {
-	return (S3C24X0_USB_DEVICE * const)S3C24X0_USB_DEVICE_BASE;
+    return (S3C24X0_USB_DEVICE * const)S3C24X0_USB_DEVICE_BASE;
 }
 static inline S3C24X0_WATCHDOG * const S3C24X0_GetBase_WATCHDOG(void)
 {
-	return (S3C24X0_WATCHDOG * const)S3C24X0_WATCHDOG_BASE;
+    return (S3C24X0_WATCHDOG * const)S3C24X0_WATCHDOG_BASE;
 }
 static inline S3C24X0_I2C * const S3C24X0_GetBase_I2C(void)
 {
-	return (S3C24X0_I2C * const)S3C24X0_I2C_BASE;
+    return (S3C24X0_I2C * const)S3C24X0_I2C_BASE;
 }
 static inline S3C24X0_I2S * const S3C24X0_GetBase_I2S(void)
 {
-	return (S3C24X0_I2S * const)S3C24X0_I2S_BASE;
+    return (S3C24X0_I2S * const)S3C24X0_I2S_BASE;
 }
 static inline S3C24X0_GPIO * const S3C24X0_GetBase_GPIO(void)
 {
-	return (S3C24X0_GPIO * const)S3C24X0_GPIO_BASE;
+    return (S3C24X0_GPIO * const)S3C24X0_GPIO_BASE;
 }
 static inline S3C24X0_RTC * const S3C24X0_GetBase_RTC(void)
 {
-	return (S3C24X0_RTC * const)S3C24X0_RTC_BASE;
+    return (S3C24X0_RTC * const)S3C24X0_RTC_BASE;
 }
 static inline S3C2410_ADC * const S3C2410_GetBase_ADC(void)
 {
-	return (S3C2410_ADC * const)S3C2410_ADC_BASE;
+    return (S3C2410_ADC * const)S3C2410_ADC_BASE;
 }
 static inline S3C24X0_SPI * const S3C24X0_GetBase_SPI(void)
 {
-	return (S3C24X0_SPI * const)S3C24X0_SPI_BASE;
+    return (S3C24X0_SPI * const)S3C24X0_SPI_BASE;
 }
 static inline S3C2410_SDI * const S3C2410_GetBase_SDI(void)
 {
-	return (S3C2410_SDI * const)S3C2410_SDI_BASE;
+    return (S3C2410_SDI * const)S3C2410_SDI_BASE;
 }
 
+/* add by thisway.diy */             
+#define _ISR_STARTADDRESS   ((unsigned)isr_handle_array)
+
+#define ISR_EINT0_OFT     0
+#define ISR_EINT1_OFT     1
+#define ISR_EINT2_OFT     2
+#define ISR_EINT3_OFT     3
+#define ISR_EINT4_7_OFT   4
+#define ISR_EINT8_23_OFT  5
+#define ISR_NOTUSED6_OFT  6
+#define ISR_BAT_FLT_OFT   7
+#define ISR_TICK_OFT      8
+#define ISR_WDT_OFT       9
+#define ISR_TIMER0_OFT    10
+#define ISR_TIMER1_OFT    11
+#define ISR_TIMER2_OFT    12
+#define ISR_TIMER3_OFT    13
+#define ISR_TIMER4_OFT    14
+#define ISR_UART2_OFT     15
+#define ISR_LCD_OFT       16
+#define ISR_DMA0_OFT      17
+#define ISR_DMA1_OFT      18
+#define ISR_DMA2_OFT      19
+#define ISR_DMA3_OFT      20
+#define ISR_SDI_OFT       21
+#define ISR_SPI0_OFT      22
+#define ISR_UART1_OFT     23
+#define ISR_NOTUSED24_OFT 24
+#define ISR_USBD_OFT      25
+#define ISR_USBH_OFT      26
+#define ISR_IIC_OFT       27
+#define ISR_UART0_OFT     28
+#define ISR_SPI1_OFT      29
+#define ISR_RTC_OFT       30
+#define ISR_ADC_OFT       31
 
 /* ISR */
-#define pISR_RESET		(*(unsigned *)(_ISR_STARTADDRESS+0x0))
-#define pISR_UNDEF		(*(unsigned *)(_ISR_STARTADDRESS+0x4))
-#define pISR_SWI		(*(unsigned *)(_ISR_STARTADDRESS+0x8))
-#define pISR_PABORT		(*(unsigned *)(_ISR_STARTADDRESS+0xC))
-#define pISR_DABORT		(*(unsigned *)(_ISR_STARTADDRESS+0x10))
-#define pISR_RESERVED		(*(unsigned *)(_ISR_STARTADDRESS+0x14))
-#define pISR_IRQ		(*(unsigned *)(_ISR_STARTADDRESS+0x18))
-#define pISR_FIQ		(*(unsigned *)(_ISR_STARTADDRESS+0x1C))
-
-#define pISR_EINT0		(*(unsigned *)(_ISR_STARTADDRESS+0x20))
-#define pISR_EINT1		(*(unsigned *)(_ISR_STARTADDRESS+0x24))
-#define pISR_EINT2		(*(unsigned *)(_ISR_STARTADDRESS+0x28))
-#define pISR_EINT3		(*(unsigned *)(_ISR_STARTADDRESS+0x2C))
-#define pISR_EINT4_7		(*(unsigned *)(_ISR_STARTADDRESS+0x30))
-#define pISR_EINT8_23		(*(unsigned *)(_ISR_STARTADDRESS+0x34))
-#define pISR_BAT_FLT		(*(unsigned *)(_ISR_STARTADDRESS+0x3C))
-#define pISR_TICK		(*(unsigned *)(_ISR_STARTADDRESS+0x40))
-#define pISR_WDT		(*(unsigned *)(_ISR_STARTADDRESS+0x44))
-#define pISR_TIMER0		(*(unsigned *)(_ISR_STARTADDRESS+0x48))
-#define pISR_TIMER1		(*(unsigned *)(_ISR_STARTADDRESS+0x4C))
-#define pISR_TIMER2		(*(unsigned *)(_ISR_STARTADDRESS+0x50))
-#define pISR_TIMER3		(*(unsigned *)(_ISR_STARTADDRESS+0x54))
-#define pISR_TIMER4		(*(unsigned *)(_ISR_STARTADDRESS+0x58))
-#define pISR_UART2		(*(unsigned *)(_ISR_STARTADDRESS+0x5C))
-#define pISR_NOTUSED		(*(unsigned *)(_ISR_STARTADDRESS+0x60))
-#define pISR_DMA0		(*(unsigned *)(_ISR_STARTADDRESS+0x64))
-#define pISR_DMA1		(*(unsigned *)(_ISR_STARTADDRESS+0x68))
-#define pISR_DMA2		(*(unsigned *)(_ISR_STARTADDRESS+0x6C))
-#define pISR_DMA3		(*(unsigned *)(_ISR_STARTADDRESS+0x70))
-#define pISR_SDI		(*(unsigned *)(_ISR_STARTADDRESS+0x74))
-#define pISR_SPI0		(*(unsigned *)(_ISR_STARTADDRESS+0x78))
-#define pISR_UART1		(*(unsigned *)(_ISR_STARTADDRESS+0x7C))
-#define pISR_USBD		(*(unsigned *)(_ISR_STARTADDRESS+0x84))
-#define pISR_USBH		(*(unsigned *)(_ISR_STARTADDRESS+0x88))
-#define pISR_IIC		(*(unsigned *)(_ISR_STARTADDRESS+0x8C))
-#define pISR_UART0		(*(unsigned *)(_ISR_STARTADDRESS+0x90))
-#define pISR_SPI1		(*(unsigned *)(_ISR_STARTADDRESS+0x94))
-#define pISR_RTC		(*(unsigned *)(_ISR_STARTADDRESS+0x98))
-#define pISR_ADC		(*(unsigned *)(_ISR_STARTADDRESS+0xA0))
+#define pISR_RESET      (*(unsigned *)(_ISR_STARTADDRESS+0x0))
+#define pISR_UNDEF      (*(unsigned *)(_ISR_STARTADDRESS+0x4))
+#define pISR_SWI        (*(unsigned *)(_ISR_STARTADDRESS+0x8))
+#define pISR_PABORT     (*(unsigned *)(_ISR_STARTADDRESS+0xC))
+#define pISR_DABORT     (*(unsigned *)(_ISR_STARTADDRESS+0x10))
+#define pISR_RESERVED       (*(unsigned *)(_ISR_STARTADDRESS+0x14))
+#define pISR_IRQ        (*(unsigned *)(_ISR_STARTADDRESS+0x18))
+#define pISR_FIQ        (*(unsigned *)(_ISR_STARTADDRESS+0x1C))
+
+#define pISR_EINT0      (*(unsigned *)(_ISR_STARTADDRESS+0x20))
+#define pISR_EINT1      (*(unsigned *)(_ISR_STARTADDRESS+0x24))
+#define pISR_EINT2      (*(unsigned *)(_ISR_STARTADDRESS+0x28))
+#define pISR_EINT3      (*(unsigned *)(_ISR_STARTADDRESS+0x2C))
+#define pISR_EINT4_7        (*(unsigned *)(_ISR_STARTADDRESS+0x30))
+#define pISR_EINT8_23       (*(unsigned *)(_ISR_STARTADDRESS+0x34))
+#define pISR_BAT_FLT        (*(unsigned *)(_ISR_STARTADDRESS+0x3C))
+#define pISR_TICK       (*(unsigned *)(_ISR_STARTADDRESS+0x40))
+#define pISR_WDT        (*(unsigned *)(_ISR_STARTADDRESS+0x44))
+#define pISR_TIMER0     (*(unsigned *)(_ISR_STARTADDRESS+0x48))
+#define pISR_TIMER1     (*(unsigned *)(_ISR_STARTADDRESS+0x4C))
+#define pISR_TIMER2     (*(unsigned *)(_ISR_STARTADDRESS+0x50))
+#define pISR_TIMER3     (*(unsigned *)(_ISR_STARTADDRESS+0x54))
+#define pISR_TIMER4     (*(unsigned *)(_ISR_STARTADDRESS+0x58))
+#define pISR_UART2      (*(unsigned *)(_ISR_STARTADDRESS+0x5C))
+#define pISR_NOTUSED        (*(unsigned *)(_ISR_STARTADDRESS+0x60))
+#define pISR_DMA0       (*(unsigned *)(_ISR_STARTADDRESS+0x64))
+#define pISR_DMA1       (*(unsigned *)(_ISR_STARTADDRESS+0x68))
+#define pISR_DMA2       (*(unsigned *)(_ISR_STARTADDRESS+0x6C))
+#define pISR_DMA3       (*(unsigned *)(_ISR_STARTADDRESS+0x70))
+#define pISR_SDI        (*(unsigned *)(_ISR_STARTADDRESS+0x74))
+#define pISR_SPI0       (*(unsigned *)(_ISR_STARTADDRESS+0x78))
+#define pISR_UART1      (*(unsigned *)(_ISR_STARTADDRESS+0x7C))
+#define pISR_USBD       (*(unsigned *)(_ISR_STARTADDRESS+0x84))
+#define pISR_USBH       (*(unsigned *)(_ISR_STARTADDRESS+0x88))
+#define pISR_IIC        (*(unsigned *)(_ISR_STARTADDRESS+0x8C))
+#define pISR_UART0      (*(unsigned *)(_ISR_STARTADDRESS+0x90))
+#define pISR_SPI1       (*(unsigned *)(_ISR_STARTADDRESS+0x94))
+#define pISR_RTC        (*(unsigned *)(_ISR_STARTADDRESS+0x98))
+#define pISR_ADC        (*(unsigned *)(_ISR_STARTADDRESS+0xA0))
 
 
-/* PENDING BIT */
+// PENDING BIT
 #define BIT_EINT0		(0x1)
 #define BIT_EINT1		(0x1<<1)
 #define BIT_EINT2		(0x1<<2)
 #define BIT_EINT3		(0x1<<3)
 #define BIT_EINT4_7		(0x1<<4)
-#define BIT_EINT8_23		(0x1<<5)
+#define BIT_EINT8_23	(0x1<<5)
+#define BIT_CAM			(0x1<<6)		// Added for 2440.
 #define BIT_BAT_FLT		(0x1<<7)
-#define BIT_TICK		(0x1<<8)
-#define BIT_WDT			(0x1<<9)
+#define BIT_TICK			(0x1<<8)
+#define BIT_WDT_AC97	(0x1<<9)
 #define BIT_TIMER0		(0x1<<10)
 #define BIT_TIMER1		(0x1<<11)
 #define BIT_TIMER2		(0x1<<12)
@@ -207,21 +249,33 @@
 #define BIT_DMA2		(0x1<<19)
 #define BIT_DMA3		(0x1<<20)
 #define BIT_SDI			(0x1<<21)
-#define BIT_SPI0		(0x1<<22)
+#define BIT_SPI0			(0x1<<22)
 #define BIT_UART1		(0x1<<23)
+#define BIT_NFCON		(0x1<<24)		// Added for 2440.
 #define BIT_USBD		(0x1<<25)
 #define BIT_USBH		(0x1<<26)
 #define BIT_IIC			(0x1<<27)
 #define BIT_UART0		(0x1<<28)
-#define BIT_SPI1		(0x1<<29)
+#define BIT_SPI1			(0x1<<29)
 #define BIT_RTC			(0x1<<30)
 #define BIT_ADC			(0x1<<31)
-#define BIT_ALLMSK		(0xFFFFFFFF)
+#define BIT_ALLMSK		(0xffffffff)
+
+#define BIT_SUB_ALLMSK	(0x7fff)
+#define BIT_SUB_AC97 	(0x1<<14)
+#define BIT_SUB_WDT 	(0x1<<13)
+#define BIT_SUB_CAM_S	(0x1<<12)		// Added for 2440.
+#define BIT_SUB_CAM_C	(0x1<<11)		// Added for 2440.
+#define BIT_SUB_ADC		(0x1<<10)
+#define BIT_SUB_TC		(0x1<<9)
+#define BIT_SUB_ERR2	(0x1<<8)
+#define BIT_SUB_TXD2	(0x1<<7)
+#define BIT_SUB_RXD2	(0x1<<6)
+#define BIT_SUB_ERR1	(0x1<<5)
+#define BIT_SUB_TXD1	(0x1<<4)
+#define BIT_SUB_RXD1	(0x1<<3)
+#define BIT_SUB_ERR0	(0x1<<2)
+#define BIT_SUB_TXD0	(0x1<<1)
+#define BIT_SUB_RXD0	(0x1<<0)
 
-#define ClearPending(bit) {\
-		 rSRCPND = bit;\
-		 rINTPND = bit;\
-		 rINTPND;\
-		 }
-/* Wait until rINTPND is changed for the case that the ISR is very short. */
 #endif /*__S3C2410_H__*/
diff -urN u-boot-1.1.6/include/s3c24x0.h u-boot-1.1.6_jz2440/include/s3c24x0.h
--- u-boot-1.1.6/include/s3c24x0.h	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_jz2440/include/s3c24x0.h	2010-11-26 12:54:37.882083977 +0800
@@ -22,7 +22,7 @@
  */
 
 /************************************************
- * NAME	    : s3c24x0.h
+ * NAME     : s3c24x0.h
  * Version  : 31.3.2003
  *
  * common stuff for SAMSUNG S3C24X0 SoC
@@ -31,337 +31,363 @@
 #ifndef __S3C24X0_H__
 #define __S3C24X0_H__
 
-typedef volatile u8	S3C24X0_REG8;
-typedef volatile u16	S3C24X0_REG16;
-typedef volatile u32	S3C24X0_REG32;
+typedef volatile u8 S3C24X0_REG8;
+typedef volatile u16    S3C24X0_REG16;
+typedef volatile u32    S3C24X0_REG32;
 
 /* Memory controller (see manual chapter 5) */
 typedef struct {
-	S3C24X0_REG32	BWSCON;
-	S3C24X0_REG32	BANKCON[8];
-	S3C24X0_REG32	REFRESH;
-	S3C24X0_REG32	BANKSIZE;
-	S3C24X0_REG32	MRSRB6;
-	S3C24X0_REG32	MRSRB7;
+    S3C24X0_REG32   BWSCON;
+    S3C24X0_REG32   BANKCON[8];
+    S3C24X0_REG32   REFRESH;
+    S3C24X0_REG32   BANKSIZE;
+    S3C24X0_REG32   MRSRB6;
+    S3C24X0_REG32   MRSRB7;
 } /*__attribute__((__packed__))*/ S3C24X0_MEMCTL;
 
 
 /* USB HOST (see manual chapter 12) */
 typedef struct {
-	S3C24X0_REG32	HcRevision;
-	S3C24X0_REG32	HcControl;
-	S3C24X0_REG32	HcCommonStatus;
-	S3C24X0_REG32	HcInterruptStatus;
-	S3C24X0_REG32	HcInterruptEnable;
-	S3C24X0_REG32	HcInterruptDisable;
-	S3C24X0_REG32	HcHCCA;
-	S3C24X0_REG32	HcPeriodCuttendED;
-	S3C24X0_REG32	HcControlHeadED;
-	S3C24X0_REG32	HcControlCurrentED;
-	S3C24X0_REG32	HcBulkHeadED;
-	S3C24X0_REG32	HcBuldCurrentED;
-	S3C24X0_REG32	HcDoneHead;
-	S3C24X0_REG32	HcRmInterval;
-	S3C24X0_REG32	HcFmRemaining;
-	S3C24X0_REG32	HcFmNumber;
-	S3C24X0_REG32	HcPeriodicStart;
-	S3C24X0_REG32	HcLSThreshold;
-	S3C24X0_REG32	HcRhDescriptorA;
-	S3C24X0_REG32	HcRhDescriptorB;
-	S3C24X0_REG32	HcRhStatus;
-	S3C24X0_REG32	HcRhPortStatus1;
-	S3C24X0_REG32	HcRhPortStatus2;
+    S3C24X0_REG32   HcRevision;
+    S3C24X0_REG32   HcControl;
+    S3C24X0_REG32   HcCommonStatus;
+    S3C24X0_REG32   HcInterruptStatus;
+    S3C24X0_REG32   HcInterruptEnable;
+    S3C24X0_REG32   HcInterruptDisable;
+    S3C24X0_REG32   HcHCCA;
+    S3C24X0_REG32   HcPeriodCuttendED;
+    S3C24X0_REG32   HcControlHeadED;
+    S3C24X0_REG32   HcControlCurrentED;
+    S3C24X0_REG32   HcBulkHeadED;
+    S3C24X0_REG32   HcBuldCurrentED;
+    S3C24X0_REG32   HcDoneHead;
+    S3C24X0_REG32   HcRmInterval;
+    S3C24X0_REG32   HcFmRemaining;
+    S3C24X0_REG32   HcFmNumber;
+    S3C24X0_REG32   HcPeriodicStart;
+    S3C24X0_REG32   HcLSThreshold;
+    S3C24X0_REG32   HcRhDescriptorA;
+    S3C24X0_REG32   HcRhDescriptorB;
+    S3C24X0_REG32   HcRhStatus;
+    S3C24X0_REG32   HcRhPortStatus1;
+    S3C24X0_REG32   HcRhPortStatus2;
 } /*__attribute__((__packed__))*/ S3C24X0_USB_HOST;
 
 
 /* INTERRUPT (see manual chapter 14) */
 typedef struct {
-	S3C24X0_REG32	SRCPND;
-	S3C24X0_REG32	INTMOD;
-	S3C24X0_REG32	INTMSK;
-	S3C24X0_REG32	PRIORITY;
-	S3C24X0_REG32	INTPND;
-	S3C24X0_REG32	INTOFFSET;
+    S3C24X0_REG32   SRCPND;
+    S3C24X0_REG32   INTMOD;
+    S3C24X0_REG32   INTMSK;
+    S3C24X0_REG32   PRIORITY;
+    S3C24X0_REG32   INTPND;
+    S3C24X0_REG32   INTOFFSET;
 #ifdef CONFIG_S3C2410
-	S3C24X0_REG32	SUBSRCPND;
-	S3C24X0_REG32	INTSUBMSK;
+    S3C24X0_REG32   SUBSRCPND;
+    S3C24X0_REG32   INTSUBMSK;
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_INTERRUPT;
 
 
 /* DMAS (see manual chapter 8) */
 typedef struct {
-	S3C24X0_REG32	DISRC;
+    S3C24X0_REG32   DISRC;
 #ifdef CONFIG_S3C2410
-	S3C24X0_REG32	DISRCC;
+    S3C24X0_REG32   DISRCC;
 #endif
-	S3C24X0_REG32	DIDST;
+    S3C24X0_REG32   DIDST;
 #ifdef CONFIG_S3C2410
-	S3C24X0_REG32	DIDSTC;
+    S3C24X0_REG32   DIDSTC;
 #endif
-	S3C24X0_REG32	DCON;
-	S3C24X0_REG32	DSTAT;
-	S3C24X0_REG32	DCSRC;
-	S3C24X0_REG32	DCDST;
-	S3C24X0_REG32	DMASKTRIG;
+    S3C24X0_REG32   DCON;
+    S3C24X0_REG32   DSTAT;
+    S3C24X0_REG32   DCSRC;
+    S3C24X0_REG32   DCDST;
+    S3C24X0_REG32   DMASKTRIG;
 #ifdef CONFIG_S3C2400
-	S3C24X0_REG32	res[1];
+    S3C24X0_REG32   res[1];
 #endif
 #ifdef CONFIG_S3C2410
-	S3C24X0_REG32	res[7];
+    S3C24X0_REG32   res[7];
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_DMA;
 
 typedef struct {
-	S3C24X0_DMA	dma[4];
+    S3C24X0_DMA dma[4];
 } /*__attribute__((__packed__))*/ S3C24X0_DMAS;
 
 
 /* CLOCK & POWER MANAGEMENT (see S3C2400 manual chapter 6) */
 /*                          (see S3C2410 manual chapter 7) */
 typedef struct {
-	S3C24X0_REG32	LOCKTIME;
-	S3C24X0_REG32	MPLLCON;
-	S3C24X0_REG32	UPLLCON;
-	S3C24X0_REG32	CLKCON;
-	S3C24X0_REG32	CLKSLOW;
-	S3C24X0_REG32	CLKDIVN;
+    S3C24X0_REG32   LOCKTIME;
+    S3C24X0_REG32   MPLLCON;
+    S3C24X0_REG32   UPLLCON;
+    S3C24X0_REG32   CLKCON;
+    S3C24X0_REG32   CLKSLOW;
+    S3C24X0_REG32   CLKDIVN;
+    S3C24X0_REG32   CAMDIVN;    /* for s3c2440, by www.100ask.net */
 } /*__attribute__((__packed__))*/ S3C24X0_CLOCK_POWER;
 
 
 /* LCD CONTROLLER (see manual chapter 15) */
 typedef struct {
-	S3C24X0_REG32	LCDCON1;
-	S3C24X0_REG32	LCDCON2;
-	S3C24X0_REG32	LCDCON3;
-	S3C24X0_REG32	LCDCON4;
-	S3C24X0_REG32	LCDCON5;
-	S3C24X0_REG32	LCDSADDR1;
-	S3C24X0_REG32	LCDSADDR2;
-	S3C24X0_REG32	LCDSADDR3;
-	S3C24X0_REG32	REDLUT;
-	S3C24X0_REG32	GREENLUT;
-	S3C24X0_REG32	BLUELUT;
-	S3C24X0_REG32	res[8];
-	S3C24X0_REG32	DITHMODE;
-	S3C24X0_REG32	TPAL;
+    S3C24X0_REG32   LCDCON1;
+    S3C24X0_REG32   LCDCON2;
+    S3C24X0_REG32   LCDCON3;
+    S3C24X0_REG32   LCDCON4;
+    S3C24X0_REG32   LCDCON5;
+    S3C24X0_REG32   LCDSADDR1;
+    S3C24X0_REG32   LCDSADDR2;
+    S3C24X0_REG32   LCDSADDR3;
+    S3C24X0_REG32   REDLUT;
+    S3C24X0_REG32   GREENLUT;
+    S3C24X0_REG32   BLUELUT;
+    S3C24X0_REG32   res[8];
+    S3C24X0_REG32   DITHMODE;
+    S3C24X0_REG32   TPAL;
 #ifdef CONFIG_S3C2410
-	S3C24X0_REG32	LCDINTPND;
-	S3C24X0_REG32	LCDSRCPND;
-	S3C24X0_REG32	LCDINTMSK;
-	S3C24X0_REG32	LPCSEL;
+    S3C24X0_REG32   LCDINTPND;
+    S3C24X0_REG32   LCDSRCPND;
+    S3C24X0_REG32   LCDINTMSK;
+    S3C24X0_REG32   LPCSEL;
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_LCD;
 
 
 /* NAND FLASH (see S3C2410 manual chapter 6) */
 typedef struct {
-	S3C24X0_REG32	NFCONF;
-	S3C24X0_REG32	NFCMD;
-	S3C24X0_REG32	NFADDR;
-	S3C24X0_REG32	NFDATA;
-	S3C24X0_REG32	NFSTAT;
-	S3C24X0_REG32	NFECC;
+    S3C24X0_REG32   NFCONF;
+    S3C24X0_REG32   NFCMD;
+    S3C24X0_REG32   NFADDR;
+    S3C24X0_REG32   NFDATA;
+    S3C24X0_REG32   NFSTAT;
+    S3C24X0_REG32   NFECC;
 } /*__attribute__((__packed__))*/ S3C2410_NAND;
 
+/* NAND FLASH (see S3C2440 manual chapter 6, www.100ask.net) */
+typedef struct {
+    S3C24X0_REG32   NFCONF;
+    S3C24X0_REG32   NFCONT;
+    S3C24X0_REG32   NFCMD;
+    S3C24X0_REG32   NFADDR;
+    S3C24X0_REG32   NFDATA;
+    S3C24X0_REG32   NFMECCD0;
+    S3C24X0_REG32   NFMECCD1;
+    S3C24X0_REG32   NFSECCD;
+    S3C24X0_REG32   NFSTAT;
+    S3C24X0_REG32   NFESTAT0;
+    S3C24X0_REG32   NFESTAT1;
+    S3C24X0_REG32   NFMECC0;
+    S3C24X0_REG32   NFMECC1;
+    S3C24X0_REG32   NFSECC;
+    S3C24X0_REG32   NFSBLK;
+    S3C24X0_REG32   NFEBLK;
+} /*__attribute__((__packed__))*/ S3C2440_NAND;
 
 /* UART (see manual chapter 11) */
 typedef struct {
-	S3C24X0_REG32	ULCON;
-	S3C24X0_REG32	UCON;
-	S3C24X0_REG32	UFCON;
-	S3C24X0_REG32	UMCON;
-	S3C24X0_REG32	UTRSTAT;
-	S3C24X0_REG32	UERSTAT;
-	S3C24X0_REG32	UFSTAT;
-	S3C24X0_REG32	UMSTAT;
+    S3C24X0_REG32   ULCON;
+    S3C24X0_REG32   UCON;
+    S3C24X0_REG32   UFCON;
+    S3C24X0_REG32   UMCON;
+    S3C24X0_REG32   UTRSTAT;
+    S3C24X0_REG32   UERSTAT;
+    S3C24X0_REG32   UFSTAT;
+    S3C24X0_REG32   UMSTAT;
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	UTXH;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	URXH;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    UTXH;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    URXH;
 #else /* Little Endian */
-	S3C24X0_REG8	UTXH;
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	URXH;
-	S3C24X0_REG8	res2[3];
+    S3C24X0_REG8    UTXH;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    URXH;
+    S3C24X0_REG8    res2[3];
 #endif
-	S3C24X0_REG32	UBRDIV;
+    S3C24X0_REG32   UBRDIV;
 } /*__attribute__((__packed__))*/ S3C24X0_UART;
 
 
 /* PWM TIMER (see manual chapter 10) */
 typedef struct {
-	S3C24X0_REG32	TCNTB;
-	S3C24X0_REG32	TCMPB;
-	S3C24X0_REG32	TCNTO;
+    S3C24X0_REG32   TCNTB;
+    S3C24X0_REG32   TCMPB;
+    S3C24X0_REG32   TCNTO;
 } /*__attribute__((__packed__))*/ S3C24X0_TIMER;
 
 typedef struct {
-	S3C24X0_REG32	TCFG0;
-	S3C24X0_REG32	TCFG1;
-	S3C24X0_REG32	TCON;
-	S3C24X0_TIMER	ch[4];
-	S3C24X0_REG32	TCNTB4;
-	S3C24X0_REG32	TCNTO4;
+    S3C24X0_REG32   TCFG0;
+    S3C24X0_REG32   TCFG1;
+    S3C24X0_REG32   TCON;
+    S3C24X0_TIMER   ch[4];
+    S3C24X0_REG32   TCNTB4;
+    S3C24X0_REG32   TCNTO4;
 } /*__attribute__((__packed__))*/ S3C24X0_TIMERS;
 
 
 /* USB DEVICE (see manual chapter 13) */
 typedef struct {
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res[3];
-	S3C24X0_REG8	EP_FIFO_REG;
+    S3C24X0_REG8    res[3];
+    S3C24X0_REG8    EP_FIFO_REG;
 #else /*  little endian */
-	S3C24X0_REG8	EP_FIFO_REG;
-	S3C24X0_REG8	res[3];
+    S3C24X0_REG8    EP_FIFO_REG;
+    S3C24X0_REG8    res[3];
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_USB_DEV_FIFOS;
 
 typedef struct {
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	EP_DMA_CON;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	EP_DMA_UNIT;
-	S3C24X0_REG8	res3[3];
-	S3C24X0_REG8	EP_DMA_FIFO;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG8	EP_DMA_TTC_L;
-	S3C24X0_REG8	res5[3];
-	S3C24X0_REG8	EP_DMA_TTC_M;
-	S3C24X0_REG8	res6[3];
-	S3C24X0_REG8	EP_DMA_TTC_H;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    EP_DMA_CON;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    EP_DMA_UNIT;
+    S3C24X0_REG8    res3[3];
+    S3C24X0_REG8    EP_DMA_FIFO;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG8    EP_DMA_TTC_L;
+    S3C24X0_REG8    res5[3];
+    S3C24X0_REG8    EP_DMA_TTC_M;
+    S3C24X0_REG8    res6[3];
+    S3C24X0_REG8    EP_DMA_TTC_H;
 #else /*  little endian */
-	S3C24X0_REG8	EP_DMA_CON;
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	EP_DMA_UNIT;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	EP_DMA_FIFO;
-	S3C24X0_REG8	res3[3];
-	S3C24X0_REG8	EP_DMA_TTC_L;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG8	EP_DMA_TTC_M;
-	S3C24X0_REG8	res5[3];
-	S3C24X0_REG8	EP_DMA_TTC_H;
-	S3C24X0_REG8	res6[3];
+    S3C24X0_REG8    EP_DMA_CON;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    EP_DMA_UNIT;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    EP_DMA_FIFO;
+    S3C24X0_REG8    res3[3];
+    S3C24X0_REG8    EP_DMA_TTC_L;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG8    EP_DMA_TTC_M;
+    S3C24X0_REG8    res5[3];
+    S3C24X0_REG8    EP_DMA_TTC_H;
+    S3C24X0_REG8    res6[3];
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_USB_DEV_DMAS;
 
 typedef struct {
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	FUNC_ADDR_REG;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	PWR_REG;
-	S3C24X0_REG8	res3[3];
-	S3C24X0_REG8	EP_INT_REG;
-	S3C24X0_REG8	res4[15];
-	S3C24X0_REG8	USB_INT_REG;
-	S3C24X0_REG8	res5[3];
-	S3C24X0_REG8	EP_INT_EN_REG;
-	S3C24X0_REG8	res6[15];
-	S3C24X0_REG8	USB_INT_EN_REG;
-	S3C24X0_REG8	res7[3];
-	S3C24X0_REG8	FRAME_NUM1_REG;
-	S3C24X0_REG8	res8[3];
-	S3C24X0_REG8	FRAME_NUM2_REG;
-	S3C24X0_REG8	res9[3];
-	S3C24X0_REG8	INDEX_REG;
-	S3C24X0_REG8	res10[7];
-	S3C24X0_REG8	MAXP_REG;
-	S3C24X0_REG8	res11[3];
-	S3C24X0_REG8	EP0_CSR_IN_CSR1_REG;
-	S3C24X0_REG8	res12[3];
-	S3C24X0_REG8	IN_CSR2_REG;
-	S3C24X0_REG8	res13[7];
-	S3C24X0_REG8	OUT_CSR1_REG;
-	S3C24X0_REG8	res14[3];
-	S3C24X0_REG8	OUT_CSR2_REG;
-	S3C24X0_REG8	res15[3];
-	S3C24X0_REG8	OUT_FIFO_CNT1_REG;
-	S3C24X0_REG8	res16[3];
-	S3C24X0_REG8	OUT_FIFO_CNT2_REG;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    FUNC_ADDR_REG;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    PWR_REG;
+    S3C24X0_REG8    res3[3];
+    S3C24X0_REG8    EP_INT_REG;
+    S3C24X0_REG8    res4[15];
+    S3C24X0_REG8    USB_INT_REG;
+    S3C24X0_REG8    res5[3];
+    S3C24X0_REG8    EP_INT_EN_REG;
+    S3C24X0_REG8    res6[15];
+    S3C24X0_REG8    USB_INT_EN_REG;
+    S3C24X0_REG8    res7[3];
+    S3C24X0_REG8    FRAME_NUM1_REG;
+    S3C24X0_REG8    res8[3];
+    S3C24X0_REG8    FRAME_NUM2_REG;
+    S3C24X0_REG8    res9[3];
+    S3C24X0_REG8    INDEX_REG;
+    S3C24X0_REG8    res10[7];
+    S3C24X0_REG8    MAXP_REG;
+    S3C24X0_REG8    res11[3];
+    S3C24X0_REG8    EP0_CSR_IN_CSR1_REG;
+    S3C24X0_REG8    res12[3];
+    S3C24X0_REG8    IN_CSR2_REG;
+    S3C24X0_REG8    res13[7];
+    S3C24X0_REG8    OUT_CSR1_REG;
+    S3C24X0_REG8    res14[3];
+    S3C24X0_REG8    OUT_CSR2_REG;
+    S3C24X0_REG8    res15[3];
+    S3C24X0_REG8    OUT_FIFO_CNT1_REG;
+    S3C24X0_REG8    res16[3];
+    S3C24X0_REG8    OUT_FIFO_CNT2_REG;
 #else /*  little endian */
-	S3C24X0_REG8	FUNC_ADDR_REG;
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	PWR_REG;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	EP_INT_REG;
-	S3C24X0_REG8	res3[15];
-	S3C24X0_REG8	USB_INT_REG;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG8	EP_INT_EN_REG;
-	S3C24X0_REG8	res5[15];
-	S3C24X0_REG8	USB_INT_EN_REG;
-	S3C24X0_REG8	res6[3];
-	S3C24X0_REG8	FRAME_NUM1_REG;
-	S3C24X0_REG8	res7[3];
-	S3C24X0_REG8	FRAME_NUM2_REG;
-	S3C24X0_REG8	res8[3];
-	S3C24X0_REG8	INDEX_REG;
-	S3C24X0_REG8	res9[7];
-	S3C24X0_REG8	MAXP_REG;
-	S3C24X0_REG8	res10[7];
-	S3C24X0_REG8	EP0_CSR_IN_CSR1_REG;
-	S3C24X0_REG8	res11[3];
-	S3C24X0_REG8	IN_CSR2_REG;
-	S3C24X0_REG8	res12[3];
-	S3C24X0_REG8	OUT_CSR1_REG;
-	S3C24X0_REG8	res13[7];
-	S3C24X0_REG8	OUT_CSR2_REG;
-	S3C24X0_REG8	res14[3];
-	S3C24X0_REG8	OUT_FIFO_CNT1_REG;
-	S3C24X0_REG8	res15[3];
-	S3C24X0_REG8	OUT_FIFO_CNT2_REG;
-	S3C24X0_REG8	res16[3];
+    S3C24X0_REG8    FUNC_ADDR_REG;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    PWR_REG;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    EP_INT_REG;
+    S3C24X0_REG8    res3[15];
+    S3C24X0_REG8    USB_INT_REG;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG8    EP_INT_EN_REG;
+    S3C24X0_REG8    res5[15];
+    S3C24X0_REG8    USB_INT_EN_REG;
+    S3C24X0_REG8    res6[3];
+    S3C24X0_REG8    FRAME_NUM1_REG;
+    S3C24X0_REG8    res7[3];
+    S3C24X0_REG8    FRAME_NUM2_REG;
+    S3C24X0_REG8    res8[3];
+    S3C24X0_REG8    INDEX_REG;
+    S3C24X0_REG8    res9[7];
+    S3C24X0_REG8    MAXP_REG;
+    S3C24X0_REG8    res10[3];
+    S3C24X0_REG8    EP0_CSR_IN_CSR1_REG;
+    S3C24X0_REG8    res11[3];
+    S3C24X0_REG8    IN_CSR2_REG;
+    S3C24X0_REG8    res12[7];
+    S3C24X0_REG8    OUT_CSR1_REG;
+    S3C24X0_REG8    res13[3];
+    S3C24X0_REG8    OUT_CSR2_REG;
+    S3C24X0_REG8    res14[3];
+    S3C24X0_REG8    OUT_FIFO_CNT1_REG;
+    S3C24X0_REG8    res15[3];
+    S3C24X0_REG8    OUT_FIFO_CNT2_REG;
+    S3C24X0_REG8    res16[3];
 #endif /*  __BIG_ENDIAN */
-	S3C24X0_USB_DEV_FIFOS	fifo[5];
-	S3C24X0_USB_DEV_DMAS	dma[5];
+    S3C24X0_REG32   res17[8];
+    S3C24X0_USB_DEV_FIFOS   fifo[5];
+    S3C24X0_REG32   res18[11];
+    S3C24X0_USB_DEV_DMAS    ep1;
+    S3C24X0_USB_DEV_DMAS    ep2;
+    S3C24X0_REG8    res19[16];
+    S3C24X0_USB_DEV_DMAS    ep3;
+    S3C24X0_USB_DEV_DMAS    ep4;
 } /*__attribute__((__packed__))*/ S3C24X0_USB_DEVICE;
 
 
 /* WATCH DOG TIMER (see manual chapter 18) */
 typedef struct {
-	S3C24X0_REG32	WTCON;
-	S3C24X0_REG32	WTDAT;
-	S3C24X0_REG32	WTCNT;
+    S3C24X0_REG32   WTCON;
+    S3C24X0_REG32   WTDAT;
+    S3C24X0_REG32   WTCNT;
 } /*__attribute__((__packed__))*/ S3C24X0_WATCHDOG;
 
 
 /* IIC (see manual chapter 20) */
 typedef struct {
-	S3C24X0_REG32	IICCON;
-	S3C24X0_REG32	IICSTAT;
-	S3C24X0_REG32	IICADD;
-	S3C24X0_REG32	IICDS;
+    S3C24X0_REG32   IICCON;
+    S3C24X0_REG32   IICSTAT;
+    S3C24X0_REG32   IICADD;
+    S3C24X0_REG32   IICDS;
 } /*__attribute__((__packed__))*/ S3C24X0_I2C;
 
 
 /* IIS (see manual chapter 21) */
 typedef struct {
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG16	res1;
-	S3C24X0_REG16	IISCON;
-	S3C24X0_REG16	res2;
-	S3C24X0_REG16	IISMOD;
-	S3C24X0_REG16	res3;
-	S3C24X0_REG16	IISPSR;
-	S3C24X0_REG16	res4;
-	S3C24X0_REG16	IISFCON;
-	S3C24X0_REG16	res5;
-	S3C24X0_REG16	IISFIFO;
+    S3C24X0_REG16   res1;
+    S3C24X0_REG16   IISCON;
+    S3C24X0_REG16   res2;
+    S3C24X0_REG16   IISMOD;
+    S3C24X0_REG16   res3;
+    S3C24X0_REG16   IISPSR;
+    S3C24X0_REG16   res4;
+    S3C24X0_REG16   IISFCON;
+    S3C24X0_REG16   res5;
+    S3C24X0_REG16   IISFIFO;
 #else /*  little endian */
-	S3C24X0_REG16	IISCON;
-	S3C24X0_REG16	res1;
-	S3C24X0_REG16	IISMOD;
-	S3C24X0_REG16	res2;
-	S3C24X0_REG16	IISPSR;
-	S3C24X0_REG16	res3;
-	S3C24X0_REG16	IISFCON;
-	S3C24X0_REG16	res4;
-	S3C24X0_REG16	IISFIFO;
-	S3C24X0_REG16	res5;
+    S3C24X0_REG16   IISCON;
+    S3C24X0_REG16   res1;
+    S3C24X0_REG16   IISMOD;
+    S3C24X0_REG16   res2;
+    S3C24X0_REG16   IISPSR;
+    S3C24X0_REG16   res3;
+    S3C24X0_REG16   IISFCON;
+    S3C24X0_REG16   res4;
+    S3C24X0_REG16   IISFIFO;
+    S3C24X0_REG16   res5;
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_I2S;
 
@@ -369,87 +395,93 @@
 /* I/O PORT (see manual chapter 9) */
 typedef struct {
 #ifdef CONFIG_S3C2400
-	S3C24X0_REG32	PACON;
-	S3C24X0_REG32	PADAT;
+    S3C24X0_REG32   PACON;
+    S3C24X0_REG32   PADAT;
 
-	S3C24X0_REG32	PBCON;
-	S3C24X0_REG32	PBDAT;
-	S3C24X0_REG32	PBUP;
+    S3C24X0_REG32   PBCON;
+    S3C24X0_REG32   PBDAT;
+    S3C24X0_REG32   PBUP;
 
-	S3C24X0_REG32	PCCON;
-	S3C24X0_REG32	PCDAT;
-	S3C24X0_REG32	PCUP;
+    S3C24X0_REG32   PCCON;
+    S3C24X0_REG32   PCDAT;
+    S3C24X0_REG32   PCUP;
 
-	S3C24X0_REG32	PDCON;
-	S3C24X0_REG32	PDDAT;
-	S3C24X0_REG32	PDUP;
+    S3C24X0_REG32   PDCON;
+    S3C24X0_REG32   PDDAT;
+    S3C24X0_REG32   PDUP;
 
-	S3C24X0_REG32	PECON;
-	S3C24X0_REG32	PEDAT;
-	S3C24X0_REG32	PEUP;
+    S3C24X0_REG32   PECON;
+    S3C24X0_REG32   PEDAT;
+    S3C24X0_REG32   PEUP;
 
-	S3C24X0_REG32	PFCON;
-	S3C24X0_REG32	PFDAT;
-	S3C24X0_REG32	PFUP;
+    S3C24X0_REG32   PFCON;
+    S3C24X0_REG32   PFDAT;
+    S3C24X0_REG32   PFUP;
 
-	S3C24X0_REG32	PGCON;
-	S3C24X0_REG32	PGDAT;
-	S3C24X0_REG32	PGUP;
+    S3C24X0_REG32   PGCON;
+    S3C24X0_REG32   PGDAT;
+    S3C24X0_REG32   PGUP;
 
-	S3C24X0_REG32	OPENCR;
+    S3C24X0_REG32   OPENCR;
 
-	S3C24X0_REG32	MISCCR;
-	S3C24X0_REG32	EXTINT;
+    S3C24X0_REG32   MISCCR;
+    S3C24X0_REG32   EXTINT;
 #endif
 #ifdef CONFIG_S3C2410
-	S3C24X0_REG32	GPACON;
-	S3C24X0_REG32	GPADAT;
-	S3C24X0_REG32	res1[2];
-	S3C24X0_REG32	GPBCON;
-	S3C24X0_REG32	GPBDAT;
-	S3C24X0_REG32	GPBUP;
-	S3C24X0_REG32	res2;
-	S3C24X0_REG32	GPCCON;
-	S3C24X0_REG32	GPCDAT;
-	S3C24X0_REG32	GPCUP;
-	S3C24X0_REG32	res3;
-	S3C24X0_REG32	GPDCON;
-	S3C24X0_REG32	GPDDAT;
-	S3C24X0_REG32	GPDUP;
-	S3C24X0_REG32	res4;
-	S3C24X0_REG32	GPECON;
-	S3C24X0_REG32	GPEDAT;
-	S3C24X0_REG32	GPEUP;
-	S3C24X0_REG32	res5;
-	S3C24X0_REG32	GPFCON;
-	S3C24X0_REG32	GPFDAT;
-	S3C24X0_REG32	GPFUP;
-	S3C24X0_REG32	res6;
-	S3C24X0_REG32	GPGCON;
-	S3C24X0_REG32	GPGDAT;
-	S3C24X0_REG32	GPGUP;
-	S3C24X0_REG32	res7;
-	S3C24X0_REG32	GPHCON;
-	S3C24X0_REG32	GPHDAT;
-	S3C24X0_REG32	GPHUP;
-	S3C24X0_REG32	res8;
-
-	S3C24X0_REG32	MISCCR;
-	S3C24X0_REG32	DCLKCON;
-	S3C24X0_REG32	EXTINT0;
-	S3C24X0_REG32	EXTINT1;
-	S3C24X0_REG32	EXTINT2;
-	S3C24X0_REG32	EINTFLT0;
-	S3C24X0_REG32	EINTFLT1;
-	S3C24X0_REG32	EINTFLT2;
-	S3C24X0_REG32	EINTFLT3;
-	S3C24X0_REG32	EINTMASK;
-	S3C24X0_REG32	EINTPEND;
-	S3C24X0_REG32	GSTATUS0;
-	S3C24X0_REG32	GSTATUS1;
-	S3C24X0_REG32	GSTATUS2;
-	S3C24X0_REG32	GSTATUS3;
-	S3C24X0_REG32	GSTATUS4;
+    S3C24X0_REG32   GPACON;
+    S3C24X0_REG32   GPADAT;
+    S3C24X0_REG32   res1[2];
+    S3C24X0_REG32   GPBCON;
+    S3C24X0_REG32   GPBDAT;
+    S3C24X0_REG32   GPBUP;
+    S3C24X0_REG32   res2;
+    S3C24X0_REG32   GPCCON;
+    S3C24X0_REG32   GPCDAT;
+    S3C24X0_REG32   GPCUP;
+    S3C24X0_REG32   res3;
+    S3C24X0_REG32   GPDCON;
+    S3C24X0_REG32   GPDDAT;
+    S3C24X0_REG32   GPDUP;
+    S3C24X0_REG32   res4;
+    S3C24X0_REG32   GPECON;
+    S3C24X0_REG32   GPEDAT;
+    S3C24X0_REG32   GPEUP;
+    S3C24X0_REG32   res5;
+    S3C24X0_REG32   GPFCON;
+    S3C24X0_REG32   GPFDAT;
+    S3C24X0_REG32   GPFUP;
+    S3C24X0_REG32   res6;
+    S3C24X0_REG32   GPGCON;
+    S3C24X0_REG32   GPGDAT;
+    S3C24X0_REG32   GPGUP;
+    S3C24X0_REG32   res7;
+    S3C24X0_REG32   GPHCON;
+    S3C24X0_REG32   GPHDAT;
+    S3C24X0_REG32   GPHUP;
+    S3C24X0_REG32   res8;
+
+    S3C24X0_REG32   MISCCR;
+    S3C24X0_REG32   DCLKCON;
+    S3C24X0_REG32   EXTINT0;
+    S3C24X0_REG32   EXTINT1;
+    S3C24X0_REG32   EXTINT2;
+    S3C24X0_REG32   EINTFLT0;
+    S3C24X0_REG32   EINTFLT1;
+    S3C24X0_REG32   EINTFLT2;
+    S3C24X0_REG32   EINTFLT3;
+    S3C24X0_REG32   EINTMASK;
+    S3C24X0_REG32   EINTPEND;
+    S3C24X0_REG32   GSTATUS0;
+    S3C24X0_REG32   GSTATUS1;
+    S3C24X0_REG32   GSTATUS2;
+    S3C24X0_REG32   GSTATUS3;
+    S3C24X0_REG32   GSTATUS4;
+
+    /* s3c2440 */
+    S3C24X0_REG32   res9[4];
+    S3C24X0_REG32   GPJCON;
+    S3C24X0_REG32   GPJDAT;
+    S3C24X0_REG32   GPJUP;
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_GPIO;
 
@@ -457,679 +489,682 @@
 /* RTC (see manual chapter 17) */
 typedef struct {
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res1[67];
-	S3C24X0_REG8	RTCCON;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	TICNT;
-	S3C24X0_REG8	res3[11];
-	S3C24X0_REG8	RTCALM;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG8	ALMSEC;
-	S3C24X0_REG8	res5[3];
-	S3C24X0_REG8	ALMMIN;
-	S3C24X0_REG8	res6[3];
-	S3C24X0_REG8	ALMHOUR;
-	S3C24X0_REG8	res7[3];
-	S3C24X0_REG8	ALMDATE;
-	S3C24X0_REG8	res8[3];
-	S3C24X0_REG8	ALMMON;
-	S3C24X0_REG8	res9[3];
-	S3C24X0_REG8	ALMYEAR;
-	S3C24X0_REG8	res10[3];
-	S3C24X0_REG8	RTCRST;
-	S3C24X0_REG8	res11[3];
-	S3C24X0_REG8	BCDSEC;
-	S3C24X0_REG8	res12[3];
-	S3C24X0_REG8	BCDMIN;
-	S3C24X0_REG8	res13[3];
-	S3C24X0_REG8	BCDHOUR;
-	S3C24X0_REG8	res14[3];
-	S3C24X0_REG8	BCDDATE;
-	S3C24X0_REG8	res15[3];
-	S3C24X0_REG8	BCDDAY;
-	S3C24X0_REG8	res16[3];
-	S3C24X0_REG8	BCDMON;
-	S3C24X0_REG8	res17[3];
-	S3C24X0_REG8	BCDYEAR;
+    S3C24X0_REG8    res1[67];
+    S3C24X0_REG8    RTCCON;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    TICNT;
+    S3C24X0_REG8    res3[11];
+    S3C24X0_REG8    RTCALM;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG8    ALMSEC;
+    S3C24X0_REG8    res5[3];
+    S3C24X0_REG8    ALMMIN;
+    S3C24X0_REG8    res6[3];
+    S3C24X0_REG8    ALMHOUR;
+    S3C24X0_REG8    res7[3];
+    S3C24X0_REG8    ALMDATE;
+    S3C24X0_REG8    res8[3];
+    S3C24X0_REG8    ALMMON;
+    S3C24X0_REG8    res9[3];
+    S3C24X0_REG8    ALMYEAR;
+    S3C24X0_REG8    res10[3];
+    S3C24X0_REG8    RTCRST;
+    S3C24X0_REG8    res11[3];
+    S3C24X0_REG8    BCDSEC;
+    S3C24X0_REG8    res12[3];
+    S3C24X0_REG8    BCDMIN;
+    S3C24X0_REG8    res13[3];
+    S3C24X0_REG8    BCDHOUR;
+    S3C24X0_REG8    res14[3];
+    S3C24X0_REG8    BCDDATE;
+    S3C24X0_REG8    res15[3];
+    S3C24X0_REG8    BCDDAY;
+    S3C24X0_REG8    res16[3];
+    S3C24X0_REG8    BCDMON;
+    S3C24X0_REG8    res17[3];
+    S3C24X0_REG8    BCDYEAR;
 #else /*  little endian */
-	S3C24X0_REG8	res0[64];
-	S3C24X0_REG8	RTCCON;
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	TICNT;
-	S3C24X0_REG8	res2[11];
-	S3C24X0_REG8	RTCALM;
-	S3C24X0_REG8	res3[3];
-	S3C24X0_REG8	ALMSEC;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG8	ALMMIN;
-	S3C24X0_REG8	res5[3];
-	S3C24X0_REG8	ALMHOUR;
-	S3C24X0_REG8	res6[3];
-	S3C24X0_REG8	ALMDATE;
-	S3C24X0_REG8	res7[3];
-	S3C24X0_REG8	ALMMON;
-	S3C24X0_REG8	res8[3];
-	S3C24X0_REG8	ALMYEAR;
-	S3C24X0_REG8	res9[3];
-	S3C24X0_REG8	RTCRST;
-	S3C24X0_REG8	res10[3];
-	S3C24X0_REG8	BCDSEC;
-	S3C24X0_REG8	res11[3];
-	S3C24X0_REG8	BCDMIN;
-	S3C24X0_REG8	res12[3];
-	S3C24X0_REG8	BCDHOUR;
-	S3C24X0_REG8	res13[3];
-	S3C24X0_REG8	BCDDATE;
-	S3C24X0_REG8	res14[3];
-	S3C24X0_REG8	BCDDAY;
-	S3C24X0_REG8	res15[3];
-	S3C24X0_REG8	BCDMON;
-	S3C24X0_REG8	res16[3];
-	S3C24X0_REG8	BCDYEAR;
-	S3C24X0_REG8	res17[3];
+    S3C24X0_REG8    res0[64];
+    S3C24X0_REG8    RTCCON;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    TICNT;
+    S3C24X0_REG8    res2[11];
+    S3C24X0_REG8    RTCALM;
+    S3C24X0_REG8    res3[3];
+    S3C24X0_REG8    ALMSEC;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG8    ALMMIN;
+    S3C24X0_REG8    res5[3];
+    S3C24X0_REG8    ALMHOUR;
+    S3C24X0_REG8    res6[3];
+    S3C24X0_REG8    ALMDATE;
+    S3C24X0_REG8    res7[3];
+    S3C24X0_REG8    ALMMON;
+    S3C24X0_REG8    res8[3];
+    S3C24X0_REG8    ALMYEAR;
+    S3C24X0_REG8    res9[3];
+    S3C24X0_REG8    RTCRST;
+    S3C24X0_REG8    res10[3];
+    S3C24X0_REG8    BCDSEC;
+    S3C24X0_REG8    res11[3];
+    S3C24X0_REG8    BCDMIN;
+    S3C24X0_REG8    res12[3];
+    S3C24X0_REG8    BCDHOUR;
+    S3C24X0_REG8    res13[3];
+    S3C24X0_REG8    BCDDATE;
+    S3C24X0_REG8    res14[3];
+    S3C24X0_REG8    BCDDAY;
+    S3C24X0_REG8    res15[3];
+    S3C24X0_REG8    BCDMON;
+    S3C24X0_REG8    res16[3];
+    S3C24X0_REG8    BCDYEAR;
+    S3C24X0_REG8    res17[3];
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_RTC;
 
 
 /* ADC (see manual chapter 16) */
 typedef struct {
-	S3C24X0_REG32	ADCCON;
-	S3C24X0_REG32	ADCDAT;
+    S3C24X0_REG32   ADCCON;
+    S3C24X0_REG32   ADCDAT;
 } /*__attribute__((__packed__))*/ S3C2400_ADC;
 
 
 /* ADC (see manual chapter 16) */
 typedef struct {
-	S3C24X0_REG32	ADCCON;
-	S3C24X0_REG32	ADCTSC;
-	S3C24X0_REG32	ADCDLY;
-	S3C24X0_REG32	ADCDAT0;
-	S3C24X0_REG32	ADCDAT1;
+    S3C24X0_REG32   ADCCON;
+    S3C24X0_REG32   ADCTSC;
+    S3C24X0_REG32   ADCDLY;
+    S3C24X0_REG32   ADCDAT0;
+    S3C24X0_REG32   ADCDAT1;
 } /*__attribute__((__packed__))*/ S3C2410_ADC;
 
 
 /* SPI (see manual chapter 22) */
 typedef struct {
-	S3C24X0_REG32	SPCON;
-	S3C24X0_REG32	SPSTA;
-	S3C24X0_REG32	SPPIN;
-	S3C24X0_REG32	SPPRE;
-	S3C24X0_REG32	SPTDAT;
-	S3C24X0_REG32	SPRDAT;
-	S3C24X0_REG32	res[2];
+    S3C24X0_REG32   SPCON;
+    S3C24X0_REG32   SPSTA;
+    S3C24X0_REG32   SPPIN;
+    S3C24X0_REG32   SPPRE;
+    S3C24X0_REG32   SPTDAT;
+    S3C24X0_REG32   SPRDAT;
+    S3C24X0_REG32   res[2];
 } __attribute__((__packed__)) S3C24X0_SPI_CHANNEL;
 
 typedef struct {
-	S3C24X0_SPI_CHANNEL	ch[S3C24X0_SPI_CHANNELS];
+    S3C24X0_SPI_CHANNEL ch[S3C24X0_SPI_CHANNELS];
 } /*__attribute__((__packed__))*/ S3C24X0_SPI;
 
 
 /* MMC INTERFACE (see S3C2400 manual chapter 19) */
 typedef struct {
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	MMCON;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	MMCRR;
-	S3C24X0_REG8	res3[3];
-	S3C24X0_REG8	MMFCON;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG8	MMSTA;
-	S3C24X0_REG16	res5;
-	S3C24X0_REG16	MMFSTA;
-	S3C24X0_REG8	res6[3];
-	S3C24X0_REG8	MMPRE;
-	S3C24X0_REG16	res7;
-	S3C24X0_REG16	MMLEN;
-	S3C24X0_REG8	res8[3];
-	S3C24X0_REG8	MMCR7;
-	S3C24X0_REG32	MMRSP[4];
-	S3C24X0_REG8	res9[3];
-	S3C24X0_REG8	MMCMD0;
-	S3C24X0_REG32	MMCMD1;
-	S3C24X0_REG16	res10;
-	S3C24X0_REG16	MMCR16;
-	S3C24X0_REG8	res11[3];
-	S3C24X0_REG8	MMDAT;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    MMCON;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    MMCRR;
+    S3C24X0_REG8    res3[3];
+    S3C24X0_REG8    MMFCON;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG8    MMSTA;
+    S3C24X0_REG16   res5;
+    S3C24X0_REG16   MMFSTA;
+    S3C24X0_REG8    res6[3];
+    S3C24X0_REG8    MMPRE;
+    S3C24X0_REG16   res7;
+    S3C24X0_REG16   MMLEN;
+    S3C24X0_REG8    res8[3];
+    S3C24X0_REG8    MMCR7;
+    S3C24X0_REG32   MMRSP[4];
+    S3C24X0_REG8    res9[3];
+    S3C24X0_REG8    MMCMD0;
+    S3C24X0_REG32   MMCMD1;
+    S3C24X0_REG16   res10;
+    S3C24X0_REG16   MMCR16;
+    S3C24X0_REG8    res11[3];
+    S3C24X0_REG8    MMDAT;
 #else
-	S3C24X0_REG8	MMCON;
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	MMCRR;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	MMFCON;
-	S3C24X0_REG8	res3[3];
-	S3C24X0_REG8	MMSTA;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG16	MMFSTA;
-	S3C24X0_REG16	res5;
-	S3C24X0_REG8	MMPRE;
-	S3C24X0_REG8	res6[3];
-	S3C24X0_REG16	MMLEN;
-	S3C24X0_REG16	res7;
-	S3C24X0_REG8	MMCR7;
-	S3C24X0_REG8	res8[3];
-	S3C24X0_REG32	MMRSP[4];
-	S3C24X0_REG8	MMCMD0;
-	S3C24X0_REG8	res9[3];
-	S3C24X0_REG32	MMCMD1;
-	S3C24X0_REG16	MMCR16;
-	S3C24X0_REG16	res10;
-	S3C24X0_REG8	MMDAT;
-	S3C24X0_REG8	res11[3];
+    S3C24X0_REG8    MMCON;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    MMCRR;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    MMFCON;
+    S3C24X0_REG8    res3[3];
+    S3C24X0_REG8    MMSTA;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG16   MMFSTA;
+    S3C24X0_REG16   res5;
+    S3C24X0_REG8    MMPRE;
+    S3C24X0_REG8    res6[3];
+    S3C24X0_REG16   MMLEN;
+    S3C24X0_REG16   res7;
+    S3C24X0_REG8    MMCR7;
+    S3C24X0_REG8    res8[3];
+    S3C24X0_REG32   MMRSP[4];
+    S3C24X0_REG8    MMCMD0;
+    S3C24X0_REG8    res9[3];
+    S3C24X0_REG32   MMCMD1;
+    S3C24X0_REG16   MMCR16;
+    S3C24X0_REG16   res10;
+    S3C24X0_REG8    MMDAT;
+    S3C24X0_REG8    res11[3];
 #endif
 } /*__attribute__((__packed__))*/ S3C2400_MMC;
 
 
 /* SD INTERFACE (see S3C2410 manual chapter 19) */
 typedef struct {
-	S3C24X0_REG32	SDICON;
-	S3C24X0_REG32	SDIPRE;
-	S3C24X0_REG32	SDICARG;
-	S3C24X0_REG32	SDICCON;
-	S3C24X0_REG32	SDICSTA;
-	S3C24X0_REG32	SDIRSP0;
-	S3C24X0_REG32	SDIRSP1;
-	S3C24X0_REG32	SDIRSP2;
-	S3C24X0_REG32	SDIRSP3;
-	S3C24X0_REG32	SDIDTIMER;
-	S3C24X0_REG32	SDIBSIZE;
-	S3C24X0_REG32	SDIDCON;
-	S3C24X0_REG32	SDIDCNT;
-	S3C24X0_REG32	SDIDSTA;
-	S3C24X0_REG32	SDIFSTA;
+    S3C24X0_REG32   SDICON;
+    S3C24X0_REG32   SDIPRE;
+    S3C24X0_REG32   SDICARG;
+    S3C24X0_REG32   SDICCON;
+    S3C24X0_REG32   SDICSTA;
+    S3C24X0_REG32   SDIRSP0;
+    S3C24X0_REG32   SDIRSP1;
+    S3C24X0_REG32   SDIRSP2;
+    S3C24X0_REG32   SDIRSP3;
+    S3C24X0_REG32   SDIDTIMER;
+    S3C24X0_REG32   SDIBSIZE;
+    S3C24X0_REG32   SDIDCON;
+    S3C24X0_REG32   SDIDCNT;
+    S3C24X0_REG32   SDIDSTA;
+    S3C24X0_REG32   SDIFSTA;
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res[3];
-	S3C24X0_REG8	SDIDAT;
+    S3C24X0_REG8    res[3];
+    S3C24X0_REG8    SDIDAT;
 #else
-	S3C24X0_REG8	SDIDAT;
-	S3C24X0_REG8	res[3];
+    S3C24X0_REG8    SDIDAT;
+    S3C24X0_REG8    res[3];
 #endif
-	S3C24X0_REG32	SDIIMSK;
+    S3C24X0_REG32   SDIIMSK;
 } /*__attribute__((__packed__))*/ S3C2410_SDI;
 
 
 #if 0
 /* Memory control */
-#define rBWSCON			(*(volatile unsigned *)0x48000000)
-#define rBANKCON0		(*(volatile unsigned *)0x48000004)
-#define rBANKCON1		(*(volatile unsigned *)0x48000008)
-#define rBANKCON2		(*(volatile unsigned *)0x4800000C)
-#define rBANKCON3		(*(volatile unsigned *)0x48000010)
-#define rBANKCON4		(*(volatile unsigned *)0x48000014)
-#define rBANKCON5		(*(volatile unsigned *)0x48000018)
-#define rBANKCON6		(*(volatile unsigned *)0x4800001C)
-#define rBANKCON7		(*(volatile unsigned *)0x48000020)
-#define rREFRESH		(*(volatile unsigned *)0x48000024)
-#define rBANKSIZE		(*(volatile unsigned *)0x48000028)
-#define rMRSRB6			(*(volatile unsigned *)0x4800002C)
-#define rMRSRB7			(*(volatile unsigned *)0x48000030)
+#define rBWSCON         (*(volatile unsigned *)0x48000000)
+#define rBANKCON0       (*(volatile unsigned *)0x48000004)
+#define rBANKCON1       (*(volatile unsigned *)0x48000008)
+#define rBANKCON2       (*(volatile unsigned *)0x4800000C)
+#define rBANKCON3       (*(volatile unsigned *)0x48000010)
+#define rBANKCON4       (*(volatile unsigned *)0x48000014)
+#define rBANKCON5       (*(volatile unsigned *)0x48000018)
+#define rBANKCON6       (*(volatile unsigned *)0x4800001C)
+#define rBANKCON7       (*(volatile unsigned *)0x48000020)
+#define rREFRESH        (*(volatile unsigned *)0x48000024)
+#define rBANKSIZE       (*(volatile unsigned *)0x48000028)
+#define rMRSRB6         (*(volatile unsigned *)0x4800002C)
+#define rMRSRB7         (*(volatile unsigned *)0x48000030)
 
 
 /* USB HOST */
-#define rHcRevision		(*(volatile unsigned *)0x49000000)
-#define rHcControl		(*(volatile unsigned *)0x49000004)
-#define rHcCommonStatus		(*(volatile unsigned *)0x49000008)
-#define rHcInterruptStatus	(*(volatile unsigned *)0x4900000C)
-#define rHcInterruptEnable	(*(volatile unsigned *)0x49000010)
-#define rHcInterruptDisable	(*(volatile unsigned *)0x49000014)
-#define rHcHCCA			(*(volatile unsigned *)0x49000018)
-#define rHcPeriodCuttendED	(*(volatile unsigned *)0x4900001C)
-#define rHcControlHeadED	(*(volatile unsigned *)0x49000020)
-#define rHcControlCurrentED	(*(volatile unsigned *)0x49000024)
-#define rHcBulkHeadED		(*(volatile unsigned *)0x49000028)
-#define rHcBuldCurrentED	(*(volatile unsigned *)0x4900002C)
-#define rHcDoneHead		(*(volatile unsigned *)0x49000030)
-#define rHcRmInterval		(*(volatile unsigned *)0x49000034)
-#define rHcFmRemaining		(*(volatile unsigned *)0x49000038)
-#define rHcFmNumber		(*(volatile unsigned *)0x4900003C)
-#define rHcPeriodicStart	(*(volatile unsigned *)0x49000040)
-#define rHcLSThreshold		(*(volatile unsigned *)0x49000044)
-#define rHcRhDescriptorA	(*(volatile unsigned *)0x49000048)
-#define rHcRhDescriptorB	(*(volatile unsigned *)0x4900004C)
-#define rHcRhStatus		(*(volatile unsigned *)0x49000050)
-#define rHcRhPortStatus1	(*(volatile unsigned *)0x49000054)
-#define rHcRhPortStatus2	(*(volatile unsigned *)0x49000058)
+#define rHcRevision     (*(volatile unsigned *)0x49000000)
+#define rHcControl      (*(volatile unsigned *)0x49000004)
+#define rHcCommonStatus     (*(volatile unsigned *)0x49000008)
+#define rHcInterruptStatus  (*(volatile unsigned *)0x4900000C)
+#define rHcInterruptEnable  (*(volatile unsigned *)0x49000010)
+#define rHcInterruptDisable (*(volatile unsigned *)0x49000014)
+#define rHcHCCA         (*(volatile unsigned *)0x49000018)
+#define rHcPeriodCuttendED  (*(volatile unsigned *)0x4900001C)
+#define rHcControlHeadED    (*(volatile unsigned *)0x49000020)
+#define rHcControlCurrentED (*(volatile unsigned *)0x49000024)
+#define rHcBulkHeadED       (*(volatile unsigned *)0x49000028)
+#define rHcBuldCurrentED    (*(volatile unsigned *)0x4900002C)
+#define rHcDoneHead     (*(volatile unsigned *)0x49000030)
+#define rHcRmInterval       (*(volatile unsigned *)0x49000034)
+#define rHcFmRemaining      (*(volatile unsigned *)0x49000038)
+#define rHcFmNumber     (*(volatile unsigned *)0x4900003C)
+#define rHcPeriodicStart    (*(volatile unsigned *)0x49000040)
+#define rHcLSThreshold      (*(volatile unsigned *)0x49000044)
+#define rHcRhDescriptorA    (*(volatile unsigned *)0x49000048)
+#define rHcRhDescriptorB    (*(volatile unsigned *)0x4900004C)
+#define rHcRhStatus     (*(volatile unsigned *)0x49000050)
+#define rHcRhPortStatus1    (*(volatile unsigned *)0x49000054)
+#define rHcRhPortStatus2    (*(volatile unsigned *)0x49000058)
 
 
 /* INTERRUPT */
-#define rSRCPND			(*(volatile unsigned *)0x4A000000)
-#define rINTMOD			(*(volatile unsigned *)0x4A000004)
-#define rINTMSK			(*(volatile unsigned *)0x4A000008)
-#define rPRIORITY		(*(volatile unsigned *)0x4A00000C)
-#define rINTPND			(*(volatile unsigned *)0x4A000010)
-#define rINTOFFSET		(*(volatile unsigned *)0x4A000014)
-#define rSUBSRCPND		(*(volatile unsigned *)0x4A000018)
-#define rINTSUBMSK		(*(volatile unsigned *)0x4A00001C)
+#define rSRCPND         (*(volatile unsigned *)0x4A000000)
+#define rINTMOD         (*(volatile unsigned *)0x4A000004)
+#define rINTMSK         (*(volatile unsigned *)0x4A000008)
+#define rPRIORITY       (*(volatile unsigned *)0x4A00000C)
+#define rINTPND         (*(volatile unsigned *)0x4A000010)
+#define rINTOFFSET      (*(volatile unsigned *)0x4A000014)
+#define rSUBSRCPND      (*(volatile unsigned *)0x4A000018)
+#define rINTSUBMSK      (*(volatile unsigned *)0x4A00001C)
 
 
 /* DMA */
-#define rDISRC0			(*(volatile unsigned *)0x4B000000)
-#define rDISRCC0		(*(volatile unsigned *)0x4B000004)
-#define rDIDST0			(*(volatile unsigned *)0x4B000008)
-#define rDIDSTC0		(*(volatile unsigned *)0x4B00000C)
-#define rDCON0			(*(volatile unsigned *)0x4B000010)
-#define rDSTAT0			(*(volatile unsigned *)0x4B000014)
-#define rDCSRC0			(*(volatile unsigned *)0x4B000018)
-#define rDCDST0			(*(volatile unsigned *)0x4B00001C)
-#define rDMASKTRIG0		(*(volatile unsigned *)0x4B000020)
-#define rDISRC1			(*(volatile unsigned *)0x4B000040)
-#define rDISRCC1		(*(volatile unsigned *)0x4B000044)
-#define rDIDST1			(*(volatile unsigned *)0x4B000048)
-#define rDIDSTC1		(*(volatile unsigned *)0x4B00004C)
-#define rDCON1			(*(volatile unsigned *)0x4B000050)
-#define rDSTAT1			(*(volatile unsigned *)0x4B000054)
-#define rDCSRC1			(*(volatile unsigned *)0x4B000058)
-#define rDCDST1			(*(volatile unsigned *)0x4B00005C)
-#define rDMASKTRIG1		(*(volatile unsigned *)0x4B000060)
-#define rDISRC2			(*(volatile unsigned *)0x4B000080)
-#define rDISRCC2		(*(volatile unsigned *)0x4B000084)
-#define rDIDST2			(*(volatile unsigned *)0x4B000088)
-#define rDIDSTC2		(*(volatile unsigned *)0x4B00008C)
-#define rDCON2			(*(volatile unsigned *)0x4B000090)
-#define rDSTAT2			(*(volatile unsigned *)0x4B000094)
-#define rDCSRC2			(*(volatile unsigned *)0x4B000098)
-#define rDCDST2			(*(volatile unsigned *)0x4B00009C)
-#define rDMASKTRIG2		(*(volatile unsigned *)0x4B0000A0)
-#define rDISRC3			(*(volatile unsigned *)0x4B0000C0)
-#define rDISRCC3		(*(volatile unsigned *)0x4B0000C4)
-#define rDIDST3			(*(volatile unsigned *)0x4B0000C8)
-#define rDIDSTC3		(*(volatile unsigned *)0x4B0000CC)
-#define rDCON3			(*(volatile unsigned *)0x4B0000D0)
-#define rDSTAT3			(*(volatile unsigned *)0x4B0000D4)
-#define rDCSRC3			(*(volatile unsigned *)0x4B0000D8)
-#define rDCDST3			(*(volatile unsigned *)0x4B0000DC)
-#define rDMASKTRIG3		(*(volatile unsigned *)0x4B0000E0)
+#define rDISRC0         (*(volatile unsigned *)0x4B000000)
+#define rDISRCC0        (*(volatile unsigned *)0x4B000004)
+#define rDIDST0         (*(volatile unsigned *)0x4B000008)
+#define rDIDSTC0        (*(volatile unsigned *)0x4B00000C)
+#define rDCON0          (*(volatile unsigned *)0x4B000010)
+#define rDSTAT0         (*(volatile unsigned *)0x4B000014)
+#define rDCSRC0         (*(volatile unsigned *)0x4B000018)
+#define rDCDST0         (*(volatile unsigned *)0x4B00001C)
+#define rDMASKTRIG0     (*(volatile unsigned *)0x4B000020)
+#define rDISRC1         (*(volatile unsigned *)0x4B000040)
+#define rDISRCC1        (*(volatile unsigned *)0x4B000044)
+#define rDIDST1         (*(volatile unsigned *)0x4B000048)
+#define rDIDSTC1        (*(volatile unsigned *)0x4B00004C)
+#define rDCON1          (*(volatile unsigned *)0x4B000050)
+#define rDSTAT1         (*(volatile unsigned *)0x4B000054)
+#define rDCSRC1         (*(volatile unsigned *)0x4B000058)
+#define rDCDST1         (*(volatile unsigned *)0x4B00005C)
+#define rDMASKTRIG1     (*(volatile unsigned *)0x4B000060)
+#define rDISRC2         (*(volatile unsigned *)0x4B000080)
+#define rDISRCC2        (*(volatile unsigned *)0x4B000084)
+#define rDIDST2         (*(volatile unsigned *)0x4B000088)
+#define rDIDSTC2        (*(volatile unsigned *)0x4B00008C)
+#define rDCON2          (*(volatile unsigned *)0x4B000090)
+#define rDSTAT2         (*(volatile unsigned *)0x4B000094)
+#define rDCSRC2         (*(volatile unsigned *)0x4B000098)
+#define rDCDST2         (*(volatile unsigned *)0x4B00009C)
+#define rDMASKTRIG2     (*(volatile unsigned *)0x4B0000A0)
+#define rDISRC3         (*(volatile unsigned *)0x4B0000C0)
+#define rDISRCC3        (*(volatile unsigned *)0x4B0000C4)
+#define rDIDST3         (*(volatile unsigned *)0x4B0000C8)
+#define rDIDSTC3        (*(volatile unsigned *)0x4B0000CC)
+#define rDCON3          (*(volatile unsigned *)0x4B0000D0)
+#define rDSTAT3         (*(volatile unsigned *)0x4B0000D4)
+#define rDCSRC3         (*(volatile unsigned *)0x4B0000D8)
+#define rDCDST3         (*(volatile unsigned *)0x4B0000DC)
+#define rDMASKTRIG3     (*(volatile unsigned *)0x4B0000E0)
 
 
 /* CLOCK & POWER MANAGEMENT */
-#define rLOCKTIME		(*(volatile unsigned *)0x4C000000)
-#define rMPLLCON		(*(volatile unsigned *)0x4C000004)
-#define rUPLLCON		(*(volatile unsigned *)0x4C000008)
-#define rCLKCON			(*(volatile unsigned *)0x4C00000C)
-#define rCLKSLOW		(*(volatile unsigned *)0x4C000010)
-#define rCLKDIVN		(*(volatile unsigned *)0x4C000014)
+#define rLOCKTIME       (*(volatile unsigned *)0x4C000000)
+#define rMPLLCON        (*(volatile unsigned *)0x4C000004)
+#define rUPLLCON        (*(volatile unsigned *)0x4C000008)
+#define rCLKCON         (*(volatile unsigned *)0x4C00000C)
+#define rCLKSLOW        (*(volatile unsigned *)0x4C000010)
+#define rCLKDIVN        (*(volatile unsigned *)0x4C000014)
 
 
 /* LCD CONTROLLER */
-#define rLCDCON1		(*(volatile unsigned *)0x4D000000)
-#define rLCDCON2		(*(volatile unsigned *)0x4D000004)
-#define rLCDCON3		(*(volatile unsigned *)0x4D000008)
-#define rLCDCON4		(*(volatile unsigned *)0x4D00000C)
-#define rLCDCON5		(*(volatile unsigned *)0x4D000010)
-#define rLCDSADDR1		(*(volatile unsigned *)0x4D000014)
-#define rLCDSADDR2		(*(volatile unsigned *)0x4D000018)
-#define rLCDSADDR3		(*(volatile unsigned *)0x4D00001C)
-#define rREDLUT			(*(volatile unsigned *)0x4D000020)
-#define rGREENLUT		(*(volatile unsigned *)0x4D000024)
-#define rBLUELUT		(*(volatile unsigned *)0x4D000028)
-#define rDITHMODE		(*(volatile unsigned *)0x4D00004C)
-#define rTPAL			(*(volatile unsigned *)0x4D000050)
-#define rLCDINTPND		(*(volatile unsigned *)0x4D000054)
-#define rLCDSRCPND		(*(volatile unsigned *)0x4D000058)
-#define rLCDINTMSK		(*(volatile unsigned *)0x4D00005C)
+#define rLCDCON1        (*(volatile unsigned *)0x4D000000)
+#define rLCDCON2        (*(volatile unsigned *)0x4D000004)
+#define rLCDCON3        (*(volatile unsigned *)0x4D000008)
+#define rLCDCON4        (*(volatile unsigned *)0x4D00000C)
+#define rLCDCON5        (*(volatile unsigned *)0x4D000010)
+#define rLCDSADDR1      (*(volatile unsigned *)0x4D000014)
+#define rLCDSADDR2      (*(volatile unsigned *)0x4D000018)
+#define rLCDSADDR3      (*(volatile unsigned *)0x4D00001C)
+#define rREDLUT         (*(volatile unsigned *)0x4D000020)
+#define rGREENLUT       (*(volatile unsigned *)0x4D000024)
+#define rBLUELUT        (*(volatile unsigned *)0x4D000028)
+#define rDITHMODE       (*(volatile unsigned *)0x4D00004C)
+#define rTPAL           (*(volatile unsigned *)0x4D000050)
+#define rLCDINTPND      (*(volatile unsigned *)0x4D000054)
+#define rLCDSRCPND      (*(volatile unsigned *)0x4D000058)
+#define rLCDINTMSK      (*(volatile unsigned *)0x4D00005C)
 
 
 /* NAND FLASH */
-#define rNFCONF			(*(volatile unsigned *)0x4E000000)
-#define rNFCMD			(*(volatile unsigned *)0x4E000004)
-#define rNFADDR			(*(volatile unsigned *)0x4E000008)
-#define rNFDATA			(*(volatile unsigned *)0x4E00000C)
-#define rNFSTAT			(*(volatile unsigned *)0x4E000010)
-#define rNFECC			(*(volatile unsigned *)0x4E000014)
+#define rNFCONF         (*(volatile unsigned *)0x4E000000)
+#define rNFCMD          (*(volatile unsigned *)0x4E000004)
+#define rNFADDR         (*(volatile unsigned *)0x4E000008)
+#define rNFDATA         (*(volatile unsigned *)0x4E00000C)
+#define rNFSTAT         (*(volatile unsigned *)0x4E000010)
+#define rNFECC          (*(volatile unsigned *)0x4E000014)
 
 
 /* UART */
-#define rULCON0			(*(volatile unsigned *)0x50000000)
-#define rUCON0			(*(volatile unsigned *)0x50000004)
-#define rUFCON0			(*(volatile unsigned *)0x50000008)
-#define rUMCON0			(*(volatile unsigned *)0x5000000C)
-#define rUTRSTAT0		(*(volatile unsigned *)0x50000010)
-#define rUERSTAT0		(*(volatile unsigned *)0x50000014)
-#define rUFSTAT0		(*(volatile unsigned *)0x50000018)
-#define rUMSTAT0		(*(volatile unsigned *)0x5000001C)
-#define rUBRDIV0		(*(volatile unsigned *)0x50000028)
-
-#define rULCON1			(*(volatile unsigned *)0x50004000)
-#define rUCON1			(*(volatile unsigned *)0x50004004)
-#define rUFCON1			(*(volatile unsigned *)0x50004008)
-#define rUMCON1			(*(volatile unsigned *)0x5000400C)
-#define rUTRSTAT1		(*(volatile unsigned *)0x50004010)
-#define rUERSTAT1		(*(volatile unsigned *)0x50004014)
-#define rUFSTAT1		(*(volatile unsigned *)0x50004018)
-#define rUMSTAT1		(*(volatile unsigned *)0x5000401C)
-#define rUBRDIV1		(*(volatile unsigned *)0x50004028)
-
-#define rULCON2			(*(volatile unsigned *)0x50008000)
-#define rUCON2			(*(volatile unsigned *)0x50008004)
-#define rUFCON2			(*(volatile unsigned *)0x50008008)
-#define rUTRSTAT2		(*(volatile unsigned *)0x50008010)
-#define rUERSTAT2		(*(volatile unsigned *)0x50008014)
-#define rUFSTAT2		(*(volatile unsigned *)0x50008018)
-#define rUBRDIV2		(*(volatile unsigned *)0x50008028)
+#define rULCON0         (*(volatile unsigned *)0x50000000)
+#define rUCON0          (*(volatile unsigned *)0x50000004)
+#define rUFCON0         (*(volatile unsigned *)0x50000008)
+#define rUMCON0         (*(volatile unsigned *)0x5000000C)
+#define rUTRSTAT0       (*(volatile unsigned *)0x50000010)
+#define rUERSTAT0       (*(volatile unsigned *)0x50000014)
+#define rUFSTAT0        (*(volatile unsigned *)0x50000018)
+#define rUMSTAT0        (*(volatile unsigned *)0x5000001C)
+#define rUBRDIV0        (*(volatile unsigned *)0x50000028)
+
+#define rULCON1         (*(volatile unsigned *)0x50004000)
+#define rUCON1          (*(volatile unsigned *)0x50004004)
+#define rUFCON1         (*(volatile unsigned *)0x50004008)
+#define rUMCON1         (*(volatile unsigned *)0x5000400C)
+#define rUTRSTAT1       (*(volatile unsigned *)0x50004010)
+#define rUERSTAT1       (*(volatile unsigned *)0x50004014)
+#define rUFSTAT1        (*(volatile unsigned *)0x50004018)
+#define rUMSTAT1        (*(volatile unsigned *)0x5000401C)
+#define rUBRDIV1        (*(volatile unsigned *)0x50004028)
+
+#define rULCON2         (*(volatile unsigned *)0x50008000)
+#define rUCON2          (*(volatile unsigned *)0x50008004)
+#define rUFCON2         (*(volatile unsigned *)0x50008008)
+#define rUTRSTAT2       (*(volatile unsigned *)0x50008010)
+#define rUERSTAT2       (*(volatile unsigned *)0x50008014)
+#define rUFSTAT2        (*(volatile unsigned *)0x50008018)
+#define rUBRDIV2        (*(volatile unsigned *)0x50008028)
 
 #ifdef __BIG_ENDIAN
-#define rUTXH0			(*(volatile unsigned char *)0x50000023)
-#define rURXH0			(*(volatile unsigned char *)0x50000027)
-#define rUTXH1			(*(volatile unsigned char *)0x50004023)
-#define rURXH1			(*(volatile unsigned char *)0x50004027)
-#define rUTXH2			(*(volatile unsigned char *)0x50008023)
-#define rURXH2			(*(volatile unsigned char *)0x50008027)
-
-#define WrUTXH0(ch)		(*(volatile unsigned char *)0x50000023)=(unsigned char)(ch)
-#define RdURXH0()		(*(volatile unsigned char *)0x50000027)
-#define WrUTXH1(ch)		(*(volatile unsigned char *)0x50004023)=(unsigned char)(ch)
-#define RdURXH1()		(*(volatile unsigned char *)0x50004027)
-#define WrUTXH2(ch)		(*(volatile unsigned char *)0x50008023)=(unsigned char)(ch)
-#define RdURXH2()		(*(volatile unsigned char *)0x50008027)
-
-#define UTXH0			(0x50000020+3)  /* byte_access address by DMA */
-#define URXH0			(0x50000024+3)
-#define UTXH1			(0x50004020+3)
-#define URXH1			(0x50004024+3)
-#define UTXH2			(0x50008020+3)
-#define URXH2			(0x50008024+3)
+#define rUTXH0          (*(volatile unsigned char *)0x50000023)
+#define rURXH0          (*(volatile unsigned char *)0x50000027)
+#define rUTXH1          (*(volatile unsigned char *)0x50004023)
+#define rURXH1          (*(volatile unsigned char *)0x50004027)
+#define rUTXH2          (*(volatile unsigned char *)0x50008023)
+#define rURXH2          (*(volatile unsigned char *)0x50008027)
+
+#define WrUTXH0(ch)     (*(volatile unsigned char *)0x50000023)=(unsigned char)(ch)
+#define RdURXH0()       (*(volatile unsigned char *)0x50000027)
+#define WrUTXH1(ch)     (*(volatile unsigned char *)0x50004023)=(unsigned char)(ch)
+#define RdURXH1()       (*(volatile unsigned char *)0x50004027)
+#define WrUTXH2(ch)     (*(volatile unsigned char *)0x50008023)=(unsigned char)(ch)
+#define RdURXH2()       (*(volatile unsigned char *)0x50008027)
+
+#define UTXH0           (0x50000020+3)  /* byte_access address by DMA */
+#define URXH0           (0x50000024+3)
+#define UTXH1           (0x50004020+3)
+#define URXH1           (0x50004024+3)
+#define UTXH2           (0x50008020+3)
+#define URXH2           (0x50008024+3)
 
 #else /* Little Endian */
-#define rUTXH0			(*(volatile unsigned char *)0x50000020)
-#define rURXH0			(*(volatile unsigned char *)0x50000024)
-#define rUTXH1			(*(volatile unsigned char *)0x50004020)
-#define rURXH1			(*(volatile unsigned char *)0x50004024)
-#define rUTXH2			(*(volatile unsigned char *)0x50008020)
-#define rURXH2			(*(volatile unsigned char *)0x50008024)
-
-#define WrUTXH0(ch)		(*(volatile unsigned char *)0x50000020)=(unsigned char)(ch)
-#define RdURXH0()		(*(volatile unsigned char *)0x50000024)
-#define WrUTXH1(ch)		(*(volatile unsigned char *)0x50004020)=(unsigned char)(ch)
-#define RdURXH1()		(*(volatile unsigned char *)0x50004024)
-#define WrUTXH2(ch)		(*(volatile unsigned char *)0x50008020)=(unsigned char)(ch)
-#define RdURXH2()		(*(volatile unsigned char *)0x50008024)
-
-#define UTXH0			(0x50000020)    /* byte_access address by DMA */
-#define URXH0			(0x50000024)
-#define UTXH1			(0x50004020)
-#define URXH1			(0x50004024)
-#define UTXH2			(0x50008020)
-#define URXH2			(0x50008024)
+#define rUTXH0          (*(volatile unsigned char *)0x50000020)
+#define rURXH0          (*(volatile unsigned char *)0x50000024)
+#define rUTXH1          (*(volatile unsigned char *)0x50004020)
+#define rURXH1          (*(volatile unsigned char *)0x50004024)
+#define rUTXH2          (*(volatile unsigned char *)0x50008020)
+#define rURXH2          (*(volatile unsigned char *)0x50008024)
+
+#define WrUTXH0(ch)     (*(volatile unsigned char *)0x50000020)=(unsigned char)(ch)
+#define RdURXH0()       (*(volatile unsigned char *)0x50000024)
+#define WrUTXH1(ch)     (*(volatile unsigned char *)0x50004020)=(unsigned char)(ch)
+#define RdURXH1()       (*(volatile unsigned char *)0x50004024)
+#define WrUTXH2(ch)     (*(volatile unsigned char *)0x50008020)=(unsigned char)(ch)
+#define RdURXH2()       (*(volatile unsigned char *)0x50008024)
+
+#define UTXH0           (0x50000020)    /* byte_access address by DMA */
+#define URXH0           (0x50000024)
+#define UTXH1           (0x50004020)
+#define URXH1           (0x50004024)
+#define UTXH2           (0x50008020)
+#define URXH2           (0x50008024)
 #endif
 
 
 /* PWM TIMER */
-#define rTCFG0			(*(volatile unsigned *)0x51000000)
-#define rTCFG1			(*(volatile unsigned *)0x51000004)
-#define rTCON			(*(volatile unsigned *)0x51000008)
-#define rTCNTB0			(*(volatile unsigned *)0x5100000C)
-#define rTCMPB0			(*(volatile unsigned *)0x51000010)
-#define rTCNTO0			(*(volatile unsigned *)0x51000014)
-#define rTCNTB1			(*(volatile unsigned *)0x51000018)
-#define rTCMPB1			(*(volatile unsigned *)0x5100001C)
-#define rTCNTO1			(*(volatile unsigned *)0x51000020)
-#define rTCNTB2			(*(volatile unsigned *)0x51000024)
-#define rTCMPB2			(*(volatile unsigned *)0x51000028)
-#define rTCNTO2			(*(volatile unsigned *)0x5100002C)
-#define rTCNTB3			(*(volatile unsigned *)0x51000030)
-#define rTCMPB3			(*(volatile unsigned *)0x51000034)
-#define rTCNTO3			(*(volatile unsigned *)0x51000038)
-#define rTCNTB4			(*(volatile unsigned *)0x5100003C)
-#define rTCNTO4			(*(volatile unsigned *)0x51000040)
+#define rTCFG0          (*(volatile unsigned *)0x51000000)
+#define rTCFG1          (*(volatile unsigned *)0x51000004)
+#define rTCON           (*(volatile unsigned *)0x51000008)
+#define rTCNTB0         (*(volatile unsigned *)0x5100000C)
+#define rTCMPB0         (*(volatile unsigned *)0x51000010)
+#define rTCNTO0         (*(volatile unsigned *)0x51000014)
+#define rTCNTB1         (*(volatile unsigned *)0x51000018)
+#define rTCMPB1         (*(volatile unsigned *)0x5100001C)
+#define rTCNTO1         (*(volatile unsigned *)0x51000020)
+#define rTCNTB2         (*(volatile unsigned *)0x51000024)
+#define rTCMPB2         (*(volatile unsigned *)0x51000028)
+#define rTCNTO2         (*(volatile unsigned *)0x5100002C)
+#define rTCNTB3         (*(volatile unsigned *)0x51000030)
+#define rTCMPB3         (*(volatile unsigned *)0x51000034)
+#define rTCNTO3         (*(volatile unsigned *)0x51000038)
+#define rTCNTB4         (*(volatile unsigned *)0x5100003C)
+#define rTCNTO4         (*(volatile unsigned *)0x51000040)
 
 
 /* USB DEVICE */
 #ifdef __BIG_ENDIAN
-#define rFUNC_ADDR_REG		(*(volatile unsigned char *)0x52000143)
-#define rPWR_REG		(*(volatile unsigned char *)0x52000147)
-#define rEP_INT_REG		(*(volatile unsigned char *)0x5200014B)
-#define rUSB_INT_REG		(*(volatile unsigned char *)0x5200015B)
-#define rEP_INT_EN_REG		(*(volatile unsigned char *)0x5200015F)
-#define rUSB_INT_EN_REG		(*(volatile unsigned char *)0x5200016F)
-#define rFRAME_NUM1_REG		(*(volatile unsigned char *)0x52000173)
-#define rFRAME_NUM2_REG		(*(volatile unsigned char *)0x52000177)
-#define rINDEX_REG		(*(volatile unsigned char *)0x5200017B)
-#define rMAXP_REG		(*(volatile unsigned char *)0x52000183)
-#define rEP0_CSR		(*(volatile unsigned char *)0x52000187)
-#define rIN_CSR1_REG		(*(volatile unsigned char *)0x52000187)
-#define rIN_CSR2_REG		(*(volatile unsigned char *)0x5200018B)
-#define rOUT_CSR1_REG		(*(volatile unsigned char *)0x52000193)
-#define rOUT_CSR2_REG		(*(volatile unsigned char *)0x52000197)
-#define rOUT_FIFO_CNT1_REG	(*(volatile unsigned char *)0x5200019B)
-#define rOUT_FIFO_CNT2_REG	(*(volatile unsigned char *)0x5200019F)
-#define rEP0_FIFO		(*(volatile unsigned char *)0x520001C3)
-#define rEP1_FIFO		(*(volatile unsigned char *)0x520001C7)
-#define rEP2_FIFO		(*(volatile unsigned char *)0x520001CB)
-#define rEP3_FIFO		(*(volatile unsigned char *)0x520001CF)
-#define rEP4_FIFO		(*(volatile unsigned char *)0x520001D3)
-#define rEP1_DMA_CON		(*(volatile unsigned char *)0x52000203)
-#define rEP1_DMA_UNIT		(*(volatile unsigned char *)0x52000207)
-#define rEP1_DMA_FIFO		(*(volatile unsigned char *)0x5200020B)
-#define rEP1_DMA_TX_LO		(*(volatile unsigned char *)0x5200020F)
-#define rEP1_DMA_TX_MD		(*(volatile unsigned char *)0x52000213)
-#define rEP1_DMA_TX_HI		(*(volatile unsigned char *)0x52000217)
-#define rEP2_DMA_CON		(*(volatile unsigned char *)0x5200021B)
-#define rEP2_DMA_UNIT		(*(volatile unsigned char *)0x5200021F)
-#define rEP2_DMA_FIFO		(*(volatile unsigned char *)0x52000223)
-#define rEP2_DMA_TX_LO		(*(volatile unsigned char *)0x52000227)
-#define rEP2_DMA_TX_MD		(*(volatile unsigned char *)0x5200022B)
-#define rEP2_DMA_TX_HI		(*(volatile unsigned char *)0x5200022F)
-#define rEP3_DMA_CON		(*(volatile unsigned char *)0x52000243)
-#define rEP3_DMA_UNIT		(*(volatile unsigned char *)0x52000247)
-#define rEP3_DMA_FIFO		(*(volatile unsigned char *)0x5200024B)
-#define rEP3_DMA_TX_LO		(*(volatile unsigned char *)0x5200024F)
-#define rEP3_DMA_TX_MD		(*(volatile unsigned char *)0x52000253)
-#define rEP3_DMA_TX_HI		(*(volatile unsigned char *)0x52000257)
-#define rEP4_DMA_CON		(*(volatile unsigned char *)0x5200025B)
-#define rEP4_DMA_UNIT		(*(volatile unsigned char *)0x5200025F)
-#define rEP4_DMA_FIFO		(*(volatile unsigned char *)0x52000263)
-#define rEP4_DMA_TX_LO		(*(volatile unsigned char *)0x52000267)
-#define rEP4_DMA_TX_MD		(*(volatile unsigned char *)0x5200026B)
-#define rEP4_DMA_TX_HI		(*(volatile unsigned char *)0x5200026F)
+#define rFUNC_ADDR_REG      (*(volatile unsigned char *)0x52000143)
+#define rPWR_REG        (*(volatile unsigned char *)0x52000147)
+#define rEP_INT_REG     (*(volatile unsigned char *)0x5200014B)
+#define rUSB_INT_REG        (*(volatile unsigned char *)0x5200015B)
+#define rEP_INT_EN_REG      (*(volatile unsigned char *)0x5200015F)
+#define rUSB_INT_EN_REG     (*(volatile unsigned char *)0x5200016F)
+#define rFRAME_NUM1_REG     (*(volatile unsigned char *)0x52000173)
+#define rFRAME_NUM2_REG     (*(volatile unsigned char *)0x52000177)
+#define rINDEX_REG      (*(volatile unsigned char *)0x5200017B)
+#define rMAXP_REG       (*(volatile unsigned char *)0x52000183)
+#define rEP0_CSR        (*(volatile unsigned char *)0x52000187)
+#define rIN_CSR1_REG        (*(volatile unsigned char *)0x52000187)
+#define rIN_CSR2_REG        (*(volatile unsigned char *)0x5200018B)
+#define rOUT_CSR1_REG       (*(volatile unsigned char *)0x52000193)
+#define rOUT_CSR2_REG       (*(volatile unsigned char *)0x52000197)
+#define rOUT_FIFO_CNT1_REG  (*(volatile unsigned char *)0x5200019B)
+#define rOUT_FIFO_CNT2_REG  (*(volatile unsigned char *)0x5200019F)
+#define rEP0_FIFO       (*(volatile unsigned char *)0x520001C3)
+#define rEP1_FIFO       (*(volatile unsigned char *)0x520001C7)
+#define rEP2_FIFO       (*(volatile unsigned char *)0x520001CB)
+#define rEP3_FIFO       (*(volatile unsigned char *)0x520001CF)
+#define rEP4_FIFO       (*(volatile unsigned char *)0x520001D3)
+#define rEP1_DMA_CON        (*(volatile unsigned char *)0x52000203)
+#define rEP1_DMA_UNIT       (*(volatile unsigned char *)0x52000207)
+#define rEP1_DMA_FIFO       (*(volatile unsigned char *)0x5200020B)
+#define rEP1_DMA_TX_LO      (*(volatile unsigned char *)0x5200020F)
+#define rEP1_DMA_TX_MD      (*(volatile unsigned char *)0x52000213)
+#define rEP1_DMA_TX_HI      (*(volatile unsigned char *)0x52000217)
+#define rEP2_DMA_CON        (*(volatile unsigned char *)0x5200021B)
+#define rEP2_DMA_UNIT       (*(volatile unsigned char *)0x5200021F)
+#define rEP2_DMA_FIFO       (*(volatile unsigned char *)0x52000223)
+#define rEP2_DMA_TX_LO      (*(volatile unsigned char *)0x52000227)
+#define rEP2_DMA_TX_MD      (*(volatile unsigned char *)0x5200022B)
+#define rEP2_DMA_TX_HI      (*(volatile unsigned char *)0x5200022F)
+#define rEP3_DMA_CON        (*(volatile unsigned char *)0x52000243)
+#define rEP3_DMA_UNIT       (*(volatile unsigned char *)0x52000247)
+#define rEP3_DMA_FIFO       (*(volatile unsigned char *)0x5200024B)
+#define rEP3_DMA_TX_LO      (*(volatile unsigned char *)0x5200024F)
+#define rEP3_DMA_TX_MD      (*(volatile unsigned char *)0x52000253)
+#define rEP3_DMA_TX_HI      (*(volatile unsigned char *)0x52000257)
+#define rEP4_DMA_CON        (*(volatile unsigned char *)0x5200025B)
+#define rEP4_DMA_UNIT       (*(volatile unsigned char *)0x5200025F)
+#define rEP4_DMA_FIFO       (*(volatile unsigned char *)0x52000263)
+#define rEP4_DMA_TX_LO      (*(volatile unsigned char *)0x52000267)
+#define rEP4_DMA_TX_MD      (*(volatile unsigned char *)0x5200026B)
+#define rEP4_DMA_TX_HI      (*(volatile unsigned char *)0x5200026F)
 #else /*  little endian */
-#define rFUNC_ADDR_REG		(*(volatile unsigned char *)0x52000140)
-#define rPWR_REG		(*(volatile unsigned char *)0x52000144)
-#define rEP_INT_REG		(*(volatile unsigned char *)0x52000148)
-#define rUSB_INT_REG		(*(volatile unsigned char *)0x52000158)
-#define rEP_INT_EN_REG		(*(volatile unsigned char *)0x5200015C)
-#define rUSB_INT_EN_REG		(*(volatile unsigned char *)0x5200016C)
-#define rFRAME_NUM1_REG		(*(volatile unsigned char *)0x52000170)
-#define rFRAME_NUM2_REG		(*(volatile unsigned char *)0x52000174)
-#define rINDEX_REG		(*(volatile unsigned char *)0x52000178)
-#define rMAXP_REG		(*(volatile unsigned char *)0x52000180)
-#define rEP0_CSR		(*(volatile unsigned char *)0x52000184)
-#define rIN_CSR1_REG		(*(volatile unsigned char *)0x52000184)
-#define rIN_CSR2_REG		(*(volatile unsigned char *)0x52000188)
-#define rOUT_CSR1_REG		(*(volatile unsigned char *)0x52000190)
-#define rOUT_CSR2_REG		(*(volatile unsigned char *)0x52000194)
-#define rOUT_FIFO_CNT1_REG	(*(volatile unsigned char *)0x52000198)
-#define rOUT_FIFO_CNT2_REG	(*(volatile unsigned char *)0x5200019C)
-#define rEP0_FIFO		(*(volatile unsigned char *)0x520001C0)
-#define rEP1_FIFO		(*(volatile unsigned char *)0x520001C4)
-#define rEP2_FIFO		(*(volatile unsigned char *)0x520001C8)
-#define rEP3_FIFO		(*(volatile unsigned char *)0x520001CC)
-#define rEP4_FIFO		(*(volatile unsigned char *)0x520001D0)
-#define rEP1_DMA_CON		(*(volatile unsigned char *)0x52000200)
-#define rEP1_DMA_UNIT		(*(volatile unsigned char *)0x52000204)
-#define rEP1_DMA_FIFO		(*(volatile unsigned char *)0x52000208)
-#define rEP1_DMA_TX_LO		(*(volatile unsigned char *)0x5200020C)
-#define rEP1_DMA_TX_MD		(*(volatile unsigned char *)0x52000210)
-#define rEP1_DMA_TX_HI		(*(volatile unsigned char *)0x52000214)
-#define rEP2_DMA_CON		(*(volatile unsigned char *)0x52000218)
-#define rEP2_DMA_UNIT		(*(volatile unsigned char *)0x5200021C)
-#define rEP2_DMA_FIFO		(*(volatile unsigned char *)0x52000220)
-#define rEP2_DMA_TX_LO		(*(volatile unsigned char *)0x52000224)
-#define rEP2_DMA_TX_MD		(*(volatile unsigned char *)0x52000228)
-#define rEP2_DMA_TX_HI		(*(volatile unsigned char *)0x5200022C)
-#define rEP3_DMA_CON		(*(volatile unsigned char *)0x52000240)
-#define rEP3_DMA_UNIT		(*(volatile unsigned char *)0x52000244)
-#define rEP3_DMA_FIFO		(*(volatile unsigned char *)0x52000248)
-#define rEP3_DMA_TX_LO		(*(volatile unsigned char *)0x5200024C)
-#define rEP3_DMA_TX_MD		(*(volatile unsigned char *)0x52000250)
-#define rEP3_DMA_TX_HI		(*(volatile unsigned char *)0x52000254)
-#define rEP4_DMA_CON		(*(volatile unsigned char *)0x52000258)
-#define rEP4_DMA_UNIT		(*(volatile unsigned char *)0x5200025C)
-#define rEP4_DMA_FIFO		(*(volatile unsigned char *)0x52000260)
-#define rEP4_DMA_TX_LO		(*(volatile unsigned char *)0x52000264)
-#define rEP4_DMA_TX_MD		(*(volatile unsigned char *)0x52000268)
-#define rEP4_DMA_TX_HI		(*(volatile unsigned char *)0x5200026C)
+#define rFUNC_ADDR_REG      (*(volatile unsigned char *)0x52000140)
+#define rPWR_REG        (*(volatile unsigned char *)0x52000144)
+#define rEP_INT_REG     (*(volatile unsigned char *)0x52000148)
+#define rUSB_INT_REG        (*(volatile unsigned char *)0x52000158)
+#define rEP_INT_EN_REG      (*(volatile unsigned char *)0x5200015C)
+#define rUSB_INT_EN_REG     (*(volatile unsigned char *)0x5200016C)
+#define rFRAME_NUM1_REG     (*(volatile unsigned char *)0x52000170)
+#define rFRAME_NUM2_REG     (*(volatile unsigned char *)0x52000174)
+#define rINDEX_REG      (*(volatile unsigned char *)0x52000178)
+#define rMAXP_REG       (*(volatile unsigned char *)0x52000180)
+#define rEP0_CSR        (*(volatile unsigned char *)0x52000184)
+#define rIN_CSR1_REG        (*(volatile unsigned char *)0x52000184)
+#define rIN_CSR2_REG        (*(volatile unsigned char *)0x52000188)
+#define rOUT_CSR1_REG       (*(volatile unsigned char *)0x52000190)
+#define rOUT_CSR2_REG       (*(volatile unsigned char *)0x52000194)
+#define rOUT_FIFO_CNT1_REG  (*(volatile unsigned char *)0x52000198)
+#define rOUT_FIFO_CNT2_REG  (*(volatile unsigned char *)0x5200019C)
+#define rEP0_FIFO       (*(volatile unsigned char *)0x520001C0)
+#define rEP1_FIFO       (*(volatile unsigned char *)0x520001C4)
+#define rEP2_FIFO       (*(volatile unsigned char *)0x520001C8)
+#define rEP3_FIFO       (*(volatile unsigned char *)0x520001CC)
+#define rEP4_FIFO       (*(volatile unsigned char *)0x520001D0)
+#define rEP1_DMA_CON        (*(volatile unsigned char *)0x52000200)
+#define rEP1_DMA_UNIT       (*(volatile unsigned char *)0x52000204)
+#define rEP1_DMA_FIFO       (*(volatile unsigned char *)0x52000208)
+#define rEP1_DMA_TX_LO      (*(volatile unsigned char *)0x5200020C)
+#define rEP1_DMA_TX_MD      (*(volatile unsigned char *)0x52000210)
+#define rEP1_DMA_TX_HI      (*(volatile unsigned char *)0x52000214)
+#define rEP2_DMA_CON        (*(volatile unsigned char *)0x52000218)
+#define rEP2_DMA_UNIT       (*(volatile unsigned char *)0x5200021C)
+#define rEP2_DMA_FIFO       (*(volatile unsigned char *)0x52000220)
+#define rEP2_DMA_TX_LO      (*(volatile unsigned char *)0x52000224)
+#define rEP2_DMA_TX_MD      (*(volatile unsigned char *)0x52000228)
+#define rEP2_DMA_TX_HI      (*(volatile unsigned char *)0x5200022C)
+#define rEP3_DMA_CON        (*(volatile unsigned char *)0x52000240)
+#define rEP3_DMA_UNIT       (*(volatile unsigned char *)0x52000244)
+#define rEP3_DMA_FIFO       (*(volatile unsigned char *)0x52000248)
+#define rEP3_DMA_TX_LO      (*(volatile unsigned char *)0x5200024C)
+#define rEP3_DMA_TX_MD      (*(volatile unsigned char *)0x52000250)
+#define rEP3_DMA_TX_HI      (*(volatile unsigned char *)0x52000254)
+#define rEP4_DMA_CON        (*(volatile unsigned char *)0x52000258)
+#define rEP4_DMA_UNIT       (*(volatile unsigned char *)0x5200025C)
+#define rEP4_DMA_FIFO       (*(volatile unsigned char *)0x52000260)
+#define rEP4_DMA_TX_LO      (*(volatile unsigned char *)0x52000264)
+#define rEP4_DMA_TX_MD      (*(volatile unsigned char *)0x52000268)
+#define rEP4_DMA_TX_HI      (*(volatile unsigned char *)0x5200026C)
 #endif /*  __BIG_ENDIAN */
 
 
 /* WATCH DOG TIMER */
-#define rWTCON			(*(volatile unsigned *)0x53000000)
-#define rWTDAT			(*(volatile unsigned *)0x53000004)
-#define rWTCNT			(*(volatile unsigned *)0x53000008)
+#define rWTCON          (*(volatile unsigned *)0x53000000)
+#define rWTDAT          (*(volatile unsigned *)0x53000004)
+#define rWTCNT          (*(volatile unsigned *)0x53000008)
 
 
 /* IIC */
-#define rIICCON			(*(volatile unsigned *)0x54000000)
-#define rIICSTAT		(*(volatile unsigned *)0x54000004)
-#define rIICADD			(*(volatile unsigned *)0x54000008)
-#define rIICDS			(*(volatile unsigned *)0x5400000C)
+#define rIICCON         (*(volatile unsigned *)0x54000000)
+#define rIICSTAT        (*(volatile unsigned *)0x54000004)
+#define rIICADD         (*(volatile unsigned *)0x54000008)
+#define rIICDS          (*(volatile unsigned *)0x5400000C)
 
 
 /* IIS */
-#define rIISCON			(*(volatile unsigned *)0x55000000)
-#define rIISMOD			(*(volatile unsigned *)0x55000004)
-#define rIISPSR			(*(volatile unsigned *)0x55000008)
-#define rIISFCON		(*(volatile unsigned *)0x5500000C)
+#define rIISCON         (*(volatile unsigned *)0x55000000)
+#define rIISMOD         (*(volatile unsigned *)0x55000004)
+#define rIISPSR         (*(volatile unsigned *)0x55000008)
+#define rIISFCON        (*(volatile unsigned *)0x5500000C)
 
 #ifdef __BIG_ENDIAN
-#define IISFIF			((volatile unsigned short *)0x55000012)
+#define IISFIF          ((volatile unsigned short *)0x55000012)
 #else /*  little endian */
-#define IISFIF			((volatile unsigned short *)0x55000010)
+#define IISFIF          ((volatile unsigned short *)0x55000010)
 #endif
 
 
 /* I/O PORT */
-#define rGPACON			(*(volatile unsigned *)0x56000000)
-#define rGPADAT			(*(volatile unsigned *)0x56000004)
+#define rGPACON         (*(volatile unsigned *)0x56000000)
+#define rGPADAT         (*(volatile unsigned *)0x56000004)
 
-#define rGPBCON			(*(volatile unsigned *)0x56000010)
-#define rGPBDAT			(*(volatile unsigned *)0x56000014)
-#define rGPBUP			(*(volatile unsigned *)0x56000018)
-
-#define rGPCCON			(*(volatile unsigned *)0x56000020)
-#define rGPCDAT			(*(volatile unsigned *)0x56000024)
-#define rGPCUP			(*(volatile unsigned *)0x56000028)
-
-#define rGPDCON			(*(volatile unsigned *)0x56000030)
-#define rGPDDAT			(*(volatile unsigned *)0x56000034)
-#define rGPDUP			(*(volatile unsigned *)0x56000038)
-
-#define rGPECON			(*(volatile unsigned *)0x56000040)
-#define rGPEDAT			(*(volatile unsigned *)0x56000044)
-#define rGPEUP			(*(volatile unsigned *)0x56000048)
-
-#define rGPFCON			(*(volatile unsigned *)0x56000050)
-#define rGPFDAT			(*(volatile unsigned *)0x56000054)
-#define rGPFUP			(*(volatile unsigned *)0x56000058)
-
-#define rGPGCON			(*(volatile unsigned *)0x56000060)
-#define rGPGDAT			(*(volatile unsigned *)0x56000064)
-#define rGPGUP			(*(volatile unsigned *)0x56000068)
-
-#define rGPHCON			(*(volatile unsigned *)0x56000070)
-#define rGPHDAT			(*(volatile unsigned *)0x56000074)
-#define rGPHUP			(*(volatile unsigned *)0x56000078)
-
-#define rMISCCR			(*(volatile unsigned *)0x56000080)
-#define rDCLKCON		(*(volatile unsigned *)0x56000084)
-#define rEXTINT0		(*(volatile unsigned *)0x56000088)
-#define rEXTINT1		(*(volatile unsigned *)0x5600008C)
-#define rEXTINT2		(*(volatile unsigned *)0x56000090)
-#define rEINTFLT0		(*(volatile unsigned *)0x56000094)
-#define rEINTFLT1		(*(volatile unsigned *)0x56000098)
-#define rEINTFLT2		(*(volatile unsigned *)0x5600009C)
-#define rEINTFLT3		(*(volatile unsigned *)0x560000A0)
-#define rEINTMASK		(*(volatile unsigned *)0x560000A4)
-#define rEINTPEND		(*(volatile unsigned *)0x560000A8)
-#define rGSTATUS0		(*(volatile unsigned *)0x560000AC)
-#define rGSTATUS1		(*(volatile unsigned *)0x560000B0)
+#define rGPBCON         (*(volatile unsigned *)0x56000010)
+#define rGPBDAT         (*(volatile unsigned *)0x56000014)
+#define rGPBUP          (*(volatile unsigned *)0x56000018)
+
+#define rGPCCON         (*(volatile unsigned *)0x56000020)
+#define rGPCDAT         (*(volatile unsigned *)0x56000024)
+#define rGPCUP          (*(volatile unsigned *)0x56000028)
+
+#define rGPDCON         (*(volatile unsigned *)0x56000030)
+#define rGPDDAT         (*(volatile unsigned *)0x56000034)
+#define rGPDUP          (*(volatile unsigned *)0x56000038)
+
+#define rGPECON         (*(volatile unsigned *)0x56000040)
+#define rGPEDAT         (*(volatile unsigned *)0x56000044)
+#define rGPEUP          (*(volatile unsigned *)0x56000048)
+
+#define rGPFCON         (*(volatile unsigned *)0x56000050)
+#define rGPFDAT         (*(volatile unsigned *)0x56000054)
+#define rGPFUP          (*(volatile unsigned *)0x56000058)
+
+#define rGPGCON         (*(volatile unsigned *)0x56000060)
+#define rGPGDAT         (*(volatile unsigned *)0x56000064)
+#define rGPGUP          (*(volatile unsigned *)0x56000068)
+
+#define rGPHCON         (*(volatile unsigned *)0x56000070)
+#define rGPHDAT         (*(volatile unsigned *)0x56000074)
+#define rGPHUP          (*(volatile unsigned *)0x56000078)
+
+#define rMISCCR         (*(volatile unsigned *)0x56000080)
+#define rDCLKCON        (*(volatile unsigned *)0x56000084)
+#define rEXTINT0        (*(volatile unsigned *)0x56000088)
+#define rEXTINT1        (*(volatile unsigned *)0x5600008C)
+#define rEXTINT2        (*(volatile unsigned *)0x56000090)
+#define rEINTFLT0       (*(volatile unsigned *)0x56000094)
+#define rEINTFLT1       (*(volatile unsigned *)0x56000098)
+#define rEINTFLT2       (*(volatile unsigned *)0x5600009C)
+#define rEINTFLT3       (*(volatile unsigned *)0x560000A0)
+#define rEINTMASK       (*(volatile unsigned *)0x560000A4)
+#define rEINTPEND       (*(volatile unsigned *)0x560000A8)
+#define rGSTATUS0       (*(volatile unsigned *)0x560000AC)
+#define rGSTATUS1       (*(volatile unsigned *)0x560000B0)
 
 
 /* RTC */
 #ifdef __BIG_ENDIAN
-#define rRTCCON			(*(volatile unsigned char *)0x57000043)
-#define rTICNT			(*(volatile unsigned char *)0x57000047)
-#define rRTCALM			(*(volatile unsigned char *)0x57000053)
-#define rALMSEC			(*(volatile unsigned char *)0x57000057)
-#define rALMMIN			(*(volatile unsigned char *)0x5700005B)
-#define rALMHOUR		(*(volatile unsigned char *)0x5700005F)
-#define rALMDATE		(*(volatile unsigned char *)0x57000063)
-#define rALMMON			(*(volatile unsigned char *)0x57000067)
-#define rALMYEAR		(*(volatile unsigned char *)0x5700006B)
-#define rRTCRST			(*(volatile unsigned char *)0x5700006F)
-#define rBCDSEC			(*(volatile unsigned char *)0x57000073)
-#define rBCDMIN			(*(volatile unsigned char *)0x57000077)
-#define rBCDHOUR		(*(volatile unsigned char *)0x5700007B)
-#define rBCDDATE		(*(volatile unsigned char *)0x5700007F)
-#define rBCDDAY			(*(volatile unsigned char *)0x57000083)
-#define rBCDMON			(*(volatile unsigned char *)0x57000087)
-#define rBCDYEAR		(*(volatile unsigned char *)0x5700008B)
+#define rRTCCON         (*(volatile unsigned char *)0x57000043)
+#define rTICNT          (*(volatile unsigned char *)0x57000047)
+#define rRTCALM         (*(volatile unsigned char *)0x57000053)
+#define rALMSEC         (*(volatile unsigned char *)0x57000057)
+#define rALMMIN         (*(volatile unsigned char *)0x5700005B)
+#define rALMHOUR        (*(volatile unsigned char *)0x5700005F)
+#define rALMDATE        (*(volatile unsigned char *)0x57000063)
+#define rALMMON         (*(volatile unsigned char *)0x57000067)
+#define rALMYEAR        (*(volatile unsigned char *)0x5700006B)
+#define rRTCRST         (*(volatile unsigned char *)0x5700006F)
+#define rBCDSEC         (*(volatile unsigned char *)0x57000073)
+#define rBCDMIN         (*(volatile unsigned char *)0x57000077)
+#define rBCDHOUR        (*(volatile unsigned char *)0x5700007B)
+#define rBCDDATE        (*(volatile unsigned char *)0x5700007F)
+#define rBCDDAY         (*(volatile unsigned char *)0x57000083)
+#define rBCDMON         (*(volatile unsigned char *)0x57000087)
+#define rBCDYEAR        (*(volatile unsigned char *)0x5700008B)
 #else /*  little endian */
-#define rRTCCON			(*(volatile unsigned char *)0x57000040)
-#define rTICNT			(*(volatile unsigned char *)0x57000044)
-#define rRTCALM			(*(volatile unsigned char *)0x57000050)
-#define rALMSEC			(*(volatile unsigned char *)0x57000054)
-#define rALMMIN			(*(volatile unsigned char *)0x57000058)
-#define rALMHOUR		(*(volatile unsigned char *)0x5700005C)
-#define rALMDATE		(*(volatile unsigned char *)0x57000060)
-#define rALMMON			(*(volatile unsigned char *)0x57000064)
-#define rALMYEAR		(*(volatile unsigned char *)0x57000068)
-#define rRTCRST			(*(volatile unsigned char *)0x5700006C)
-#define rBCDSEC			(*(volatile unsigned char *)0x57000070)
-#define rBCDMIN			(*(volatile unsigned char *)0x57000074)
-#define rBCDHOUR		(*(volatile unsigned char *)0x57000078)
-#define rBCDDATE		(*(volatile unsigned char *)0x5700007C)
-#define rBCDDAY			(*(volatile unsigned char *)0x57000080)
-#define rBCDMON			(*(volatile unsigned char *)0x57000084)
-#define rBCDYEAR		(*(volatile unsigned char *)0x57000088)
+#define rRTCCON         (*(volatile unsigned char *)0x57000040)
+#define rTICNT          (*(volatile unsigned char *)0x57000044)
+#define rRTCALM         (*(volatile unsigned char *)0x57000050)
+#define rALMSEC         (*(volatile unsigned char *)0x57000054)
+#define rALMMIN         (*(volatile unsigned char *)0x57000058)
+#define rALMHOUR        (*(volatile unsigned char *)0x5700005C)
+#define rALMDATE        (*(volatile unsigned char *)0x57000060)
+#define rALMMON         (*(volatile unsigned char *)0x57000064)
+#define rALMYEAR        (*(volatile unsigned char *)0x57000068)
+#define rRTCRST         (*(volatile unsigned char *)0x5700006C)
+#define rBCDSEC         (*(volatile unsigned char *)0x57000070)
+#define rBCDMIN         (*(volatile unsigned char *)0x57000074)
+#define rBCDHOUR        (*(volatile unsigned char *)0x57000078)
+#define rBCDDATE        (*(volatile unsigned char *)0x5700007C)
+#define rBCDDAY         (*(volatile unsigned char *)0x57000080)
+#define rBCDMON         (*(volatile unsigned char *)0x57000084)
+#define rBCDYEAR        (*(volatile unsigned char *)0x57000088)
 #endif
 
 
 /* ADC */
-#define rADCCON			(*(volatile unsigned *)0x58000000)
-#define rADCTSC			(*(volatile unsigned *)0x58000004)
-#define rADCDLY			(*(volatile unsigned *)0x58000008)
-#define rADCDAT0		(*(volatile unsigned *)0x5800000C)
-#define rADCDAT1		(*(volatile unsigned *)0x58000010)
+#define rADCCON         (*(volatile unsigned *)0x58000000)
+#define rADCTSC         (*(volatile unsigned *)0x58000004)
+#define rADCDLY         (*(volatile unsigned *)0x58000008)
+#define rADCDAT0        (*(volatile unsigned *)0x5800000C)
+#define rADCDAT1        (*(volatile unsigned *)0x58000010)
 
 
 /* SPI */
-#define rSPCON0			(*(volatile unsigned *)0x59000000)
-#define rSPSTA0			(*(volatile unsigned *)0x59000004)
-#define rSPPIN0			(*(volatile unsigned *)0x59000008)
-#define rSPPRE0			(*(volatile unsigned *)0x5900000C)
-#define rSPTDAT0		(*(volatile unsigned *)0x59000010)
-#define rSPRDAT0		(*(volatile unsigned *)0x59000014)
-#define rSPCON1			(*(volatile unsigned *)0x59000020)
-#define rSPSTA1			(*(volatile unsigned *)0x59000024)
-#define rSPPIN1			(*(volatile unsigned *)0x59000028)
-#define rSPPRE1			(*(volatile unsigned *)0x5900002C)
-#define rSPTDAT1		(*(volatile unsigned *)0x59000030)
-#define rSPRDAT1		(*(volatile unsigned *)0x59000034)
+#define rSPCON0         (*(volatile unsigned *)0x59000000)
+#define rSPSTA0         (*(volatile unsigned *)0x59000004)
+#define rSPPIN0         (*(volatile unsigned *)0x59000008)
+#define rSPPRE0         (*(volatile unsigned *)0x5900000C)
+#define rSPTDAT0        (*(volatile unsigned *)0x59000010)
+#define rSPRDAT0        (*(volatile unsigned *)0x59000014)
+#define rSPCON1         (*(volatile unsigned *)0x59000020)
+#define rSPSTA1         (*(volatile unsigned *)0x59000024)
+#define rSPPIN1         (*(volatile unsigned *)0x59000028)
+#define rSPPRE1         (*(volatile unsigned *)0x5900002C)
+#define rSPTDAT1        (*(volatile unsigned *)0x59000030)
+#define rSPRDAT1        (*(volatile unsigned *)0x59000034)
 
 
 /* SD INTERFACE */
-#define rSDICON			(*(volatile unsigned *)0x5A000000)
-#define rSDIPRE			(*(volatile unsigned *)0x5A000004)
-#define rSDICmdArg		(*(volatile unsigned *)0x5A000008)
-#define rSDICmdCon		(*(volatile unsigned *)0x5A00000C)
-#define rSDICmdSta		(*(volatile unsigned *)0x5A000010)
-#define rSDIRSP0		(*(volatile unsigned *)0x5A000014)
-#define rSDIRSP1		(*(volatile unsigned *)0x5A000018)
-#define rSDIRSP2		(*(volatile unsigned *)0x5A00001C)
-#define rSDIRSP3		(*(volatile unsigned *)0x5A000020)
-#define rSDIDTimer		(*(volatile unsigned *)0x5A000024)
-#define rSDIBSize		(*(volatile unsigned *)0x5A000028)
-#define rSDIDatCon		(*(volatile unsigned *)0x5A00002C)
-#define rSDIDatCnt		(*(volatile unsigned *)0x5A000030)
-#define rSDIDatSta		(*(volatile unsigned *)0x5A000034)
-#define rSDIFSTA		(*(volatile unsigned *)0x5A000038)
+#define rSDICON         (*(volatile unsigned *)0x5A000000)
+#define rSDIPRE         (*(volatile unsigned *)0x5A000004)
+#define rSDICmdArg      (*(volatile unsigned *)0x5A000008)
+#define rSDICmdCon      (*(volatile unsigned *)0x5A00000C)
+#define rSDICmdSta      (*(volatile unsigned *)0x5A000010)
+#define rSDIRSP0        (*(volatile unsigned *)0x5A000014)
+#define rSDIRSP1        (*(volatile unsigned *)0x5A000018)
+#define rSDIRSP2        (*(volatile unsigned *)0x5A00001C)
+#define rSDIRSP3        (*(volatile unsigned *)0x5A000020)
+#define rSDIDTimer      (*(volatile unsigned *)0x5A000024)
+#define rSDIBSize       (*(volatile unsigned *)0x5A000028)
+#define rSDIDatCon      (*(volatile unsigned *)0x5A00002C)
+#define rSDIDatCnt      (*(volatile unsigned *)0x5A000030)
+#define rSDIDatSta      (*(volatile unsigned *)0x5A000034)
+#define rSDIFSTA        (*(volatile unsigned *)0x5A000038)
 #ifdef __BIG_ENDIAN
-#define rSDIDAT			(*(volatile unsigned char *)0x5A00003F)
+#define rSDIDAT         (*(volatile unsigned char *)0x5A00003F)
 #else
-#define rSDIDAT			(*(volatile unsigned char *)0x5A00003C)
+#define rSDIDAT         (*(volatile unsigned char *)0x5A00003C)
 #endif
-#define rSDIIntMsk		(*(volatile unsigned *)0x5A000040)
+#define rSDIIntMsk      (*(volatile unsigned *)0x5A000040)
 
 #endif
 
+#define rGSTATUS1       (*(volatile unsigned *)0x560000B0)
+#define isS3C2410 		((rGSTATUS1 & 0xffff0000) == 0x32410000)
+
 #endif /*__S3C24X0_H__*/
diff -urN u-boot-1.1.6/Makefile u-boot-1.1.6_jz2440/Makefile
--- u-boot-1.1.6/Makefile	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_jz2440/Makefile	2010-11-26 12:54:37.830153999 +0800
@@ -206,8 +206,8 @@
 LIBS += drivers/libdrivers.a
 LIBS += drivers/nand/libnand.a
 LIBS += drivers/nand_legacy/libnand_legacy.a
+//LIBS += drivers/usb/libusb.a
 LIBS += drivers/sk98lin/libsk98lin.a
-LIBS += post/libpost.a post/cpu/libcpu.a
 LIBS += common/libcommon.a
 LIBS += $(BOARDLIBS)
 
@@ -266,11 +266,15 @@
 			-Map u-boot.map -o u-boot
 
 $(OBJS):
+	echo $(OBJS)	
 		$(MAKE) -C cpu/$(CPU) $(if $(REMOTE_BUILD),$@,$(notdir $@))
 
 $(LIBS):
 		$(MAKE) -C $(dir $(subst $(obj),,$@))
 
+usb:
+	$(MAKE) -C drivers/usb
+
 $(SUBDIRS):
 		$(MAKE) -C $@ all
 
@@ -1879,6 +1883,9 @@
 smdk2410_config	:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm920t smdk2410 NULL s3c24x0
 
+100ask24x0_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t 100ask24x0 NULL s3c24x0
+
 SX1_config :		unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm925t sx1
 

