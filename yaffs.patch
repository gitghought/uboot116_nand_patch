diff -urN u-boot-1.1.6_jz2440/board/100ask24x0/100ask24x0.c u-boot-1.1.6_nand_ok/board/100ask24x0/100ask24x0.c
--- u-boot-1.1.6_jz2440/board/100ask24x0/100ask24x0.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_nand_ok/board/100ask24x0/100ask24x0.c	2010-11-26 12:54:37.034090906 +0800
@@ -0,0 +1,96 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <s3c2410.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+    S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+    S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+
+    /* set up the I/O ports */
+    gpio->GPACON = 0x007FFFFF;
+    gpio->GPBCON = 0x00044555;
+    gpio->GPBUP = 0x000007FF;
+    gpio->GPCCON = 0xAAAAAAAA;
+    gpio->GPCUP = 0x0000FFFF;
+    gpio->GPDCON = 0xAAAAAAAA;
+    gpio->GPDUP = 0x0000FFFF;
+    gpio->GPECON = 0xAAAAAAAA;
+    gpio->GPEUP = 0x0000FFFF;
+    gpio->GPFCON = 0x000055AA;
+    gpio->GPFUP = 0x000000FF;
+    gpio->GPGCON = 0xFF95FFBA;
+    gpio->GPGUP = 0x0000FFFF;
+    gpio->GPHCON = 0x002AFAAA;
+    gpio->GPHUP = 0x000007FF;
+
+    /* support both of S3C2410 and S3C2440, by www.100ask.net */
+    if (isS3C2410)
+    {
+        /* arch number of SMDK2410-Board */
+        gd->bd->bi_arch_number = MACH_TYPE_SMDK2410;
+    }
+    else
+    {
+        /* arch number of SMDK2440-Board */
+        gd->bd->bi_arch_number = MACH_TYPE_S3C2440;
+    }
+
+    /* adress of boot parameters */
+    gd->bd->bi_boot_params = 0x30000100;
+#if 0
+    icache_enable();
+    dcache_enable();
+#endif
+    return 0;
+}
+
+int dram_init (void)
+{
+    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+    return 0;
+}
+
+ulong board_flash_get_legacy(ulong base, int banknum, flash_info_t *info)
+{	
+	info->portwidth = CFG_FLASH_CFI_WIDTH;
+	info->chipwidth = CFG_FLASH_CFI_WIDTH;
+	info->interface = FLASH_CFI_X16;
+	return 1;
+}
+
+
diff -urN u-boot-1.1.6_jz2440/board/100ask24x0/boot_init.c u-boot-1.1.6_nand_ok/board/100ask24x0/boot_init.c
--- u-boot-1.1.6_jz2440/board/100ask24x0/boot_init.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_nand_ok/board/100ask24x0/boot_init.c	2010-11-26 12:54:37.042080086 +0800
@@ -0,0 +1,566 @@
+#include <common.h>
+#include <s3c2410.h>
+
+#define BUSY            1
+
+#define NAND_SECTOR_SIZE    512
+#define NAND_BLOCK_MASK     (NAND_SECTOR_SIZE - 1)
+
+#define NAND_SECTOR_SIZE_LP    2048
+#define NAND_BLOCK_MASK_LP     (NAND_SECTOR_SIZE_LP - 1)
+
+/* 供外部调用的函数 */
+void nand_init_ll(void);
+void nand_read_ll(unsigned char *buf, unsigned long start_addr, int size);
+
+/* NAND Flash操作的总入口, 它们将调用S3C2410或S3C2440的相应函数 */
+static void nand_reset(void);
+static void wait_idle(void);
+static void nand_select_chip(void);
+static void nand_deselect_chip(void);
+static void write_cmd(int cmd);
+static void write_addr(unsigned int addr);
+static unsigned char read_data(void);
+
+/* S3C2410的NAND Flash处理函数 */
+static void s3c2410_nand_reset(void);
+static void s3c2410_wait_idle(void);
+static void s3c2410_nand_select_chip(void);
+static void s3c2410_nand_deselect_chip(void);
+static void s3c2410_write_cmd(int cmd);
+static void s3c2410_write_addr(unsigned int addr);
+static unsigned char s3c2410_read_data(void);
+
+/* S3C2440的NAND Flash处理函数 */
+static void s3c2440_nand_reset(void);
+static void s3c2440_wait_idle(void);
+static void s3c2440_nand_select_chip(void);
+static void s3c2440_nand_deselect_chip(void);
+static void s3c2440_write_cmd(int cmd);
+static void s3c2440_write_addr(unsigned int addr);
+static unsigned char s3c2440_read_data(void);
+
+/* S3C2410的NAND Flash操作函数 */
+
+/* 复位 */
+static void s3c2410_nand_reset(void)
+{
+    s3c2410_nand_select_chip();
+    s3c2410_write_cmd(0xff);  // 复位命令
+    s3c2410_wait_idle();
+    s3c2410_nand_deselect_chip();
+}
+
+/* 等待NAND Flash就绪 */
+static void s3c2410_wait_idle(void)
+{
+    int i;
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+	
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2410nand->NFSTAT;
+    while(!(*p & BUSY))
+        for(i=0; i<10; i++);
+}
+
+/* 发出片选信号 */
+static void s3c2410_nand_select_chip(void)
+{
+    int i;
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+
+    s3c2410nand->NFCONF &= ~(1<<11);
+    for(i=0; i<10; i++);    
+}
+
+/* 取消片选信号 */
+static void s3c2410_nand_deselect_chip(void)
+{
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+
+    s3c2410nand->NFCONF |= (1<<11);
+}
+
+/* 发出命令 */
+static void s3c2410_write_cmd(int cmd)
+{
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2410nand->NFCMD;
+    *p = cmd;
+}
+
+/* 发出地址 */
+static void s3c2410_write_addr(unsigned int addr)
+{
+    int i;
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2410nand->NFADDR;
+    
+    *p = addr & 0xff;
+    for(i=0; i<10; i++);
+    *p = (addr >> 9) & 0xff;
+    for(i=0; i<10; i++);
+    *p = (addr >> 17) & 0xff;
+    for(i=0; i<10; i++);
+    *p = (addr >> 25) & 0xff;
+    for(i=0; i<10; i++);
+}
+
+/* 读取数据 */
+static unsigned char s3c2410_read_data(void)
+{
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2410nand->NFDATA;
+    return *p;
+}
+
+/* S3C2440的NAND Flash操作函数 */
+
+/* 复位 */
+static void s3c2440_nand_reset(void)
+{
+    s3c2440_nand_select_chip();
+    s3c2440_write_cmd(0xff);  // 复位命令
+    s3c2440_wait_idle();
+    s3c2440_nand_deselect_chip();
+}
+
+/* 等待NAND Flash就绪 */
+static void s3c2440_wait_idle(void)
+{
+    int i;
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFSTAT;
+
+    while(!(*p & BUSY))
+        for(i=0; i<10; i++);
+}
+
+/* 发出片选信号 */
+static void s3c2440_nand_select_chip(void)
+{
+    int i;
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+
+    s3c2440nand->NFCONT &= ~(1<<1);
+    for(i=0; i<10; i++);    
+}
+
+/* 取消片选信号 */
+static void s3c2440_nand_deselect_chip(void)
+{
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+
+    s3c2440nand->NFCONT |= (1<<1);
+}
+
+/* 发出命令 */
+static void s3c2440_write_cmd(int cmd)
+{
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFCMD;
+    *p = cmd;
+}
+
+/* 发出地址 */
+static void s3c2440_write_addr(unsigned int addr)
+{
+    int i;
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
+    
+    *p = addr & 0xff;
+    for(i=0; i<10; i++);
+    *p = (addr >> 9) & 0xff;
+    for(i=0; i<10; i++);
+    *p = (addr >> 17) & 0xff;
+    for(i=0; i<10; i++);
+    *p = (addr >> 25) & 0xff;
+    for(i=0; i<10; i++);
+}
+
+
+/* 发出地址 */
+static void s3c2440_write_addr_lp(unsigned int addr)
+{
+    int i;
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
+	int col, page;
+
+	col = addr & NAND_BLOCK_MASK_LP;
+	page = addr / NAND_SECTOR_SIZE_LP;
+	
+    *p = col & 0xff;			/* Column Address A0~A7 */
+    for(i=0; i<10; i++);		
+    *p = (col >> 8) & 0x0f;		/* Column Address A8~A11 */
+    for(i=0; i<10; i++);
+    *p = page & 0xff;			/* Row Address A12~A19 */
+    for(i=0; i<10; i++);
+    *p = (page >> 8) & 0xff;	/* Row Address A20~A27 */
+    for(i=0; i<10; i++);
+    *p = (page >> 16) & 0x03;	/* Row Address A28~A29 */
+    for(i=0; i<10; i++);
+}
+
+/* 读取数据 */
+static unsigned char s3c2440_read_data(void)
+{
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFDATA;
+    return *p;
+}
+
+
+/* 在第一次使用NAND Flash前，复位一下NAND Flash */
+static void nand_reset(void)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_nand_reset();
+	}
+	else
+	{
+	    s3c2440_nand_reset();
+	}
+}
+
+static void wait_idle(void)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_wait_idle();
+	}
+	else
+	{
+	    s3c2440_wait_idle();
+	}
+}
+
+static void nand_select_chip(void)
+{
+    int i;
+	
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_nand_select_chip();
+	}
+	else
+	{
+	    s3c2440_nand_select_chip();
+	}
+	
+    for(i=0; i<10; i++);
+}
+
+static void nand_deselect_chip(void)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_nand_deselect_chip();
+	}
+	else
+	{
+	    s3c2440_nand_deselect_chip();
+	}	
+}
+
+static void write_cmd(int cmd)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_write_cmd(cmd);
+	}
+	else
+	{
+	    s3c2440_write_cmd(cmd);
+	}	
+}
+static void write_addr(unsigned int addr)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_write_addr(addr);
+	}
+	else
+	{
+	    s3c2440_write_addr(addr);
+	}	
+}
+
+static void write_addr_lp(unsigned int addr)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    s3c2410_write_addr(addr);
+	}
+	else
+	{
+	    s3c2440_write_addr_lp(addr);
+	}	
+}
+
+static unsigned char read_data(void)
+{
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+	{
+	    return s3c2410_read_data();
+	}
+	else
+	{
+	    return s3c2440_read_data();
+	}	
+}
+
+/* 初始化NAND Flash */
+void nand_init_ll(void)
+{
+	S3C2410_NAND * s3c2410nand = (S3C2410_NAND *)0x4e000000;
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+
+#define TACLS   0
+#define TWRPH0  3
+#define TWRPH1  0
+
+    /* 判断是S3C2410还是S3C2440 */
+    if (isS3C2410)
+    {
+		/* 使能NAND Flash控制器, 初始化ECC, 禁止片选, 设置时序 */
+        s3c2410nand->NFCONF = (1<<15)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0);
+    }
+    else
+    {
+		/* 设置时序 */
+        s3c2440nand->NFCONF = (TACLS<<12)|(TWRPH0<<8)|(TWRPH1<<4);
+        /* 使能NAND Flash控制器, 初始化ECC, 禁止片选 */
+        s3c2440nand->NFCONT = (1<<4)|(1<<1)|(1<<0);
+    }
+
+	/* 复位NAND Flash */
+	nand_reset();
+}
+
+
+/* 读函数 */
+void nand_read_ll(unsigned char *buf, unsigned long start_addr, int size)
+{
+    int i, j;
+    
+    if ((start_addr & NAND_BLOCK_MASK) || (size & NAND_BLOCK_MASK)) {
+        return ;    /* 地址或长度不对齐 */
+    }
+
+    /* 选中芯片 */
+    nand_select_chip();
+
+    for(i=start_addr; i < (start_addr + size);) {
+      /* 发出READ0命令 */
+      write_cmd(0);
+
+      /* Write Address */
+      write_addr(i);
+      wait_idle();
+
+      for(j=0; j < NAND_SECTOR_SIZE; j++, i++) {
+          *buf = read_data();
+          buf++;
+      }
+    }
+
+    /* 取消片选信号 */
+    nand_deselect_chip();
+    
+    return ;
+}
+
+
+/* 读函数 
+  * Large Page
+  */
+void nand_read_ll_lp(unsigned char *buf, unsigned long start_addr, int size)
+{
+    int i, j;
+    
+    if ((start_addr & NAND_BLOCK_MASK_LP) || (size & NAND_BLOCK_MASK_LP)) {
+        return ;    /* 地址或长度不对齐 */
+    }
+
+    /* 选中芯片 */
+    nand_select_chip();
+
+    for(i=start_addr; i < (start_addr + size);) {
+      /* 发出READ0命令 */
+      write_cmd(0);
+
+      /* Write Address */
+      write_addr_lp(i);
+	  write_cmd(0x30);
+      wait_idle();
+
+      for(j=0; j < NAND_SECTOR_SIZE_LP; j++, i++) {
+          *buf = read_data();
+          buf++;
+      }
+    }
+
+    /* 取消片选信号 */
+    nand_deselect_chip();
+    
+    return ;
+}
+
+int bBootFrmNORFlash(void)
+{
+    volatile unsigned int *pdw = (volatile unsigned int *)0;
+    unsigned int dwVal;
+    
+    /*
+     * 无论是从NOR Flash还是从NAND Flash启动，
+     * 地址0处为指令"b	Reset", 机器码为0xEA00000B，
+     * 对于从NAND Flash启动的情况，其开始4KB的代码会复制到CPU内部4K内存中，
+     * 对于从NOR Flash启动的情况，NOR Flash的开始地址即为0。
+     * 对于NOR Flash，必须通过一定的命令序列才能写数据，
+     * 所以可以根据这点差别来分辨是从NAND Flash还是NOR Flash启动:
+     * 向地址0写入一个数据，然后读出来，如果没有改变的话就是NOR Flash
+     */
+
+    dwVal = *pdw;       
+    *pdw = 0x12345678;
+    if (*pdw != 0x12345678)
+    {
+        return 1;
+    }
+    else
+    {
+        *pdw = dwVal;
+        return 0;
+    }
+}
+
+int CopyCode2Ram(unsigned long start_addr, unsigned char *buf, int size)
+{
+    unsigned int *pdwDest;
+    unsigned int *pdwSrc;
+    int i;
+
+    if (bBootFrmNORFlash())
+    {
+        pdwDest = (unsigned int *)buf;
+        pdwSrc  = (unsigned int *)start_addr;
+        /* 从 NOR Flash启动 */
+        for (i = 0; i < size / 4; i++)
+        {
+            pdwDest[i] = pdwSrc[i];
+        }
+        return 0;
+    }
+    else
+    {
+        /* 初始化NAND Flash */
+		nand_init_ll();
+        /* 从 NAND Flash启动 */
+        nand_read_ll_lp(buf, start_addr, (size + NAND_BLOCK_MASK_LP)&~(NAND_BLOCK_MASK_LP));
+		return 0;
+    }
+}
+
+static inline void delay (unsigned long loops)
+{
+    __asm__ volatile ("1:\n"
+      "subs %0, %1, #1\n"
+      "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/* S3C2440: Mpll = (2*m * Fin) / (p * 2^s), UPLL = (m * Fin) / (p * 2^s)
+ * m = M (the value for divider M)+ 8, p = P (the value for divider P) + 2
+ */
+#define S3C2440_MPLL_400MHZ     ((0x5c<<12)|(0x01<<4)|(0x01))
+#define S3C2440_MPLL_200MHZ     ((0x5c<<12)|(0x01<<4)|(0x02))
+#define S3C2440_MPLL_100MHZ     ((0x5c<<12)|(0x01<<4)|(0x03))
+#define S3C2440_UPLL_96MHZ      ((0x38<<12)|(0x02<<4)|(0x01))
+#define S3C2440_UPLL_48MHZ      ((0x38<<12)|(0x02<<4)|(0x02))
+#define S3C2440_CLKDIV          (0x05) // | (1<<3))    /* FCLK:HCLK:PCLK = 1:4:8, UCLK = UPLL/2 */
+#define S3C2440_CLKDIV188       0x04    /* FCLK:HCLK:PCLK = 1:8:8 */
+#define S3C2440_CAMDIVN188      ((0<<8)|(1<<9)) /* FCLK:HCLK:PCLK = 1:8:8 */
+
+/* Fin = 16.9344MHz */
+#define S3C2440_MPLL_399MHz_Fin16MHz	((0x6e<<12)|(0x03<<4)|(0x01))
+#define S3C2440_UPLL_48MHZ_Fin16MHz     ((60<<12)|(4<<4)|(2))
+
+/* S3C2410: Mpll,Upll = (m * Fin) / (p * 2^s)
+ * m = M (the value for divider M)+ 8, p = P (the value for divider P) + 2
+ */
+#define S3C2410_MPLL_200MHZ     ((0x5c<<12)|(0x04<<4)|(0x00))
+#define S3C2410_UPLL_48MHZ      ((0x28<<12)|(0x01<<4)|(0x02))
+#define S3C2410_CLKDIV          0x03    /* FCLK:HCLK:PCLK = 1:2:4 */
+void clock_init(void)
+{
+	S3C24X0_CLOCK_POWER *clk_power = (S3C24X0_CLOCK_POWER *)0x4C000000;
+
+    /* support both of S3C2410 and S3C2440, by www.100ask.net */
+    if (isS3C2410)
+    {
+        /* FCLK:HCLK:PCLK = 1:2:4 */
+        clk_power->CLKDIVN = S3C2410_CLKDIV;
+
+        /* change to asynchronous bus mod */
+        __asm__(    "mrc    p15, 0, r1, c1, c0, 0\n"    /* read ctrl register   */  
+                    "orr    r1, r1, #0xc0000000\n"      /* Asynchronous         */  
+                    "mcr    p15, 0, r1, c1, c0, 0\n"    /* write ctrl register  */  
+                    :::"r1"
+                    );
+        
+        /* to reduce PLL lock time, adjust the LOCKTIME register */
+        clk_power->LOCKTIME = 0xFFFFFFFF;
+
+        /* configure UPLL */
+        clk_power->UPLLCON = S3C2410_UPLL_48MHZ;
+
+        /* some delay between MPLL and UPLL */
+        delay (4000);
+
+        /* configure MPLL */
+        clk_power->MPLLCON = S3C2410_MPLL_200MHZ;
+
+        /* some delay between MPLL and UPLL */
+        delay (8000);
+    }
+    else
+    {
+        /* FCLK:HCLK:PCLK = 1:4:8 */
+        clk_power->CLKDIVN = S3C2440_CLKDIV;
+
+        /* change to asynchronous bus mod */
+        __asm__(    "mrc    p15, 0, r1, c1, c0, 0\n"    /* read ctrl register   */  
+                    "orr    r1, r1, #0xc0000000\n"      /* Asynchronous         */  
+                    "mcr    p15, 0, r1, c1, c0, 0\n"    /* write ctrl register  */  
+                    :::"r1"
+                    );
+
+        /* to reduce PLL lock time, adjust the LOCKTIME register */
+        clk_power->LOCKTIME = 0xFFFFFFFF;
+
+        /* configure UPLL */
+        clk_power->UPLLCON = S3C2440_UPLL_48MHZ;
+
+        /* some delay between MPLL and UPLL */
+        delay (4000);
+
+        /* configure MPLL */
+        clk_power->MPLLCON = S3C2440_MPLL_400MHZ;
+
+        /* some delay between MPLL and UPLL */
+        delay (8000);
+    }
+}
+
diff -urN u-boot-1.1.6_jz2440/board/100ask24x0/config.mk u-boot-1.1.6_nand_ok/board/100ask24x0/config.mk
--- u-boot-1.1.6_jz2440/board/100ask24x0/config.mk	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_nand_ok/board/100ask24x0/config.mk	2010-11-26 12:54:37.022042833 +0800
@@ -0,0 +1,25 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# SAMSUNG SMDK2410 board with S3C2410X (ARM920T) cpu
+#
+# see http://www.samsung.com/ for more information on SAMSUNG
+#
+
+#
+# SMDK2410 has 1 bank of 64 MB DRAM
+#
+# 3000'0000 to 3400'0000
+#
+# Linux-Kernel is expected to be at 3000'8000, entry 3000'8000
+# optionally with a ramdisk at 3080'0000
+#
+# we load ourself to 33F8'0000
+#
+# download area is 3300'0000
+#
+
+
+TEXT_BASE = 0x33F80000
diff -urN u-boot-1.1.6_jz2440/board/100ask24x0/flash.c u-boot-1.1.6_nand_ok/board/100ask24x0/flash.c
--- u-boot-1.1.6_jz2440/board/100ask24x0/flash.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_nand_ok/board/100ask24x0/flash.c	2010-11-26 12:54:37.022042833 +0800
@@ -0,0 +1,433 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+ulong myflush (void);
+
+
+#define FLASH_BANK_SIZE	PHYS_FLASH_SIZE
+#define MAIN_SECT_SIZE  0x10000	/* 64 KB */
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+
+#define CMD_READ_ARRAY		0x000000F0
+#define CMD_UNLOCK1		0x000000AA
+#define CMD_UNLOCK2		0x00000055
+#define CMD_ERASE_SETUP		0x00000080
+#define CMD_ERASE_CONFIRM	0x00000030
+#define CMD_PROGRAM		0x000000A0
+#define CMD_UNLOCK_BYPASS	0x00000020
+
+#define MEM_FLASH_ADDR1		(*(volatile u16 *)(CFG_FLASH_BASE + (0x00000555 << 1)))
+#define MEM_FLASH_ADDR2		(*(volatile u16 *)(CFG_FLASH_BASE + (0x000002AA << 1)))
+
+#define BIT_ERASE_DONE		0x00000080
+#define BIT_RDY_MASK		0x00000080
+#define BIT_PROGRAM_ERROR	0x00000020
+#define BIT_TIMEOUT		0x80000000	/* our flag */
+
+#define READY 1
+#define ERR   2
+#define TMO   4
+
+/*-----------------------------------------------------------------------
+ */
+
+ulong flash_init (void)
+{
+	int i, j;
+	ulong size = 0;
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		ulong flashbase = 0;
+
+		flash_info[i].flash_id =
+#if defined(CONFIG_AMD_LV400)
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV400B & FLASH_TYPEMASK);
+#elif defined(CONFIG_AMD_LV800)
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV800B & FLASH_TYPEMASK);
+#else
+#error "Unknown flash configured"
+#endif
+			flash_info[i].size = FLASH_BANK_SIZE;
+		flash_info[i].sector_count = CFG_MAX_FLASH_SECT;
+		memset (flash_info[i].protect, 0, CFG_MAX_FLASH_SECT);
+		if (i == 0)
+			flashbase = PHYS_FLASH_1;
+		else
+			panic ("configured too many flash banks!\n");
+		for (j = 0; j < flash_info[i].sector_count; j++) {
+			if (j <= 3) {
+				/* 1st one is 16 KB */
+				if (j == 0) {
+					flash_info[i].start[j] =
+						flashbase + 0;
+				}
+
+				/* 2nd and 3rd are both 8 KB */
+				if ((j == 1) || (j == 2)) {
+					flash_info[i].start[j] =
+						flashbase + 0x4000 + (j -
+								      1) *
+						0x2000;
+				}
+
+				/* 4th 32 KB */
+				if (j == 3) {
+					flash_info[i].start[j] =
+						flashbase + 0x8000;
+				}
+			} else {
+				flash_info[i].start[j] =
+					flashbase + (j - 3) * MAIN_SECT_SIZE;
+			}
+		}
+		size += flash_info[i].size;
+	}
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CFG_FLASH_BASE,
+		       CFG_FLASH_BASE + monitor_flash_len - 1,
+		       &flash_info[0]);
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CFG_ENV_ADDR,
+		       CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		printf ("AMD: ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (AMD_ID_LV400B & FLASH_TYPEMASK):
+		printf ("1x Amd29LV400BB (4Mbit)\n");
+		break;
+	case (AMD_ID_LV800B & FLASH_TYPEMASK):
+		printf ("1x Amd29LV800BB (8Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		goto Done;
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+			info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+
+      Done:;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	ushort result;
+	int iflag, cflag, prot, sect;
+	int rc = ERR_OK;
+	int chip;
+
+	/* first look for protection bits */
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+	    (AMD_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+		printf ("Erasing sector %2d ... ", sect);
+
+		/* arm simple, non interrupt dependent timer */
+		reset_timer_masked ();
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			vu_short *addr = (vu_short *) (info->start[sect]);
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			MEM_FLASH_ADDR1 = CMD_ERASE_SETUP;
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			*addr = CMD_ERASE_CONFIRM;
+
+			/* wait until flash is ready */
+			chip = 0;
+
+			do {
+				result = *addr;
+
+				/* check timeout */
+				if (get_timer_masked () >
+				    CFG_FLASH_ERASE_TOUT) {
+					MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+					chip = TMO;
+					break;
+				}
+
+				if (!chip
+				    && (result & 0xFFFF) & BIT_ERASE_DONE)
+					chip = READY;
+
+				if (!chip
+				    && (result & 0xFFFF) & BIT_PROGRAM_ERROR)
+					chip = ERR;
+
+			} while (!chip);
+
+			MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+
+			if (chip == ERR) {
+				rc = ERR_PROG_ERROR;
+				goto outahere;
+			}
+			if (chip == TMO) {
+				rc = ERR_TIMOUT;
+				goto outahere;
+			}
+
+			printf ("ok.\n");
+		} else {	/* it was protected */
+
+			printf ("protected!\n");
+		}
+	}
+
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+      outahere:
+	/* allow flash to settle - wait 10 ms */
+	udelay_masked (10000);
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+volatile static int write_hword (flash_info_t * info, ulong dest, ushort data)
+{
+	vu_short *addr = (vu_short *) dest;
+	ushort result;
+	int rc = ERR_OK;
+	int cflag, iflag;
+	int chip;
+
+	/*
+	 * Check if Flash is (sufficiently) erased
+	 */
+	result = *addr;
+	if ((result & data) != data)
+		return ERR_NOT_ERASED;
+
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+	MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+	MEM_FLASH_ADDR1 = CMD_UNLOCK_BYPASS;
+	*addr = CMD_PROGRAM;
+	*addr = data;
+
+	/* arm simple, non interrupt dependent timer */
+	reset_timer_masked ();
+
+	/* wait until flash is ready */
+	chip = 0;
+	do {
+		result = *addr;
+
+		/* check timeout */
+		if (get_timer_masked () > CFG_FLASH_ERASE_TOUT) {
+			chip = ERR | TMO;
+			break;
+		}
+		if (!chip && ((result & 0x80) == (data & 0x80)))
+			chip = READY;
+
+		if (!chip && ((result & 0xFFFF) & BIT_PROGRAM_ERROR)) {
+			result = *addr;
+
+			if ((result & 0x80) == (data & 0x80))
+				chip = READY;
+			else
+				chip = ERR;
+		}
+
+	} while (!chip);
+
+	*addr = CMD_READ_ARRAY;
+
+	if (chip == ERR || *addr != data)
+		rc = ERR_PROG_ERROR;
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	int l;
+	int i, rc;
+	ushort data;
+
+	wp = (addr & ~1);	/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+		for (; i < 2 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 8);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 2; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+
+		if ((rc = write_hword (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 2) {
+		data = *((vu_short *) src);
+		if ((rc = write_hword (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 8);
+		--cnt;
+	}
+	for (; i < 2; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 8);
+	}
+
+	return write_hword (info, wp, data);
+}
diff -urN u-boot-1.1.6_jz2440/board/100ask24x0/lowlevel_init.S u-boot-1.1.6_nand_ok/board/100ask24x0/lowlevel_init.S
--- u-boot-1.1.6_jz2440/board/100ask24x0/lowlevel_init.S	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_nand_ok/board/100ask24x0/lowlevel_init.S	2010-11-26 12:54:37.042080086 +0800
@@ -0,0 +1,168 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+
+/* some parameters for the board */
+
+/*
+ *
+ * Taken from linux/arch/arm/boot/compressed/head-s3c2410.S
+ *
+ * Copyright (C) 2002 Samsung Electronics SW.LEE  <hitchcar@sec.samsung.com>
+ *
+ */
+
+#define BWSCON	0x48000000
+
+/* BWSCON */
+#define DW8		 	(0x0)
+#define DW16		 	(0x1)
+#define DW32		 	(0x2)
+#define WAIT		 	(0x1<<2)
+#define UBLB		 	(0x1<<3)
+
+#define B1_BWSCON	  	(DW16)
+#define B2_BWSCON	  	(DW16)
+//#define B3_BWSCON	  	(DW16 + WAIT + UBLB)
+#define B3_BWSCON	  	(DW16 + UBLB)
+#define B4_BWSCON	  	(DW16 + WAIT + UBLB)
+#define B5_BWSCON	  	(DW8)
+#define B6_BWSCON	  	(DW32)
+#define B7_BWSCON	  	(DW32)
+
+/* BANK0CON */
+#define B0_Tacs		 	0x0	/*  0clk */
+#define B0_Tcos		 	0x0	/*  0clk */
+#define B0_Tacc		 	0x7	/* 14clk */
+#define B0_Tcoh		 	0x0	/*  0clk */
+#define B0_Tah		 	0x0	/*  0clk */
+#define B0_Tacp		 	0x0
+#define B0_PMC		 	0x0	/* normal */
+
+/* BANK1CON */
+#define B1_Tacs		 	0x0	/*  0clk */
+#define B1_Tcos		 	0x0	/*  0clk */
+#define B1_Tacc		 	0x7	/* 14clk */
+#define B1_Tcoh		 	0x0	/*  0clk */
+#define B1_Tah		 	0x0	/*  0clk */
+#define B1_Tacp		 	0x0
+#define B1_PMC		 	0x0
+
+#define B2_Tacs		 	0x0
+#define B2_Tcos		 	0x0
+#define B2_Tacc		 	0x7
+#define B2_Tcoh		 	0x0
+#define B2_Tah		 	0x0
+#define B2_Tacp		 	0x0
+#define B2_PMC		 	0x0
+
+#define B3_Tacs		 	0x0	/*  0clk */
+#define B3_Tcos		 	0x3	/*  4clk */
+#define B3_Tacc		 	0x7	/* 14clk */
+#define B3_Tcoh		 	0x1	/*  1clk */
+#define B3_Tah		 	0x0	/*  0clk */
+#define B3_Tacp		 	0x3     /*  6clk */
+#define B3_PMC		 	0x0	/* normal */
+
+#define B4_Tacs		 	0x0	/*  0clk */
+#define B4_Tcos		 	0x3	/*  4clk */
+#define B4_Tacc		 	0x7	/* 14clk */
+#define B4_Tcoh		 	0x1	/*  1clk */
+#define B4_Tah		 	0x3	/*  4clk */
+#define B4_Tacp		 	0x6 /*  6clk */
+#define B4_PMC		 	0x0	/* normal */
+
+#define B5_Tacs		 	0x0	/*  0clk */
+#define B5_Tcos		 	0x0	/*  0clk */
+#define B5_Tacc		 	0x7	/* 14clk */
+#define B5_Tcoh		 	0x0	/*  0clk */
+#define B5_Tah		 	0x0	/*  0clk */
+#define B5_Tacp		 	0x0
+#define B5_PMC		 	0x0	/* normal */
+
+#define B6_MT		 	0x3	/* SDRAM */
+#define B6_Trcd	 	 	0x1
+#define B6_SCAN		 	0x1	/* 9bit */
+
+#define B7_MT		 	0x3	/* SDRAM */
+#define B7_Trcd		 	0x1	/* 3clk */
+#define B7_SCAN		 	0x1	/* 9bit */
+
+/* REFRESH parameter */
+#define REFEN		 	0x1	/* Refresh enable */
+#define TREFMD		 	0x0	/* CBR(CAS before RAS)/Auto refresh */
+#define Trp		 	    0x0	/* 2clk */
+#define Trc		    	0x3	/* 7clk */
+#define Tchr		 	0x2	/* 3clk */
+#define REFCNT		 	0x4f4	/* period=7.8125us, HCLK=100Mhz, (2048+1-7.8125*100) */
+/**************************************/
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+.globl lowlevel_init
+lowlevel_init:
+	/* memory control configuration */
+	/* make r0 relative the current location so that it */
+	/* reads SMRDATA out of FLASH rather than memory ! */
+	ldr     r0, =SMRDATA
+	ldr	r1, _TEXT_BASE
+	sub	r0, r0, r1
+	ldr	r1, =BWSCON	/* Bus Width Status Controller */
+	add     r2, r0, #13*4
+0:
+	ldr     r3, [r0], #4
+	str     r3, [r1], #4
+	cmp     r2, r0
+	bne     0b
+
+	/* everything is fine now */
+	mov	pc, lr
+
+	.ltorg
+/* the literal pools origin */
+
+SMRDATA:
+    .word (0+(B1_BWSCON<<4)+(B2_BWSCON<<8)+(B3_BWSCON<<12)+(B4_BWSCON<<16)+(B5_BWSCON<<20)+(B6_BWSCON<<24)+(B7_BWSCON<<28)) 
+    .word ((B0_Tacs<<13)+(B0_Tcos<<11)+(B0_Tacc<<8)+(B0_Tcoh<<6)+(B0_Tah<<4)+(B0_Tacp<<2)+(B0_PMC))
+    .word ((B1_Tacs<<13)+(B1_Tcos<<11)+(B1_Tacc<<8)+(B1_Tcoh<<6)+(B1_Tah<<4)+(B1_Tacp<<2)+(B1_PMC))
+    .word ((B2_Tacs<<13)+(B2_Tcos<<11)+(B2_Tacc<<8)+(B2_Tcoh<<6)+(B2_Tah<<4)+(B2_Tacp<<2)+(B2_PMC))
+    .word ((B3_Tacs<<13)+(B3_Tcos<<11)+(B3_Tacc<<8)+(B3_Tcoh<<6)+(B3_Tah<<4)+(B3_Tacp<<2)+(B3_PMC))
+    .word ((B4_Tacs<<13)+(B4_Tcos<<11)+(B4_Tacc<<8)+(B4_Tcoh<<6)+(B4_Tah<<4)+(B4_Tacp<<2)+(B4_PMC))
+    .word ((B5_Tacs<<13)+(B5_Tcos<<11)+(B5_Tacc<<8)+(B5_Tcoh<<6)+(B5_Tah<<4)+(B5_Tacp<<2)+(B5_PMC))
+    .word ((B6_MT<<15)+(B6_Trcd<<2)+(B6_SCAN))
+    .word ((B7_MT<<15)+(B7_Trcd<<2)+(B7_SCAN))
+    .word ((REFEN<<23)+(TREFMD<<22)+(Trp<<20)+(Trc<<18)+(Tchr<<16)+REFCNT)
+    .word 0xb1
+    .word 0x30
+    .word 0x30
diff -urN u-boot-1.1.6_jz2440/board/100ask24x0/Makefile u-boot-1.1.6_nand_ok/board/100ask24x0/Makefile
--- u-boot-1.1.6_jz2440/board/100ask24x0/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_nand_ok/board/100ask24x0/Makefile	2010-11-26 12:54:37.030096240 +0800
@@ -0,0 +1,51 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= 100ask24x0.o boot_init.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN u-boot-1.1.6_jz2440/board/100ask24x0/u-boot.lds u-boot-1.1.6_nand_ok/board/100ask24x0/u-boot.lds
--- u-boot-1.1.6_jz2440/board/100ask24x0/u-boot.lds	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_nand_ok/board/100ask24x0/u-boot.lds	2010-11-26 12:54:37.042080086 +0800
@@ -0,0 +1,58 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/arm920t/start.o	(.text)
+          board/100ask24x0/boot_init.o (.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -urN u-boot-1.1.6_jz2440/cpu/arm920t/s3c24x0/Makefile u-boot-1.1.6_nand_ok/cpu/arm920t/s3c24x0/Makefile
--- u-boot-1.1.6_jz2440/cpu/arm920t/s3c24x0/Makefile	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_nand_ok/cpu/arm920t/s3c24x0/Makefile	2010-11-26 12:54:37.726297356 +0800
@@ -26,7 +26,7 @@
 LIB	= $(obj)lib$(SOC).a
 
 COBJS	= i2c.o interrupts.o serial.o speed.o \
-	  usb_ohci.o
+	  usb_ohci.o nand_flash.o
 
 SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
diff -urN u-boot-1.1.6_jz2440/cpu/arm920t/s3c24x0/nand_flash.c u-boot-1.1.6_nand_ok/cpu/arm920t/s3c24x0/nand_flash.c
--- u-boot-1.1.6_jz2440/cpu/arm920t/s3c24x0/nand_flash.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_nand_ok/cpu/arm920t/s3c24x0/nand_flash.c	2010-11-26 12:54:37.726297356 +0800
@@ -0,0 +1,186 @@
+/*
+ * Nand flash interface of s3c2410/s3c2440, by www.100ask.net
+ * Changed from drivers/mtd/nand/s3c2410.c of kernel 2.6.13
+ */
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND) && !defined(CFG_NAND_LEGACY)
+#include <s3c2410.h>
+#include <nand.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define S3C2410_NFSTAT_READY    (1<<0)
+#define S3C2410_NFCONF_nFCE     (1<<11)
+
+#define S3C2440_NFSTAT_READY    (1<<0)
+#define S3C2440_NFCONT_nFCE     (1<<1)
+
+
+/* select chip, for s3c2410 */
+static void s3c2410_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+
+    if (chip == -1) {
+        s3c2410nand->NFCONF |= S3C2410_NFCONF_nFCE;
+    } else {
+        s3c2410nand->NFCONF &= ~S3C2410_NFCONF_nFCE;
+    }
+}
+
+/* command and control functions, for s3c2410 
+ *
+ * Note, these all use tglx's method of changing the IO_ADDR_W field
+ * to make the code simpler, and use the nand layer's code to issue the
+ * command and address sequences via the proper IO ports.
+ *
+*/
+static void s3c2410_nand_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+    struct nand_chip *chip = mtd->priv;
+
+    switch (cmd) {
+    case NAND_CTL_SETNCE:
+    case NAND_CTL_CLRNCE:
+        printf("%s: called for NCE\n", __FUNCTION__);
+        break;
+
+    case NAND_CTL_SETCLE:
+        chip->IO_ADDR_W = (void *)&s3c2410nand->NFCMD;
+        break;
+
+    case NAND_CTL_SETALE:
+        chip->IO_ADDR_W = (void *)&s3c2410nand->NFADDR;
+        break;
+
+        /* NAND_CTL_CLRCLE: */
+        /* NAND_CTL_CLRALE: */
+    default:
+        chip->IO_ADDR_W = (void *)&s3c2410nand->NFDATA;
+        break;
+    }
+}
+
+/* s3c2410_nand_devready()
+ *
+ * returns 0 if the nand is busy, 1 if it is ready
+ */
+static int s3c2410_nand_devready(struct mtd_info *mtd)
+{
+    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+
+    return (s3c2410nand->NFSTAT & S3C2410_NFSTAT_READY);
+}
+
+
+/* select chip, for s3c2440 */
+static void s3c2440_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (chip == -1) {
+        s3c2440nand->NFCONT |= S3C2440_NFCONT_nFCE;
+    } else {
+        s3c2440nand->NFCONT &= ~S3C2440_NFCONT_nFCE;
+    }
+}
+
+/* command and control functions */
+static void s3c2440_nand_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+    struct nand_chip *chip = mtd->priv;
+
+    switch (cmd) {
+    case NAND_CTL_SETNCE:
+    case NAND_CTL_CLRNCE:
+        printf("%s: called for NCE\n", __FUNCTION__);
+        break;
+
+    case NAND_CTL_SETCLE:
+        chip->IO_ADDR_W = (void *)&s3c2440nand->NFCMD;
+        break;
+
+    case NAND_CTL_SETALE:
+        chip->IO_ADDR_W = (void *)&s3c2440nand->NFADDR;
+        break;
+
+        /* NAND_CTL_CLRCLE: */
+        /* NAND_CTL_CLRALE: */
+    default:
+        chip->IO_ADDR_W = (void *)&s3c2440nand->NFDATA;
+        break;
+    }
+}
+
+/* s3c2440_nand_devready()
+ *
+ * returns 0 if the nand is busy, 1 if it is ready
+ */
+static int s3c2440_nand_devready(struct mtd_info *mtd)
+{
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    return (s3c2440nand->NFSTAT & S3C2440_NFSTAT_READY);
+}
+
+/*
+ * Nand flash hardware initialization:
+ * Set the timing, enable NAND flash controller
+ */
+static void s3c24x0_nand_inithw(void)
+{
+    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+#define TACLS   0
+#define TWRPH0  4
+#define TWRPH1  2
+
+    if (isS3C2410)
+    {
+        /* Enable NAND flash controller, Initialize ECC, enable chip select, Set flash memory timing */
+        s3c2410nand->NFCONF = (1<<15)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0);
+    }
+    else
+    {
+        /* Set flash memory timing */
+        s3c2440nand->NFCONF = (TACLS<<12)|(TWRPH0<<8)|(TWRPH1<<4);
+        /* Initialize ECC, enable chip select, NAND flash controller enable */
+        s3c2440nand->NFCONT = (1<<4)|(0<<1)|(1<<0);
+    }
+}
+
+/*
+ * Called by drivers/nand/nand.c, initialize the interface of nand flash
+ */
+void board_nand_init(struct nand_chip *chip)
+{
+    S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    s3c24x0_nand_inithw();
+
+    if (isS3C2410) {
+        chip->IO_ADDR_R    = (void *)&s3c2410nand->NFDATA;
+        chip->IO_ADDR_W    = (void *)&s3c2410nand->NFDATA;
+        chip->hwcontrol    = s3c2410_nand_hwcontrol;
+        chip->dev_ready    = s3c2410_nand_devready;
+        chip->select_chip  = s3c2410_nand_select_chip;
+        chip->options      = 0;
+    } else {
+        chip->IO_ADDR_R    = (void *)&s3c2440nand->NFDATA;
+        chip->IO_ADDR_W    = (void *)&s3c2440nand->NFDATA;
+        chip->hwcontrol    = s3c2440_nand_hwcontrol;
+        chip->dev_ready    = s3c2440_nand_devready;
+        chip->select_chip  = s3c2440_nand_select_chip;
+        chip->options      = 0;
+    }
+
+    chip->eccmode       = NAND_ECC_SOFT;
+}
+
+#endif
diff -urN u-boot-1.1.6_jz2440/cpu/arm920t/s3c24x0/nand_flash_legacy.c u-boot-1.1.6_nand_ok/cpu/arm920t/s3c24x0/nand_flash_legacy.c
--- u-boot-1.1.6_jz2440/cpu/arm920t/s3c24x0/nand_flash_legacy.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_nand_ok/cpu/arm920t/s3c24x0/nand_flash_legacy.c	2010-11-26 12:54:37.726297356 +0800
@@ -0,0 +1,222 @@
+/* add by www.100ask.net */
+/*-----------------------------------------------------------------------
+ * NAND flash settings
+ */
+#include <common.h>
+#include <s3c2410.h>
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* only has two value: NFCE_LOW, NFCE_HIGH */
+#define NFCE_STATE  int 
+
+void NF_Conf(u16 conf)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	s3c2410nand->NFCONF = conf;
+    else
+        s3c2440nand->NFCONF = conf;
+}
+
+/* only for s3c2440 */
+void NF_Cont(u16 cont)
+{
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number != MACH_TYPE_SMDK2410)
+        s3c2440nand->NFCONT = cont;
+}
+
+void NF_Cmd(u8 cmd)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	s3c2410nand->NFCMD = cmd;
+    else
+    	s3c2440nand->NFCMD = cmd;
+}
+
+void NF_CmdW(u8 cmd)
+{
+	NF_Cmd(cmd);
+    udelay(1);
+}
+
+void NF_Addr(u8 addr)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	s3c2410nand->NFADDR = addr;
+    else
+    	s3c2440nand->NFADDR = addr;
+    udelay(15);
+}
+
+void NF_SetCE(NFCE_STATE s)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+	switch (s) {
+		case NFCE_LOW:
+            if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+		    	s3c2410nand->NFCONF &= ~(1<<11);
+            else
+		    	s3c2440nand->NFCONT &= ~(1<<1);                
+			break;
+
+		case NFCE_HIGH:
+            if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    			s3c2410nand->NFCONF |= (1<<11);
+            else
+		    	s3c2440nand->NFCONT |= (1<<1);
+			break;
+	}
+}
+
+/* only for s3c2440 */
+void NF_ClrRB(void)
+{
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number != MACH_TYPE_SMDK2410)
+    {
+        s3c2440nand->NFSTAT |= (1<<2);
+    }
+}
+
+void NF_WaitRB(void)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    {
+    	while (!(s3c2410nand->NFSTAT & (1<<0)));
+    }
+    else
+    {
+    	while (!(s3c2440nand->NFSTAT & (1<<0)));
+        s3c2440nand->NFSTAT |= (1<<2);
+    }
+}
+
+void NF_Write(u8 data)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+    volatile unsigned char *puc = (volatile unsigned char *)&s3c2440nand->NFDATA;
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	s3c2410nand->NFDATA = data;
+    else
+    	*puc = data;    /* s3c2440's NFDATA must be accessed by 'u8*', www.100ask.net */
+    
+}
+
+u8 NF_Read(void)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+    volatile unsigned char *puc = (volatile unsigned char *)&s3c2440nand->NFDATA;
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	return(s3c2410nand->NFDATA);
+    else
+    	return(*puc);   /* s3c2440's NFDATA must be accessed by 'u8*', www.100ask.net */
+}
+
+void NF_Init_ECC(void)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	s3c2410nand->NFCONF |= (1<<12);
+    else
+    {
+        s3c2440nand->NFCONT |= (1<<4);   // Reset ECC
+        s3c2440nand->NFCONT &= ~(1<<5);  // UnLock MECC
+    }
+}
+
+u32 NF_Read_ECC(void)
+{
+	S3C2410_NAND * const s3c2410nand = S3C2410_GetBase_NAND();
+	S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    	return(s3c2410nand->NFECC);
+    else
+    {
+        s3c2440nand->NFCONT |= (1<<5);  // Lock MECC
+        return(s3c2440nand->NFMECC0);   // Read MECC
+    }
+}
+
+extern ulong
+nand_probe(ulong physadr);
+
+
+static inline void NF_Reset(void)
+{
+    int i;
+
+    NF_Cont((1<<4)|(0<<1)|(1<<0));  /* only for s3c2440, Initialize ECC, enable chip select, NAND flash controller enable */
+    NF_SetCE(NFCE_LOW); /* enable chip select */
+    NF_ClrRB();         /* only for s3c2440 */
+    NF_Cmd(0xFF);		/* reset command */
+    for(i = 0; i < 10; i++);	/* tWB = 100ns. */
+    NF_WaitRB();		/* wait 200~500us; */
+    NF_SetCE(NFCE_HIGH);
+}
+
+static inline void NF_Init(void)
+{
+#if 0 /* a little bit too optimistic */
+#define TACLS   0
+#define TWRPH0  3
+#define TWRPH1  0
+#else
+#define TACLS   0
+#define TWRPH0  4
+#define TWRPH1  2
+#endif
+
+    /* Set flash memory timing */
+    if (gd->bd->bi_arch_number == MACH_TYPE_SMDK2410)
+    {
+        NF_Conf((1<<15)|(0<<14)|(0<<13)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0));
+        /*nand->NFCONF = (1<<15)|(1<<14)|(1<<13)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0); */
+        /* 1  1    1     1,   1      xxx,  r xxx,   r xxx */
+        /* En 512B 4step ECCR nFCE=H tACLS   tWRPH0   tWRPH1 */
+    }
+    else
+    {
+        NF_Conf((3<<12)|(7<<8)|(7<<4));
+    }
+
+    NF_Reset();
+}
+
+void
+nand_init(void)
+{
+	S3C2410_NAND * const nand = S3C2410_GetBase_NAND();
+
+	NF_Init();
+#ifdef DEBUG
+	printf("NAND flash probing at 0x%.8lX\n", (ulong)nand);
+#endif
+	printf ("%4lu MB\n", nand_probe((ulong)nand) >> 20);
+}
+#endif	/* CONFIG_COMMANDS & CFG_CMD_NAND */
+
diff -urN u-boot-1.1.6_jz2440/cpu/arm920t/s3c24x0/speed.c u-boot-1.1.6_nand_ok/cpu/arm920t/s3c24x0/speed.c
--- u-boot-1.1.6_jz2440/cpu/arm920t/s3c24x0/speed.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_nand_ok/cpu/arm920t/s3c24x0/speed.c	2010-11-26 12:54:37.730289845 +0800
@@ -38,6 +38,8 @@
 #include <s3c2410.h>
 #endif
 
+DECLARE_GLOBAL_DATA_PTR;
+
 #define MPLL 0
 #define UPLL 1
 
@@ -57,17 +59,21 @@
     ulong r, m, p, s;
 
     if (pllreg == MPLL)
-	r = clk_power->MPLLCON;
+    r = clk_power->MPLLCON;
     else if (pllreg == UPLL)
-	r = clk_power->UPLLCON;
+    r = clk_power->UPLLCON;
     else
-	hang();
+    hang();
 
     m = ((r & 0xFF000) >> 12) + 8;
     p = ((r & 0x003F0) >> 4) + 2;
     s = r & 0x3;
 
-    return((CONFIG_SYS_CLK_FREQ * m) / (p << s));
+    /* support both of S3C2410 and S3C2440, by www.100ask.net */
+    if (isS3C2410)
+        return((CONFIG_SYS_CLK_FREQ * m) / (p << s));
+    else
+        return((CONFIG_SYS_CLK_FREQ * m * 2) / (p << s));   /* S3C2440 */
 }
 
 /* return FCLK frequency */
@@ -76,20 +82,99 @@
     return(get_PLLCLK(MPLL));
 }
 
+/* for s3c2440 */
+#define S3C2440_CLKDIVN_PDIVN        (1<<0)
+#define S3C2440_CLKDIVN_HDIVN_MASK   (3<<1)
+#define S3C2440_CLKDIVN_HDIVN_1      (0<<1)
+#define S3C2440_CLKDIVN_HDIVN_2      (1<<1)
+#define S3C2440_CLKDIVN_HDIVN_4_8    (2<<1)
+#define S3C2440_CLKDIVN_HDIVN_3_6    (3<<1)
+#define S3C2440_CLKDIVN_UCLK         (1<<3)
+
+#define S3C2440_CAMDIVN_CAMCLK_MASK  (0xf<<0)
+#define S3C2440_CAMDIVN_CAMCLK_SEL   (1<<4)
+#define S3C2440_CAMDIVN_HCLK3_HALF   (1<<8)
+#define S3C2440_CAMDIVN_HCLK4_HALF   (1<<9)
+#define S3C2440_CAMDIVN_DVSEN        (1<<12)
+
 /* return HCLK frequency */
 ulong get_HCLK(void)
 {
     S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+    unsigned long clkdiv;
+    unsigned long camdiv;
+    int hdiv = 1;
+
+    /* support both of S3C2410 and S3C2440, by www.100ask.net */
+    if (isS3C2410)
+        return((clk_power->CLKDIVN & 0x2) ? get_FCLK()/2 : get_FCLK());
+    else
+    {
+        clkdiv = clk_power->CLKDIVN;
+        camdiv = clk_power->CAMDIVN;
+
+        /* work out clock scalings */
+
+        switch (clkdiv & S3C2440_CLKDIVN_HDIVN_MASK) {
+        case S3C2440_CLKDIVN_HDIVN_1:
+            hdiv = 1;
+            break;
+
+        case S3C2440_CLKDIVN_HDIVN_2:
+            hdiv = 2;
+            break;
+
+        case S3C2440_CLKDIVN_HDIVN_4_8:
+            hdiv = (camdiv & S3C2440_CAMDIVN_HCLK4_HALF) ? 8 : 4;
+            break;
+
+        case S3C2440_CLKDIVN_HDIVN_3_6:
+            hdiv = (camdiv & S3C2440_CAMDIVN_HCLK3_HALF) ? 6 : 3;
+            break;
+        }
 
-    return((clk_power->CLKDIVN & 0x2) ? get_FCLK()/2 : get_FCLK());
+        return get_FCLK() / hdiv;
+    }
 }
 
 /* return PCLK frequency */
 ulong get_PCLK(void)
 {
     S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+    unsigned long clkdiv;
+    unsigned long camdiv;
+    int hdiv = 1;
+
+    /* support both of S3C2410 and S3C2440, by www.100ask.net */
+    if (isS3C2410)
+        return((clk_power->CLKDIVN & 0x1) ? get_HCLK()/2 : get_HCLK());
+    else
+    {   
+        clkdiv = clk_power->CLKDIVN;
+        camdiv = clk_power->CAMDIVN;
+
+        /* work out clock scalings */
+
+        switch (clkdiv & S3C2440_CLKDIVN_HDIVN_MASK) {
+        case S3C2440_CLKDIVN_HDIVN_1:
+            hdiv = 1;
+            break;
+
+        case S3C2440_CLKDIVN_HDIVN_2:
+            hdiv = 2;
+            break;
+
+        case S3C2440_CLKDIVN_HDIVN_4_8:
+            hdiv = (camdiv & S3C2440_CAMDIVN_HCLK4_HALF) ? 8 : 4;
+            break;
+
+        case S3C2440_CLKDIVN_HDIVN_3_6:
+            hdiv = (camdiv & S3C2440_CAMDIVN_HCLK3_HALF) ? 6 : 3;
+            break;
+        }
 
-    return((clk_power->CLKDIVN & 0x1) ? get_HCLK()/2 : get_HCLK());
+        return get_FCLK() / hdiv / ((clkdiv & S3C2440_CLKDIVN_PDIVN)? 2:1);
+    }        
 }
 
 /* return UCLK frequency */
diff -urN u-boot-1.1.6_jz2440/cpu/arm920t/start.S u-boot-1.1.6_nand_ok/cpu/arm920t/start.S
--- u-boot-1.1.6_jz2440/cpu/arm920t/start.S	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_nand_ok/cpu/arm920t/start.S	2010-11-26 12:54:37.718042180 +0800
@@ -90,6 +90,18 @@
 _bss_end:
 	.word _end
 
+.globl FREE_RAM_END
+FREE_RAM_END:
+	.word	0x0badc0de
+
+.globl FREE_RAM_SIZE
+FREE_RAM_SIZE:
+	.word	0x0badc0de
+
+.globl PreLoadedONRAM
+PreLoadedONRAM:
+	.word	0
+
 #ifdef CONFIG_USE_IRQ
 /* IRQ stack memory (calculated at run-time) */
 .globl IRQ_STACK_START
@@ -123,6 +135,7 @@
 # define CLKDIVN	0x14800014	/* clock divisor register */
 #elif defined(CONFIG_S3C2410)
 # define pWTCON		0x53000000
+# define INTMOD     0X4A000004
 # define INTMSK		0x4A000008	/* Interupt-Controller base addresses */
 # define INTSUBMSK	0x4A00001C
 # define CLKDIVN	0x4C000014	/* clock divisor register */
@@ -145,11 +158,13 @@
 	str	r1, [r0]
 # endif
 
+#if 0
 	/* FCLK:HCLK:PCLK = 1:2:4 */
 	/* default FCLK is 120 MHz ! */
 	ldr	r0, =CLKDIVN
 	mov	r1, #3
 	str	r1, [r0]
+#endif
 #endif	/* CONFIG_S3C2400 || CONFIG_S3C2410 */
 
 	/*
@@ -157,19 +172,40 @@
 	 * not when booting from ram!
 	 */
 #ifndef CONFIG_SKIP_LOWLEVEL_INIT
-	bl	cpu_init_crit
+	adr	r0, _start		/* r0 <- current position of code   */
+	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
+	cmp     r0, r1                  /* don't reloc during debug         */
+	blne	cpu_init_crit
+#endif
+
+	/* Set up the stack						    */
+stack_setup:
+	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
+	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
+	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
+
+#ifdef CONFIG_USE_IRQ
+	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
 #endif
+	sub	sp, r0, #12		/* leave 3 words for abort-stack    */
+
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+    bl clock_init
+#endif    
 
 #ifndef CONFIG_SKIP_RELOCATE_UBOOT
 relocate:				/* relocate U-Boot to RAM	    */
 	adr	r0, _start		/* r0 <- current position of code   */
 	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
 	cmp     r0, r1                  /* don't reloc during debug         */
-	beq     stack_setup
-
+	beq     clear_bss
+	
 	ldr	r2, _armboot_start
 	ldr	r3, _bss_start
 	sub	r2, r3, r2		/* r2 <- size of armboot            */
+#if 1
+	bl  CopyCode2Ram	/* r0: source, r1: dest, r2: size */
+#else
 	add	r2, r0, r2		/* r2 <- source end address         */
 
 copy_loop:
@@ -177,17 +213,8 @@
 	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
 	cmp	r0, r2			/* until source end addreee [r2]    */
 	ble	copy_loop
-#endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
-
-	/* Set up the stack						    */
-stack_setup:
-	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
-	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
-	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
-#ifdef CONFIG_USE_IRQ
-	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
 #endif
-	sub	sp, r0, #12		/* leave 3 words for abort-stack    */
+#endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
 
 clear_bss:
 	ldr	r0, _bss_start		/* find start of bss segment        */
@@ -199,6 +226,15 @@
 	cmp	r0, r1
 	ble	clbss_l
 
+SetLoadFlag:
+	/* Set a global flag, PreLoadedONRAM */
+	adr	r0, _start		/* r0 <- current position of code   */
+	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
+	cmp     r0, r1                  /* don't reloc during debug         */
+	ldr r2, =PreLoadedONRAM
+	mov r3, #1
+	streq r3, [r2]
+
 #if 0
 	/* try doing this stuff after the relocation */
 	ldr     r0, =pWTCON
@@ -400,14 +436,88 @@
 	bad_save_user_regs
 	bl 	do_not_used
 
+@ thisway.diy, 2006.06.24
+.globl Launch
+    .align	4
+Launch:    
+    mov r7, r0
+    @ diable interrupt
+	@ disable watch dog timer
+	mov	r1, #0x53000000
+	mov	r2, #0x0
+	str	r2, [r1]
+
+    ldr r1,=INTMSK
+    ldr r2,=0xffffffff  @ all interrupt disable
+    str r2,[r1]
+
+    ldr r1,=INTSUBMSK
+    ldr r2,=0x7ff       @ all sub interrupt disable
+    str r2,[r1]
+
+    ldr     r1, = INTMOD
+    mov r2, #0x0        @ set all interrupt as IRQ (not FIQ)
+    str     r2, [r1]
+
+    @ 
+	mov	ip, #0
+	mcr	p15, 0, ip, c13, c0, 0      @	/* zero PID */
+	mcr	p15, 0, ip, c7, c7, 0       @	/* invalidate I,D caches */
+	mcr	p15, 0, ip, c7, c10, 4      @	/* drain write buffer */
+	mcr	p15, 0, ip, c8, c7, 0       @	/* invalidate I,D TLBs */
+	mrc	p15, 0, ip, c1, c0, 0       @	/* get control register */
+	bic	ip, ip, #0x0001             @	/* disable MMU */
+	mcr	p15, 0, ip, c1, c0, 0       @	/* write control register */
+
+    @ MMU_EnableICache
+    @mrc p15,0,r1,c1,c0,0
+    @orr r1,r1,#(1<<12)
+    @mcr p15,0,r1,c1,c0,0
+
+    @ clear SDRAM: the end of free mem(has wince on it now) to the end of SDRAM
+    ldr     r3, FREE_RAM_END
+    ldr     r4, =PHYS_SDRAM_1+PHYS_SDRAM_1_SIZE    @ must clear all the memory unused to zero
+    mov     r5, #0
+
+    ldr     r1, _armboot_start
+    ldr     r2, =On_Steppingstone
+    sub     r2, r2, r1
+    mov     pc, r2
+On_Steppingstone:
+2:  stmia   r3!, {r5}
+    cmp     r3, r4
+    bne     2b
+
+    @ set sp = 0 on sys mode
+    mov sp, #0
+
+    @ add by thisway.diy 2006.06.26, switch to SVC mode
+	msr	cpsr_c,	#0xdf	@ set the I-bit = 1, diable the IRQ interrupt
+	msr	cpsr_c,	#0xd3	@ set the I-bit = 1, diable the IRQ interrupt
+    ldr sp, =0x31ff5800	
+    
+    nop
+	nop
+    nop
+	nop
+
+	mov     pc, r7  @ Jump to PhysicalAddress
+	nop
+    mov pc, lr
+
 #ifdef CONFIG_USE_IRQ
 
 	.align	5
 irq:
-	get_irq_stack
-	irq_save_user_regs
-	bl 	do_irq
-	irq_restore_user_regs
+///* add by www.100ask.net to use IRQ for USB and DMA */
+//	sub	lr, lr, #4			        @ the return address
+//	ldr	sp, IRQ_STACK_START	        @ the stack for irq
+//	stmdb	sp!, 	{ r0-r12,lr }	@ save registers
+//	
+//	ldr	lr,	=int_return		        @ set the return addr
+//	ldr	pc, =IRQ_Handle		        @ call the isr
+//int_return:
+//	ldmia	sp!, 	{ r0-r12,pc }^	@ return from interrupt
 
 	.align	5
 fiq:
diff -urN u-boot-1.1.6_jz2440/include/configs/100ask24x0.h u-boot-1.1.6_nand_ok/include/configs/100ask24x0.h
--- u-boot-1.1.6_jz2440/include/configs/100ask24x0.h	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_nand_ok/include/configs/100ask24x0.h	2010-11-26 12:54:37.958266315 +0800
@@ -0,0 +1,237 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ * Gary Jennejohn <gj@denx.de>
+ * David Mueller <d.mueller@elsoft.ch>
+ *
+ * Configuation settings for the SAMSUNG SMDK2410 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM920T		1	/* This is an ARM920T Core	*/
+#define	CONFIG_S3C2410		1	/* in a SAMSUNG S3C2410 SoC     */
+#define CONFIG_SMDK2410		1	/* on a SAMSUNG SMDK2410 Board  */
+
+/* input clock of PLL */
+#define CONFIG_SYS_CLK_FREQ	12000000 /* the SMDK2410 has 12MHz input clock */
+//#define CONFIG_SYS_CLK_FREQ	16934400 /* the SMDK2410 has 12MHz input clock */
+
+
+#define USE_920T_MMU		1
+
+#define CONFIG_USB_DEVICE   1
+
+#ifdef CONFIG_USB_DEVICE
+#define CONFIG_USE_IRQ		1
+#endif
+
+#define CONFIG_JFFS2_CMDLINE 1
+#define CONFIG_JFFS2_NAND    1
+
+#define MTDIDS_DEFAULT "nand0=nandflash0"
+#define MTDPARTS_DEFAULT "mtdparts=nandflash0:256k@0(bootloader)," \
+                            "128k(params)," \
+                            "2m(kernel)," \
+                            "-(root)"
+
+/*
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN		(CFG_ENV_SIZE + 128*1024)
+#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Hardware drivers
+ */
+#if 1
+#if 0
+#define CONFIG_DRIVER_CS8900	1	/* we have a CS8900 on-board */
+#define CS8900_BASE		0x19000300
+#define CS8900_BUS16		1 /* the Linux driver does accesses as shorts */
+#endif
+
+#if !defined(CONFIG_DRIVER_CS8900)
+#define CONFIG_DRIVER_DM9000		1
+#define CONFIG_DM9000_USE_16BIT 	1
+#define CONFIG_DM9000_BASE			0x20000000
+#define DM9000_IO					0x20000000  
+#define DM9000_DATA					0x20000004
+#endif
+#endif
+/*
+ * select serial console configuration
+ */
+#define CONFIG_SERIAL1          1	/* we use SERIAL 1 on SMDK2410 */
+
+/************************************************************
+ * RTC
+ ************************************************************/
+#define	CONFIG_RTC_S3C24X0	1
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE		115200
+
+/* for tag(s) to transfer message to kernel, www.100ask.net */
+#define CONFIG_SETUP_MEMORY_TAGS    1
+#define CONFIG_CMDLINE_TAG          1
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+#define CONFIG_COMMANDS \
+                        ((CONFIG_CMD_DFL | \
+                        CFG_CMD_CACHE    | \
+                    /* Start: by www.100ask.net */ \
+                        CFG_CMD_PING     | \
+                        CFG_CMD_JFFS2    | \
+                        CFG_CMD_NAND     | \
+                    /* End: by www.100ask.net */ \
+                        /*CFG_CMD_EEPROM |*/ \
+                        /*CFG_CMD_I2C    |*/ \
+                        /*CFG_CMD_USB    |*/ \
+                        CFG_CMD_REGINFO  | \
+                        CFG_CMD_DATE     | \
+                        CFG_CMD_ELF))
+
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	2
+#define CONFIG_BOOTARGS    	"noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0"
+#define CONFIG_ETHADDR	    08:00:3e:26:0a:5b
+#define CONFIG_NETMASK      255.255.255.0
+#define CONFIG_IPADDR		192.168.1.199
+#define CONFIG_SERVERIP		192.168.1.107
+/*#define CONFIG_BOOTFILE	"elinos-lart" */
+#define CONFIG_BOOTCOMMAND	"nand read.jffs2 0x30007FC0 kernel; bootm 0x30007FC0"
+
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200		/* speed to run kgdb serial port */
+/* what's this ? it's not used anywhere */
+#define CONFIG_KGDB_SER_INDEX	1		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory		*/
+#define	CFG_PROMPT		"OpenJTAG> "	/* Monitor Command Prompt	*/
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_BARGSIZE		CFG_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CFG_MEMTEST_START	0x30000000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0x33F00000	/* 63 MB in DRAM	*/
+
+#undef  CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define	CFG_LOAD_ADDR		0x33000000	/* default load address	*/
+
+/* the PWM TImer 4 uses a counter of 15625 for 10 ms, so we need */
+/* it to wrap 100 times (total 1562500) to get 1 sec. */
+#define	CFG_HZ			1562500
+
+/* valid baudrates */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   /* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x30000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x04000000 /* 64 MB */
+
+#define PHYS_FLASH_1		0x00000000 /* Flash Bank #1 */
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+#define CFG_MONITOR_BASE	PHYS_FLASH_1
+
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+#if 0
+#define CONFIG_AMD_LV400	1	/* uncomment this if you have a LV400 flash */
+#endif
+//#define CONFIG_AMD_LV800	1	/* uncomment this if you have a LV800 flash */
+
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#ifdef CONFIG_AMD_LV800
+#define PHYS_FLASH_SIZE		0x00100000 /* 1MB */
+#define CFG_MAX_FLASH_SECT	(19)	/* max number of sectors on one chip */
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + 0x0F0000) /* addr of environment */
+#endif
+#ifdef CONFIG_AMD_LV400
+#define PHYS_FLASH_SIZE		0x00080000 /* 512KB */
+#define CFG_MAX_FLASH_SECT	(11)	/* max number of sectors on one chip */
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + 0x070000) /* addr of environment */
+#endif
+
+#define CFG_FLASH_CFI				1
+#define CFG_FLASH_CFI_DRIVER 		1
+#define CFG_FLASH_USE_BUFFER_WRITE	1
+#define CONFIG_FLASH_CFI_LEGACY		1
+
+#ifdef CFG_FLASH_CFI_DRIVER
+#define CFG_MAX_FLASH_SECT	 512   /* max number of sectors on one chip */
+#define CFG_FLASH_CFI_WIDTH  0x02  /* FLASH_CFI_16BIT */
+#endif
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(5*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(5*CFG_HZ) /* Timeout for Flash Write */
+
+//#define	CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_IS_IN_NAND  1
+#define CFG_ENV_OFFSET      0x40000
+#define CFG_ENV_SIZE		0x20000	/* Total Size of Environment Sector */
+
+/*-----------------------------------------------------------------------
+ * NAND flash settings
+ */
+#define CFG_NAND_BASE           0
+#define CFG_MAX_NAND_DEVICE     1
+#define NAND_MAX_CHIPS          1
+
+#endif	/* __CONFIG_H */
diff -urN u-boot-1.1.6_jz2440/include/s3c2410.h u-boot-1.1.6_nand_ok/include/s3c2410.h
--- u-boot-1.1.6_jz2440/include/s3c2410.h	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_nand_ok/include/s3c2410.h	2010-11-26 12:54:37.994099919 +0800
@@ -22,7 +22,7 @@
  */
 
 /************************************************
- * NAME	    : s3c2410.h
+ * NAME     : s3c2410.h
  * Version  : 31.3.2003
  *
  * Based on S3C2410X User's manual Rev 1.1
@@ -31,38 +31,38 @@
 #ifndef __S3C2410_H__
 #define __S3C2410_H__
 
-#define S3C24X0_UART_CHANNELS	3
-#define S3C24X0_SPI_CHANNELS	2
+#define S3C24X0_UART_CHANNELS   3
+#define S3C24X0_SPI_CHANNELS    2
 
 /* S3C2410 only supports 512 Byte HW ECC */
-#define S3C2410_ECCSIZE		512
-#define S3C2410_ECCBYTES	3
+#define S3C2410_ECCSIZE     512
+#define S3C2410_ECCBYTES    3
 
 typedef enum {
-	S3C24X0_UART0,
-	S3C24X0_UART1,
-	S3C24X0_UART2
+    S3C24X0_UART0,
+    S3C24X0_UART1,
+    S3C24X0_UART2
 } S3C24X0_UARTS_NR;
 
 /* S3C2410 device base addresses */
-#define S3C24X0_MEMCTL_BASE		0x48000000
-#define S3C24X0_USB_HOST_BASE		0x49000000
-#define S3C24X0_INTERRUPT_BASE		0x4A000000
-#define S3C24X0_DMA_BASE		0x4B000000
-#define S3C24X0_CLOCK_POWER_BASE	0x4C000000
-#define S3C24X0_LCD_BASE		0x4D000000
-#define S3C2410_NAND_BASE		0x4E000000
-#define S3C24X0_UART_BASE		0x50000000
-#define S3C24X0_TIMER_BASE		0x51000000
-#define S3C24X0_USB_DEVICE_BASE		0x52000140
-#define S3C24X0_WATCHDOG_BASE		0x53000000
-#define S3C24X0_I2C_BASE		0x54000000
-#define S3C24X0_I2S_BASE		0x55000000
-#define S3C24X0_GPIO_BASE		0x56000000
-#define S3C24X0_RTC_BASE		0x57000000
-#define S3C2410_ADC_BASE		0x58000000
-#define S3C24X0_SPI_BASE		0x59000000
-#define S3C2410_SDI_BASE		0x5A000000
+#define S3C24X0_MEMCTL_BASE     0x48000000
+#define S3C24X0_USB_HOST_BASE       0x49000000
+#define S3C24X0_INTERRUPT_BASE      0x4A000000
+#define S3C24X0_DMA_BASE        0x4B000000
+#define S3C24X0_CLOCK_POWER_BASE    0x4C000000
+#define S3C24X0_LCD_BASE        0x4D000000
+#define S3C2410_NAND_BASE       0x4E000000
+#define S3C24X0_UART_BASE       0x50000000
+#define S3C24X0_TIMER_BASE      0x51000000
+#define S3C24X0_USB_DEVICE_BASE     0x52000140
+#define S3C24X0_WATCHDOG_BASE       0x53000000
+#define S3C24X0_I2C_BASE        0x54000000
+#define S3C24X0_I2S_BASE        0x55000000
+#define S3C24X0_GPIO_BASE       0x56000000
+#define S3C24X0_RTC_BASE        0x57000000
+#define S3C2410_ADC_BASE        0x58000000
+#define S3C24X0_SPI_BASE        0x59000000
+#define S3C2410_SDI_BASE        0x5A000000
 
 
 /* include common stuff */
@@ -71,130 +71,172 @@
 
 static inline S3C24X0_MEMCTL * const S3C24X0_GetBase_MEMCTL(void)
 {
-	return (S3C24X0_MEMCTL * const)S3C24X0_MEMCTL_BASE;
+    return (S3C24X0_MEMCTL * const)S3C24X0_MEMCTL_BASE;
 }
 static inline S3C24X0_USB_HOST * const S3C24X0_GetBase_USB_HOST(void)
 {
-	return (S3C24X0_USB_HOST * const)S3C24X0_USB_HOST_BASE;
+    return (S3C24X0_USB_HOST * const)S3C24X0_USB_HOST_BASE;
 }
 static inline S3C24X0_INTERRUPT * const S3C24X0_GetBase_INTERRUPT(void)
 {
-	return (S3C24X0_INTERRUPT * const)S3C24X0_INTERRUPT_BASE;
+    return (S3C24X0_INTERRUPT * const)S3C24X0_INTERRUPT_BASE;
 }
 static inline S3C24X0_DMAS * const S3C24X0_GetBase_DMAS(void)
 {
-	return (S3C24X0_DMAS * const)S3C24X0_DMA_BASE;
+    return (S3C24X0_DMAS * const)S3C24X0_DMA_BASE;
 }
 static inline S3C24X0_CLOCK_POWER * const S3C24X0_GetBase_CLOCK_POWER(void)
 {
-	return (S3C24X0_CLOCK_POWER * const)S3C24X0_CLOCK_POWER_BASE;
+    return (S3C24X0_CLOCK_POWER * const)S3C24X0_CLOCK_POWER_BASE;
 }
 static inline S3C24X0_LCD * const S3C24X0_GetBase_LCD(void)
 {
-	return (S3C24X0_LCD * const)S3C24X0_LCD_BASE;
+    return (S3C24X0_LCD * const)S3C24X0_LCD_BASE;
 }
 static inline S3C2410_NAND * const S3C2410_GetBase_NAND(void)
 {
-	return (S3C2410_NAND * const)S3C2410_NAND_BASE;
+    return (S3C2410_NAND * const)S3C2410_NAND_BASE;
+}
+
+/* for s3c2440, www.100ask.net */
+static inline S3C2440_NAND * const S3C2440_GetBase_NAND(void)
+{
+    return (S3C2440_NAND * const)S3C2410_NAND_BASE;
 }
 static inline S3C24X0_UART * const S3C24X0_GetBase_UART(S3C24X0_UARTS_NR nr)
 {
-	return (S3C24X0_UART * const)(S3C24X0_UART_BASE + (nr * 0x4000));
+    return (S3C24X0_UART * const)(S3C24X0_UART_BASE + (nr * 0x4000));
 }
 static inline S3C24X0_TIMERS * const S3C24X0_GetBase_TIMERS(void)
 {
-	return (S3C24X0_TIMERS * const)S3C24X0_TIMER_BASE;
+    return (S3C24X0_TIMERS * const)S3C24X0_TIMER_BASE;
 }
 static inline S3C24X0_USB_DEVICE * const S3C24X0_GetBase_USB_DEVICE(void)
 {
-	return (S3C24X0_USB_DEVICE * const)S3C24X0_USB_DEVICE_BASE;
+    return (S3C24X0_USB_DEVICE * const)S3C24X0_USB_DEVICE_BASE;
 }
 static inline S3C24X0_WATCHDOG * const S3C24X0_GetBase_WATCHDOG(void)
 {
-	return (S3C24X0_WATCHDOG * const)S3C24X0_WATCHDOG_BASE;
+    return (S3C24X0_WATCHDOG * const)S3C24X0_WATCHDOG_BASE;
 }
 static inline S3C24X0_I2C * const S3C24X0_GetBase_I2C(void)
 {
-	return (S3C24X0_I2C * const)S3C24X0_I2C_BASE;
+    return (S3C24X0_I2C * const)S3C24X0_I2C_BASE;
 }
 static inline S3C24X0_I2S * const S3C24X0_GetBase_I2S(void)
 {
-	return (S3C24X0_I2S * const)S3C24X0_I2S_BASE;
+    return (S3C24X0_I2S * const)S3C24X0_I2S_BASE;
 }
 static inline S3C24X0_GPIO * const S3C24X0_GetBase_GPIO(void)
 {
-	return (S3C24X0_GPIO * const)S3C24X0_GPIO_BASE;
+    return (S3C24X0_GPIO * const)S3C24X0_GPIO_BASE;
 }
 static inline S3C24X0_RTC * const S3C24X0_GetBase_RTC(void)
 {
-	return (S3C24X0_RTC * const)S3C24X0_RTC_BASE;
+    return (S3C24X0_RTC * const)S3C24X0_RTC_BASE;
 }
 static inline S3C2410_ADC * const S3C2410_GetBase_ADC(void)
 {
-	return (S3C2410_ADC * const)S3C2410_ADC_BASE;
+    return (S3C2410_ADC * const)S3C2410_ADC_BASE;
 }
 static inline S3C24X0_SPI * const S3C24X0_GetBase_SPI(void)
 {
-	return (S3C24X0_SPI * const)S3C24X0_SPI_BASE;
+    return (S3C24X0_SPI * const)S3C24X0_SPI_BASE;
 }
 static inline S3C2410_SDI * const S3C2410_GetBase_SDI(void)
 {
-	return (S3C2410_SDI * const)S3C2410_SDI_BASE;
+    return (S3C2410_SDI * const)S3C2410_SDI_BASE;
 }
 
+/* add by thisway.diy */             
+#define _ISR_STARTADDRESS   ((unsigned)isr_handle_array)
+
+#define ISR_EINT0_OFT     0
+#define ISR_EINT1_OFT     1
+#define ISR_EINT2_OFT     2
+#define ISR_EINT3_OFT     3
+#define ISR_EINT4_7_OFT   4
+#define ISR_EINT8_23_OFT  5
+#define ISR_NOTUSED6_OFT  6
+#define ISR_BAT_FLT_OFT   7
+#define ISR_TICK_OFT      8
+#define ISR_WDT_OFT       9
+#define ISR_TIMER0_OFT    10
+#define ISR_TIMER1_OFT    11
+#define ISR_TIMER2_OFT    12
+#define ISR_TIMER3_OFT    13
+#define ISR_TIMER4_OFT    14
+#define ISR_UART2_OFT     15
+#define ISR_LCD_OFT       16
+#define ISR_DMA0_OFT      17
+#define ISR_DMA1_OFT      18
+#define ISR_DMA2_OFT      19
+#define ISR_DMA3_OFT      20
+#define ISR_SDI_OFT       21
+#define ISR_SPI0_OFT      22
+#define ISR_UART1_OFT     23
+#define ISR_NOTUSED24_OFT 24
+#define ISR_USBD_OFT      25
+#define ISR_USBH_OFT      26
+#define ISR_IIC_OFT       27
+#define ISR_UART0_OFT     28
+#define ISR_SPI1_OFT      29
+#define ISR_RTC_OFT       30
+#define ISR_ADC_OFT       31
 
 /* ISR */
-#define pISR_RESET		(*(unsigned *)(_ISR_STARTADDRESS+0x0))
-#define pISR_UNDEF		(*(unsigned *)(_ISR_STARTADDRESS+0x4))
-#define pISR_SWI		(*(unsigned *)(_ISR_STARTADDRESS+0x8))
-#define pISR_PABORT		(*(unsigned *)(_ISR_STARTADDRESS+0xC))
-#define pISR_DABORT		(*(unsigned *)(_ISR_STARTADDRESS+0x10))
-#define pISR_RESERVED		(*(unsigned *)(_ISR_STARTADDRESS+0x14))
-#define pISR_IRQ		(*(unsigned *)(_ISR_STARTADDRESS+0x18))
-#define pISR_FIQ		(*(unsigned *)(_ISR_STARTADDRESS+0x1C))
-
-#define pISR_EINT0		(*(unsigned *)(_ISR_STARTADDRESS+0x20))
-#define pISR_EINT1		(*(unsigned *)(_ISR_STARTADDRESS+0x24))
-#define pISR_EINT2		(*(unsigned *)(_ISR_STARTADDRESS+0x28))
-#define pISR_EINT3		(*(unsigned *)(_ISR_STARTADDRESS+0x2C))
-#define pISR_EINT4_7		(*(unsigned *)(_ISR_STARTADDRESS+0x30))
-#define pISR_EINT8_23		(*(unsigned *)(_ISR_STARTADDRESS+0x34))
-#define pISR_BAT_FLT		(*(unsigned *)(_ISR_STARTADDRESS+0x3C))
-#define pISR_TICK		(*(unsigned *)(_ISR_STARTADDRESS+0x40))
-#define pISR_WDT		(*(unsigned *)(_ISR_STARTADDRESS+0x44))
-#define pISR_TIMER0		(*(unsigned *)(_ISR_STARTADDRESS+0x48))
-#define pISR_TIMER1		(*(unsigned *)(_ISR_STARTADDRESS+0x4C))
-#define pISR_TIMER2		(*(unsigned *)(_ISR_STARTADDRESS+0x50))
-#define pISR_TIMER3		(*(unsigned *)(_ISR_STARTADDRESS+0x54))
-#define pISR_TIMER4		(*(unsigned *)(_ISR_STARTADDRESS+0x58))
-#define pISR_UART2		(*(unsigned *)(_ISR_STARTADDRESS+0x5C))
-#define pISR_NOTUSED		(*(unsigned *)(_ISR_STARTADDRESS+0x60))
-#define pISR_DMA0		(*(unsigned *)(_ISR_STARTADDRESS+0x64))
-#define pISR_DMA1		(*(unsigned *)(_ISR_STARTADDRESS+0x68))
-#define pISR_DMA2		(*(unsigned *)(_ISR_STARTADDRESS+0x6C))
-#define pISR_DMA3		(*(unsigned *)(_ISR_STARTADDRESS+0x70))
-#define pISR_SDI		(*(unsigned *)(_ISR_STARTADDRESS+0x74))
-#define pISR_SPI0		(*(unsigned *)(_ISR_STARTADDRESS+0x78))
-#define pISR_UART1		(*(unsigned *)(_ISR_STARTADDRESS+0x7C))
-#define pISR_USBD		(*(unsigned *)(_ISR_STARTADDRESS+0x84))
-#define pISR_USBH		(*(unsigned *)(_ISR_STARTADDRESS+0x88))
-#define pISR_IIC		(*(unsigned *)(_ISR_STARTADDRESS+0x8C))
-#define pISR_UART0		(*(unsigned *)(_ISR_STARTADDRESS+0x90))
-#define pISR_SPI1		(*(unsigned *)(_ISR_STARTADDRESS+0x94))
-#define pISR_RTC		(*(unsigned *)(_ISR_STARTADDRESS+0x98))
-#define pISR_ADC		(*(unsigned *)(_ISR_STARTADDRESS+0xA0))
+#define pISR_RESET      (*(unsigned *)(_ISR_STARTADDRESS+0x0))
+#define pISR_UNDEF      (*(unsigned *)(_ISR_STARTADDRESS+0x4))
+#define pISR_SWI        (*(unsigned *)(_ISR_STARTADDRESS+0x8))
+#define pISR_PABORT     (*(unsigned *)(_ISR_STARTADDRESS+0xC))
+#define pISR_DABORT     (*(unsigned *)(_ISR_STARTADDRESS+0x10))
+#define pISR_RESERVED       (*(unsigned *)(_ISR_STARTADDRESS+0x14))
+#define pISR_IRQ        (*(unsigned *)(_ISR_STARTADDRESS+0x18))
+#define pISR_FIQ        (*(unsigned *)(_ISR_STARTADDRESS+0x1C))
+
+#define pISR_EINT0      (*(unsigned *)(_ISR_STARTADDRESS+0x20))
+#define pISR_EINT1      (*(unsigned *)(_ISR_STARTADDRESS+0x24))
+#define pISR_EINT2      (*(unsigned *)(_ISR_STARTADDRESS+0x28))
+#define pISR_EINT3      (*(unsigned *)(_ISR_STARTADDRESS+0x2C))
+#define pISR_EINT4_7        (*(unsigned *)(_ISR_STARTADDRESS+0x30))
+#define pISR_EINT8_23       (*(unsigned *)(_ISR_STARTADDRESS+0x34))
+#define pISR_BAT_FLT        (*(unsigned *)(_ISR_STARTADDRESS+0x3C))
+#define pISR_TICK       (*(unsigned *)(_ISR_STARTADDRESS+0x40))
+#define pISR_WDT        (*(unsigned *)(_ISR_STARTADDRESS+0x44))
+#define pISR_TIMER0     (*(unsigned *)(_ISR_STARTADDRESS+0x48))
+#define pISR_TIMER1     (*(unsigned *)(_ISR_STARTADDRESS+0x4C))
+#define pISR_TIMER2     (*(unsigned *)(_ISR_STARTADDRESS+0x50))
+#define pISR_TIMER3     (*(unsigned *)(_ISR_STARTADDRESS+0x54))
+#define pISR_TIMER4     (*(unsigned *)(_ISR_STARTADDRESS+0x58))
+#define pISR_UART2      (*(unsigned *)(_ISR_STARTADDRESS+0x5C))
+#define pISR_NOTUSED        (*(unsigned *)(_ISR_STARTADDRESS+0x60))
+#define pISR_DMA0       (*(unsigned *)(_ISR_STARTADDRESS+0x64))
+#define pISR_DMA1       (*(unsigned *)(_ISR_STARTADDRESS+0x68))
+#define pISR_DMA2       (*(unsigned *)(_ISR_STARTADDRESS+0x6C))
+#define pISR_DMA3       (*(unsigned *)(_ISR_STARTADDRESS+0x70))
+#define pISR_SDI        (*(unsigned *)(_ISR_STARTADDRESS+0x74))
+#define pISR_SPI0       (*(unsigned *)(_ISR_STARTADDRESS+0x78))
+#define pISR_UART1      (*(unsigned *)(_ISR_STARTADDRESS+0x7C))
+#define pISR_USBD       (*(unsigned *)(_ISR_STARTADDRESS+0x84))
+#define pISR_USBH       (*(unsigned *)(_ISR_STARTADDRESS+0x88))
+#define pISR_IIC        (*(unsigned *)(_ISR_STARTADDRESS+0x8C))
+#define pISR_UART0      (*(unsigned *)(_ISR_STARTADDRESS+0x90))
+#define pISR_SPI1       (*(unsigned *)(_ISR_STARTADDRESS+0x94))
+#define pISR_RTC        (*(unsigned *)(_ISR_STARTADDRESS+0x98))
+#define pISR_ADC        (*(unsigned *)(_ISR_STARTADDRESS+0xA0))
 
 
-/* PENDING BIT */
+// PENDING BIT
 #define BIT_EINT0		(0x1)
 #define BIT_EINT1		(0x1<<1)
 #define BIT_EINT2		(0x1<<2)
 #define BIT_EINT3		(0x1<<3)
 #define BIT_EINT4_7		(0x1<<4)
-#define BIT_EINT8_23		(0x1<<5)
+#define BIT_EINT8_23	(0x1<<5)
+#define BIT_CAM			(0x1<<6)		// Added for 2440.
 #define BIT_BAT_FLT		(0x1<<7)
-#define BIT_TICK		(0x1<<8)
-#define BIT_WDT			(0x1<<9)
+#define BIT_TICK			(0x1<<8)
+#define BIT_WDT_AC97	(0x1<<9)
 #define BIT_TIMER0		(0x1<<10)
 #define BIT_TIMER1		(0x1<<11)
 #define BIT_TIMER2		(0x1<<12)
@@ -207,21 +249,33 @@
 #define BIT_DMA2		(0x1<<19)
 #define BIT_DMA3		(0x1<<20)
 #define BIT_SDI			(0x1<<21)
-#define BIT_SPI0		(0x1<<22)
+#define BIT_SPI0			(0x1<<22)
 #define BIT_UART1		(0x1<<23)
+#define BIT_NFCON		(0x1<<24)		// Added for 2440.
 #define BIT_USBD		(0x1<<25)
 #define BIT_USBH		(0x1<<26)
 #define BIT_IIC			(0x1<<27)
 #define BIT_UART0		(0x1<<28)
-#define BIT_SPI1		(0x1<<29)
+#define BIT_SPI1			(0x1<<29)
 #define BIT_RTC			(0x1<<30)
 #define BIT_ADC			(0x1<<31)
-#define BIT_ALLMSK		(0xFFFFFFFF)
+#define BIT_ALLMSK		(0xffffffff)
+
+#define BIT_SUB_ALLMSK	(0x7fff)
+#define BIT_SUB_AC97 	(0x1<<14)
+#define BIT_SUB_WDT 	(0x1<<13)
+#define BIT_SUB_CAM_S	(0x1<<12)		// Added for 2440.
+#define BIT_SUB_CAM_C	(0x1<<11)		// Added for 2440.
+#define BIT_SUB_ADC		(0x1<<10)
+#define BIT_SUB_TC		(0x1<<9)
+#define BIT_SUB_ERR2	(0x1<<8)
+#define BIT_SUB_TXD2	(0x1<<7)
+#define BIT_SUB_RXD2	(0x1<<6)
+#define BIT_SUB_ERR1	(0x1<<5)
+#define BIT_SUB_TXD1	(0x1<<4)
+#define BIT_SUB_RXD1	(0x1<<3)
+#define BIT_SUB_ERR0	(0x1<<2)
+#define BIT_SUB_TXD0	(0x1<<1)
+#define BIT_SUB_RXD0	(0x1<<0)
 
-#define ClearPending(bit) {\
-		 rSRCPND = bit;\
-		 rINTPND = bit;\
-		 rINTPND;\
-		 }
-/* Wait until rINTPND is changed for the case that the ISR is very short. */
 #endif /*__S3C2410_H__*/
diff -urN u-boot-1.1.6_jz2440/include/s3c24x0.h u-boot-1.1.6_nand_ok/include/s3c24x0.h
--- u-boot-1.1.6_jz2440/include/s3c24x0.h	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_nand_ok/include/s3c24x0.h	2010-11-26 12:54:37.882083977 +0800
@@ -22,7 +22,7 @@
  */
 
 /************************************************
- * NAME	    : s3c24x0.h
+ * NAME     : s3c24x0.h
  * Version  : 31.3.2003
  *
  * common stuff for SAMSUNG S3C24X0 SoC
@@ -31,337 +31,363 @@
 #ifndef __S3C24X0_H__
 #define __S3C24X0_H__
 
-typedef volatile u8	S3C24X0_REG8;
-typedef volatile u16	S3C24X0_REG16;
-typedef volatile u32	S3C24X0_REG32;
+typedef volatile u8 S3C24X0_REG8;
+typedef volatile u16    S3C24X0_REG16;
+typedef volatile u32    S3C24X0_REG32;
 
 /* Memory controller (see manual chapter 5) */
 typedef struct {
-	S3C24X0_REG32	BWSCON;
-	S3C24X0_REG32	BANKCON[8];
-	S3C24X0_REG32	REFRESH;
-	S3C24X0_REG32	BANKSIZE;
-	S3C24X0_REG32	MRSRB6;
-	S3C24X0_REG32	MRSRB7;
+    S3C24X0_REG32   BWSCON;
+    S3C24X0_REG32   BANKCON[8];
+    S3C24X0_REG32   REFRESH;
+    S3C24X0_REG32   BANKSIZE;
+    S3C24X0_REG32   MRSRB6;
+    S3C24X0_REG32   MRSRB7;
 } /*__attribute__((__packed__))*/ S3C24X0_MEMCTL;
 
 
 /* USB HOST (see manual chapter 12) */
 typedef struct {
-	S3C24X0_REG32	HcRevision;
-	S3C24X0_REG32	HcControl;
-	S3C24X0_REG32	HcCommonStatus;
-	S3C24X0_REG32	HcInterruptStatus;
-	S3C24X0_REG32	HcInterruptEnable;
-	S3C24X0_REG32	HcInterruptDisable;
-	S3C24X0_REG32	HcHCCA;
-	S3C24X0_REG32	HcPeriodCuttendED;
-	S3C24X0_REG32	HcControlHeadED;
-	S3C24X0_REG32	HcControlCurrentED;
-	S3C24X0_REG32	HcBulkHeadED;
-	S3C24X0_REG32	HcBuldCurrentED;
-	S3C24X0_REG32	HcDoneHead;
-	S3C24X0_REG32	HcRmInterval;
-	S3C24X0_REG32	HcFmRemaining;
-	S3C24X0_REG32	HcFmNumber;
-	S3C24X0_REG32	HcPeriodicStart;
-	S3C24X0_REG32	HcLSThreshold;
-	S3C24X0_REG32	HcRhDescriptorA;
-	S3C24X0_REG32	HcRhDescriptorB;
-	S3C24X0_REG32	HcRhStatus;
-	S3C24X0_REG32	HcRhPortStatus1;
-	S3C24X0_REG32	HcRhPortStatus2;
+    S3C24X0_REG32   HcRevision;
+    S3C24X0_REG32   HcControl;
+    S3C24X0_REG32   HcCommonStatus;
+    S3C24X0_REG32   HcInterruptStatus;
+    S3C24X0_REG32   HcInterruptEnable;
+    S3C24X0_REG32   HcInterruptDisable;
+    S3C24X0_REG32   HcHCCA;
+    S3C24X0_REG32   HcPeriodCuttendED;
+    S3C24X0_REG32   HcControlHeadED;
+    S3C24X0_REG32   HcControlCurrentED;
+    S3C24X0_REG32   HcBulkHeadED;
+    S3C24X0_REG32   HcBuldCurrentED;
+    S3C24X0_REG32   HcDoneHead;
+    S3C24X0_REG32   HcRmInterval;
+    S3C24X0_REG32   HcFmRemaining;
+    S3C24X0_REG32   HcFmNumber;
+    S3C24X0_REG32   HcPeriodicStart;
+    S3C24X0_REG32   HcLSThreshold;
+    S3C24X0_REG32   HcRhDescriptorA;
+    S3C24X0_REG32   HcRhDescriptorB;
+    S3C24X0_REG32   HcRhStatus;
+    S3C24X0_REG32   HcRhPortStatus1;
+    S3C24X0_REG32   HcRhPortStatus2;
 } /*__attribute__((__packed__))*/ S3C24X0_USB_HOST;
 
 
 /* INTERRUPT (see manual chapter 14) */
 typedef struct {
-	S3C24X0_REG32	SRCPND;
-	S3C24X0_REG32	INTMOD;
-	S3C24X0_REG32	INTMSK;
-	S3C24X0_REG32	PRIORITY;
-	S3C24X0_REG32	INTPND;
-	S3C24X0_REG32	INTOFFSET;
+    S3C24X0_REG32   SRCPND;
+    S3C24X0_REG32   INTMOD;
+    S3C24X0_REG32   INTMSK;
+    S3C24X0_REG32   PRIORITY;
+    S3C24X0_REG32   INTPND;
+    S3C24X0_REG32   INTOFFSET;
 #ifdef CONFIG_S3C2410
-	S3C24X0_REG32	SUBSRCPND;
-	S3C24X0_REG32	INTSUBMSK;
+    S3C24X0_REG32   SUBSRCPND;
+    S3C24X0_REG32   INTSUBMSK;
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_INTERRUPT;
 
 
 /* DMAS (see manual chapter 8) */
 typedef struct {
-	S3C24X0_REG32	DISRC;
+    S3C24X0_REG32   DISRC;
 #ifdef CONFIG_S3C2410
-	S3C24X0_REG32	DISRCC;
+    S3C24X0_REG32   DISRCC;
 #endif
-	S3C24X0_REG32	DIDST;
+    S3C24X0_REG32   DIDST;
 #ifdef CONFIG_S3C2410
-	S3C24X0_REG32	DIDSTC;
+    S3C24X0_REG32   DIDSTC;
 #endif
-	S3C24X0_REG32	DCON;
-	S3C24X0_REG32	DSTAT;
-	S3C24X0_REG32	DCSRC;
-	S3C24X0_REG32	DCDST;
-	S3C24X0_REG32	DMASKTRIG;
+    S3C24X0_REG32   DCON;
+    S3C24X0_REG32   DSTAT;
+    S3C24X0_REG32   DCSRC;
+    S3C24X0_REG32   DCDST;
+    S3C24X0_REG32   DMASKTRIG;
 #ifdef CONFIG_S3C2400
-	S3C24X0_REG32	res[1];
+    S3C24X0_REG32   res[1];
 #endif
 #ifdef CONFIG_S3C2410
-	S3C24X0_REG32	res[7];
+    S3C24X0_REG32   res[7];
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_DMA;
 
 typedef struct {
-	S3C24X0_DMA	dma[4];
+    S3C24X0_DMA dma[4];
 } /*__attribute__((__packed__))*/ S3C24X0_DMAS;
 
 
 /* CLOCK & POWER MANAGEMENT (see S3C2400 manual chapter 6) */
 /*                          (see S3C2410 manual chapter 7) */
 typedef struct {
-	S3C24X0_REG32	LOCKTIME;
-	S3C24X0_REG32	MPLLCON;
-	S3C24X0_REG32	UPLLCON;
-	S3C24X0_REG32	CLKCON;
-	S3C24X0_REG32	CLKSLOW;
-	S3C24X0_REG32	CLKDIVN;
+    S3C24X0_REG32   LOCKTIME;
+    S3C24X0_REG32   MPLLCON;
+    S3C24X0_REG32   UPLLCON;
+    S3C24X0_REG32   CLKCON;
+    S3C24X0_REG32   CLKSLOW;
+    S3C24X0_REG32   CLKDIVN;
+    S3C24X0_REG32   CAMDIVN;    /* for s3c2440, by www.100ask.net */
 } /*__attribute__((__packed__))*/ S3C24X0_CLOCK_POWER;
 
 
 /* LCD CONTROLLER (see manual chapter 15) */
 typedef struct {
-	S3C24X0_REG32	LCDCON1;
-	S3C24X0_REG32	LCDCON2;
-	S3C24X0_REG32	LCDCON3;
-	S3C24X0_REG32	LCDCON4;
-	S3C24X0_REG32	LCDCON5;
-	S3C24X0_REG32	LCDSADDR1;
-	S3C24X0_REG32	LCDSADDR2;
-	S3C24X0_REG32	LCDSADDR3;
-	S3C24X0_REG32	REDLUT;
-	S3C24X0_REG32	GREENLUT;
-	S3C24X0_REG32	BLUELUT;
-	S3C24X0_REG32	res[8];
-	S3C24X0_REG32	DITHMODE;
-	S3C24X0_REG32	TPAL;
+    S3C24X0_REG32   LCDCON1;
+    S3C24X0_REG32   LCDCON2;
+    S3C24X0_REG32   LCDCON3;
+    S3C24X0_REG32   LCDCON4;
+    S3C24X0_REG32   LCDCON5;
+    S3C24X0_REG32   LCDSADDR1;
+    S3C24X0_REG32   LCDSADDR2;
+    S3C24X0_REG32   LCDSADDR3;
+    S3C24X0_REG32   REDLUT;
+    S3C24X0_REG32   GREENLUT;
+    S3C24X0_REG32   BLUELUT;
+    S3C24X0_REG32   res[8];
+    S3C24X0_REG32   DITHMODE;
+    S3C24X0_REG32   TPAL;
 #ifdef CONFIG_S3C2410
-	S3C24X0_REG32	LCDINTPND;
-	S3C24X0_REG32	LCDSRCPND;
-	S3C24X0_REG32	LCDINTMSK;
-	S3C24X0_REG32	LPCSEL;
+    S3C24X0_REG32   LCDINTPND;
+    S3C24X0_REG32   LCDSRCPND;
+    S3C24X0_REG32   LCDINTMSK;
+    S3C24X0_REG32   LPCSEL;
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_LCD;
 
 
 /* NAND FLASH (see S3C2410 manual chapter 6) */
 typedef struct {
-	S3C24X0_REG32	NFCONF;
-	S3C24X0_REG32	NFCMD;
-	S3C24X0_REG32	NFADDR;
-	S3C24X0_REG32	NFDATA;
-	S3C24X0_REG32	NFSTAT;
-	S3C24X0_REG32	NFECC;
+    S3C24X0_REG32   NFCONF;
+    S3C24X0_REG32   NFCMD;
+    S3C24X0_REG32   NFADDR;
+    S3C24X0_REG32   NFDATA;
+    S3C24X0_REG32   NFSTAT;
+    S3C24X0_REG32   NFECC;
 } /*__attribute__((__packed__))*/ S3C2410_NAND;
 
+/* NAND FLASH (see S3C2440 manual chapter 6, www.100ask.net) */
+typedef struct {
+    S3C24X0_REG32   NFCONF;
+    S3C24X0_REG32   NFCONT;
+    S3C24X0_REG32   NFCMD;
+    S3C24X0_REG32   NFADDR;
+    S3C24X0_REG32   NFDATA;
+    S3C24X0_REG32   NFMECCD0;
+    S3C24X0_REG32   NFMECCD1;
+    S3C24X0_REG32   NFSECCD;
+    S3C24X0_REG32   NFSTAT;
+    S3C24X0_REG32   NFESTAT0;
+    S3C24X0_REG32   NFESTAT1;
+    S3C24X0_REG32   NFMECC0;
+    S3C24X0_REG32   NFMECC1;
+    S3C24X0_REG32   NFSECC;
+    S3C24X0_REG32   NFSBLK;
+    S3C24X0_REG32   NFEBLK;
+} /*__attribute__((__packed__))*/ S3C2440_NAND;
 
 /* UART (see manual chapter 11) */
 typedef struct {
-	S3C24X0_REG32	ULCON;
-	S3C24X0_REG32	UCON;
-	S3C24X0_REG32	UFCON;
-	S3C24X0_REG32	UMCON;
-	S3C24X0_REG32	UTRSTAT;
-	S3C24X0_REG32	UERSTAT;
-	S3C24X0_REG32	UFSTAT;
-	S3C24X0_REG32	UMSTAT;
+    S3C24X0_REG32   ULCON;
+    S3C24X0_REG32   UCON;
+    S3C24X0_REG32   UFCON;
+    S3C24X0_REG32   UMCON;
+    S3C24X0_REG32   UTRSTAT;
+    S3C24X0_REG32   UERSTAT;
+    S3C24X0_REG32   UFSTAT;
+    S3C24X0_REG32   UMSTAT;
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	UTXH;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	URXH;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    UTXH;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    URXH;
 #else /* Little Endian */
-	S3C24X0_REG8	UTXH;
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	URXH;
-	S3C24X0_REG8	res2[3];
+    S3C24X0_REG8    UTXH;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    URXH;
+    S3C24X0_REG8    res2[3];
 #endif
-	S3C24X0_REG32	UBRDIV;
+    S3C24X0_REG32   UBRDIV;
 } /*__attribute__((__packed__))*/ S3C24X0_UART;
 
 
 /* PWM TIMER (see manual chapter 10) */
 typedef struct {
-	S3C24X0_REG32	TCNTB;
-	S3C24X0_REG32	TCMPB;
-	S3C24X0_REG32	TCNTO;
+    S3C24X0_REG32   TCNTB;
+    S3C24X0_REG32   TCMPB;
+    S3C24X0_REG32   TCNTO;
 } /*__attribute__((__packed__))*/ S3C24X0_TIMER;
 
 typedef struct {
-	S3C24X0_REG32	TCFG0;
-	S3C24X0_REG32	TCFG1;
-	S3C24X0_REG32	TCON;
-	S3C24X0_TIMER	ch[4];
-	S3C24X0_REG32	TCNTB4;
-	S3C24X0_REG32	TCNTO4;
+    S3C24X0_REG32   TCFG0;
+    S3C24X0_REG32   TCFG1;
+    S3C24X0_REG32   TCON;
+    S3C24X0_TIMER   ch[4];
+    S3C24X0_REG32   TCNTB4;
+    S3C24X0_REG32   TCNTO4;
 } /*__attribute__((__packed__))*/ S3C24X0_TIMERS;
 
 
 /* USB DEVICE (see manual chapter 13) */
 typedef struct {
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res[3];
-	S3C24X0_REG8	EP_FIFO_REG;
+    S3C24X0_REG8    res[3];
+    S3C24X0_REG8    EP_FIFO_REG;
 #else /*  little endian */
-	S3C24X0_REG8	EP_FIFO_REG;
-	S3C24X0_REG8	res[3];
+    S3C24X0_REG8    EP_FIFO_REG;
+    S3C24X0_REG8    res[3];
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_USB_DEV_FIFOS;
 
 typedef struct {
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	EP_DMA_CON;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	EP_DMA_UNIT;
-	S3C24X0_REG8	res3[3];
-	S3C24X0_REG8	EP_DMA_FIFO;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG8	EP_DMA_TTC_L;
-	S3C24X0_REG8	res5[3];
-	S3C24X0_REG8	EP_DMA_TTC_M;
-	S3C24X0_REG8	res6[3];
-	S3C24X0_REG8	EP_DMA_TTC_H;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    EP_DMA_CON;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    EP_DMA_UNIT;
+    S3C24X0_REG8    res3[3];
+    S3C24X0_REG8    EP_DMA_FIFO;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG8    EP_DMA_TTC_L;
+    S3C24X0_REG8    res5[3];
+    S3C24X0_REG8    EP_DMA_TTC_M;
+    S3C24X0_REG8    res6[3];
+    S3C24X0_REG8    EP_DMA_TTC_H;
 #else /*  little endian */
-	S3C24X0_REG8	EP_DMA_CON;
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	EP_DMA_UNIT;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	EP_DMA_FIFO;
-	S3C24X0_REG8	res3[3];
-	S3C24X0_REG8	EP_DMA_TTC_L;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG8	EP_DMA_TTC_M;
-	S3C24X0_REG8	res5[3];
-	S3C24X0_REG8	EP_DMA_TTC_H;
-	S3C24X0_REG8	res6[3];
+    S3C24X0_REG8    EP_DMA_CON;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    EP_DMA_UNIT;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    EP_DMA_FIFO;
+    S3C24X0_REG8    res3[3];
+    S3C24X0_REG8    EP_DMA_TTC_L;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG8    EP_DMA_TTC_M;
+    S3C24X0_REG8    res5[3];
+    S3C24X0_REG8    EP_DMA_TTC_H;
+    S3C24X0_REG8    res6[3];
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_USB_DEV_DMAS;
 
 typedef struct {
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	FUNC_ADDR_REG;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	PWR_REG;
-	S3C24X0_REG8	res3[3];
-	S3C24X0_REG8	EP_INT_REG;
-	S3C24X0_REG8	res4[15];
-	S3C24X0_REG8	USB_INT_REG;
-	S3C24X0_REG8	res5[3];
-	S3C24X0_REG8	EP_INT_EN_REG;
-	S3C24X0_REG8	res6[15];
-	S3C24X0_REG8	USB_INT_EN_REG;
-	S3C24X0_REG8	res7[3];
-	S3C24X0_REG8	FRAME_NUM1_REG;
-	S3C24X0_REG8	res8[3];
-	S3C24X0_REG8	FRAME_NUM2_REG;
-	S3C24X0_REG8	res9[3];
-	S3C24X0_REG8	INDEX_REG;
-	S3C24X0_REG8	res10[7];
-	S3C24X0_REG8	MAXP_REG;
-	S3C24X0_REG8	res11[3];
-	S3C24X0_REG8	EP0_CSR_IN_CSR1_REG;
-	S3C24X0_REG8	res12[3];
-	S3C24X0_REG8	IN_CSR2_REG;
-	S3C24X0_REG8	res13[7];
-	S3C24X0_REG8	OUT_CSR1_REG;
-	S3C24X0_REG8	res14[3];
-	S3C24X0_REG8	OUT_CSR2_REG;
-	S3C24X0_REG8	res15[3];
-	S3C24X0_REG8	OUT_FIFO_CNT1_REG;
-	S3C24X0_REG8	res16[3];
-	S3C24X0_REG8	OUT_FIFO_CNT2_REG;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    FUNC_ADDR_REG;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    PWR_REG;
+    S3C24X0_REG8    res3[3];
+    S3C24X0_REG8    EP_INT_REG;
+    S3C24X0_REG8    res4[15];
+    S3C24X0_REG8    USB_INT_REG;
+    S3C24X0_REG8    res5[3];
+    S3C24X0_REG8    EP_INT_EN_REG;
+    S3C24X0_REG8    res6[15];
+    S3C24X0_REG8    USB_INT_EN_REG;
+    S3C24X0_REG8    res7[3];
+    S3C24X0_REG8    FRAME_NUM1_REG;
+    S3C24X0_REG8    res8[3];
+    S3C24X0_REG8    FRAME_NUM2_REG;
+    S3C24X0_REG8    res9[3];
+    S3C24X0_REG8    INDEX_REG;
+    S3C24X0_REG8    res10[7];
+    S3C24X0_REG8    MAXP_REG;
+    S3C24X0_REG8    res11[3];
+    S3C24X0_REG8    EP0_CSR_IN_CSR1_REG;
+    S3C24X0_REG8    res12[3];
+    S3C24X0_REG8    IN_CSR2_REG;
+    S3C24X0_REG8    res13[7];
+    S3C24X0_REG8    OUT_CSR1_REG;
+    S3C24X0_REG8    res14[3];
+    S3C24X0_REG8    OUT_CSR2_REG;
+    S3C24X0_REG8    res15[3];
+    S3C24X0_REG8    OUT_FIFO_CNT1_REG;
+    S3C24X0_REG8    res16[3];
+    S3C24X0_REG8    OUT_FIFO_CNT2_REG;
 #else /*  little endian */
-	S3C24X0_REG8	FUNC_ADDR_REG;
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	PWR_REG;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	EP_INT_REG;
-	S3C24X0_REG8	res3[15];
-	S3C24X0_REG8	USB_INT_REG;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG8	EP_INT_EN_REG;
-	S3C24X0_REG8	res5[15];
-	S3C24X0_REG8	USB_INT_EN_REG;
-	S3C24X0_REG8	res6[3];
-	S3C24X0_REG8	FRAME_NUM1_REG;
-	S3C24X0_REG8	res7[3];
-	S3C24X0_REG8	FRAME_NUM2_REG;
-	S3C24X0_REG8	res8[3];
-	S3C24X0_REG8	INDEX_REG;
-	S3C24X0_REG8	res9[7];
-	S3C24X0_REG8	MAXP_REG;
-	S3C24X0_REG8	res10[7];
-	S3C24X0_REG8	EP0_CSR_IN_CSR1_REG;
-	S3C24X0_REG8	res11[3];
-	S3C24X0_REG8	IN_CSR2_REG;
-	S3C24X0_REG8	res12[3];
-	S3C24X0_REG8	OUT_CSR1_REG;
-	S3C24X0_REG8	res13[7];
-	S3C24X0_REG8	OUT_CSR2_REG;
-	S3C24X0_REG8	res14[3];
-	S3C24X0_REG8	OUT_FIFO_CNT1_REG;
-	S3C24X0_REG8	res15[3];
-	S3C24X0_REG8	OUT_FIFO_CNT2_REG;
-	S3C24X0_REG8	res16[3];
+    S3C24X0_REG8    FUNC_ADDR_REG;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    PWR_REG;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    EP_INT_REG;
+    S3C24X0_REG8    res3[15];
+    S3C24X0_REG8    USB_INT_REG;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG8    EP_INT_EN_REG;
+    S3C24X0_REG8    res5[15];
+    S3C24X0_REG8    USB_INT_EN_REG;
+    S3C24X0_REG8    res6[3];
+    S3C24X0_REG8    FRAME_NUM1_REG;
+    S3C24X0_REG8    res7[3];
+    S3C24X0_REG8    FRAME_NUM2_REG;
+    S3C24X0_REG8    res8[3];
+    S3C24X0_REG8    INDEX_REG;
+    S3C24X0_REG8    res9[7];
+    S3C24X0_REG8    MAXP_REG;
+    S3C24X0_REG8    res10[3];
+    S3C24X0_REG8    EP0_CSR_IN_CSR1_REG;
+    S3C24X0_REG8    res11[3];
+    S3C24X0_REG8    IN_CSR2_REG;
+    S3C24X0_REG8    res12[7];
+    S3C24X0_REG8    OUT_CSR1_REG;
+    S3C24X0_REG8    res13[3];
+    S3C24X0_REG8    OUT_CSR2_REG;
+    S3C24X0_REG8    res14[3];
+    S3C24X0_REG8    OUT_FIFO_CNT1_REG;
+    S3C24X0_REG8    res15[3];
+    S3C24X0_REG8    OUT_FIFO_CNT2_REG;
+    S3C24X0_REG8    res16[3];
 #endif /*  __BIG_ENDIAN */
-	S3C24X0_USB_DEV_FIFOS	fifo[5];
-	S3C24X0_USB_DEV_DMAS	dma[5];
+    S3C24X0_REG32   res17[8];
+    S3C24X0_USB_DEV_FIFOS   fifo[5];
+    S3C24X0_REG32   res18[11];
+    S3C24X0_USB_DEV_DMAS    ep1;
+    S3C24X0_USB_DEV_DMAS    ep2;
+    S3C24X0_REG8    res19[16];
+    S3C24X0_USB_DEV_DMAS    ep3;
+    S3C24X0_USB_DEV_DMAS    ep4;
 } /*__attribute__((__packed__))*/ S3C24X0_USB_DEVICE;
 
 
 /* WATCH DOG TIMER (see manual chapter 18) */
 typedef struct {
-	S3C24X0_REG32	WTCON;
-	S3C24X0_REG32	WTDAT;
-	S3C24X0_REG32	WTCNT;
+    S3C24X0_REG32   WTCON;
+    S3C24X0_REG32   WTDAT;
+    S3C24X0_REG32   WTCNT;
 } /*__attribute__((__packed__))*/ S3C24X0_WATCHDOG;
 
 
 /* IIC (see manual chapter 20) */
 typedef struct {
-	S3C24X0_REG32	IICCON;
-	S3C24X0_REG32	IICSTAT;
-	S3C24X0_REG32	IICADD;
-	S3C24X0_REG32	IICDS;
+    S3C24X0_REG32   IICCON;
+    S3C24X0_REG32   IICSTAT;
+    S3C24X0_REG32   IICADD;
+    S3C24X0_REG32   IICDS;
 } /*__attribute__((__packed__))*/ S3C24X0_I2C;
 
 
 /* IIS (see manual chapter 21) */
 typedef struct {
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG16	res1;
-	S3C24X0_REG16	IISCON;
-	S3C24X0_REG16	res2;
-	S3C24X0_REG16	IISMOD;
-	S3C24X0_REG16	res3;
-	S3C24X0_REG16	IISPSR;
-	S3C24X0_REG16	res4;
-	S3C24X0_REG16	IISFCON;
-	S3C24X0_REG16	res5;
-	S3C24X0_REG16	IISFIFO;
+    S3C24X0_REG16   res1;
+    S3C24X0_REG16   IISCON;
+    S3C24X0_REG16   res2;
+    S3C24X0_REG16   IISMOD;
+    S3C24X0_REG16   res3;
+    S3C24X0_REG16   IISPSR;
+    S3C24X0_REG16   res4;
+    S3C24X0_REG16   IISFCON;
+    S3C24X0_REG16   res5;
+    S3C24X0_REG16   IISFIFO;
 #else /*  little endian */
-	S3C24X0_REG16	IISCON;
-	S3C24X0_REG16	res1;
-	S3C24X0_REG16	IISMOD;
-	S3C24X0_REG16	res2;
-	S3C24X0_REG16	IISPSR;
-	S3C24X0_REG16	res3;
-	S3C24X0_REG16	IISFCON;
-	S3C24X0_REG16	res4;
-	S3C24X0_REG16	IISFIFO;
-	S3C24X0_REG16	res5;
+    S3C24X0_REG16   IISCON;
+    S3C24X0_REG16   res1;
+    S3C24X0_REG16   IISMOD;
+    S3C24X0_REG16   res2;
+    S3C24X0_REG16   IISPSR;
+    S3C24X0_REG16   res3;
+    S3C24X0_REG16   IISFCON;
+    S3C24X0_REG16   res4;
+    S3C24X0_REG16   IISFIFO;
+    S3C24X0_REG16   res5;
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_I2S;
 
@@ -369,87 +395,93 @@
 /* I/O PORT (see manual chapter 9) */
 typedef struct {
 #ifdef CONFIG_S3C2400
-	S3C24X0_REG32	PACON;
-	S3C24X0_REG32	PADAT;
+    S3C24X0_REG32   PACON;
+    S3C24X0_REG32   PADAT;
 
-	S3C24X0_REG32	PBCON;
-	S3C24X0_REG32	PBDAT;
-	S3C24X0_REG32	PBUP;
+    S3C24X0_REG32   PBCON;
+    S3C24X0_REG32   PBDAT;
+    S3C24X0_REG32   PBUP;
 
-	S3C24X0_REG32	PCCON;
-	S3C24X0_REG32	PCDAT;
-	S3C24X0_REG32	PCUP;
+    S3C24X0_REG32   PCCON;
+    S3C24X0_REG32   PCDAT;
+    S3C24X0_REG32   PCUP;
 
-	S3C24X0_REG32	PDCON;
-	S3C24X0_REG32	PDDAT;
-	S3C24X0_REG32	PDUP;
+    S3C24X0_REG32   PDCON;
+    S3C24X0_REG32   PDDAT;
+    S3C24X0_REG32   PDUP;
 
-	S3C24X0_REG32	PECON;
-	S3C24X0_REG32	PEDAT;
-	S3C24X0_REG32	PEUP;
+    S3C24X0_REG32   PECON;
+    S3C24X0_REG32   PEDAT;
+    S3C24X0_REG32   PEUP;
 
-	S3C24X0_REG32	PFCON;
-	S3C24X0_REG32	PFDAT;
-	S3C24X0_REG32	PFUP;
+    S3C24X0_REG32   PFCON;
+    S3C24X0_REG32   PFDAT;
+    S3C24X0_REG32   PFUP;
 
-	S3C24X0_REG32	PGCON;
-	S3C24X0_REG32	PGDAT;
-	S3C24X0_REG32	PGUP;
+    S3C24X0_REG32   PGCON;
+    S3C24X0_REG32   PGDAT;
+    S3C24X0_REG32   PGUP;
 
-	S3C24X0_REG32	OPENCR;
+    S3C24X0_REG32   OPENCR;
 
-	S3C24X0_REG32	MISCCR;
-	S3C24X0_REG32	EXTINT;
+    S3C24X0_REG32   MISCCR;
+    S3C24X0_REG32   EXTINT;
 #endif
 #ifdef CONFIG_S3C2410
-	S3C24X0_REG32	GPACON;
-	S3C24X0_REG32	GPADAT;
-	S3C24X0_REG32	res1[2];
-	S3C24X0_REG32	GPBCON;
-	S3C24X0_REG32	GPBDAT;
-	S3C24X0_REG32	GPBUP;
-	S3C24X0_REG32	res2;
-	S3C24X0_REG32	GPCCON;
-	S3C24X0_REG32	GPCDAT;
-	S3C24X0_REG32	GPCUP;
-	S3C24X0_REG32	res3;
-	S3C24X0_REG32	GPDCON;
-	S3C24X0_REG32	GPDDAT;
-	S3C24X0_REG32	GPDUP;
-	S3C24X0_REG32	res4;
-	S3C24X0_REG32	GPECON;
-	S3C24X0_REG32	GPEDAT;
-	S3C24X0_REG32	GPEUP;
-	S3C24X0_REG32	res5;
-	S3C24X0_REG32	GPFCON;
-	S3C24X0_REG32	GPFDAT;
-	S3C24X0_REG32	GPFUP;
-	S3C24X0_REG32	res6;
-	S3C24X0_REG32	GPGCON;
-	S3C24X0_REG32	GPGDAT;
-	S3C24X0_REG32	GPGUP;
-	S3C24X0_REG32	res7;
-	S3C24X0_REG32	GPHCON;
-	S3C24X0_REG32	GPHDAT;
-	S3C24X0_REG32	GPHUP;
-	S3C24X0_REG32	res8;
-
-	S3C24X0_REG32	MISCCR;
-	S3C24X0_REG32	DCLKCON;
-	S3C24X0_REG32	EXTINT0;
-	S3C24X0_REG32	EXTINT1;
-	S3C24X0_REG32	EXTINT2;
-	S3C24X0_REG32	EINTFLT0;
-	S3C24X0_REG32	EINTFLT1;
-	S3C24X0_REG32	EINTFLT2;
-	S3C24X0_REG32	EINTFLT3;
-	S3C24X0_REG32	EINTMASK;
-	S3C24X0_REG32	EINTPEND;
-	S3C24X0_REG32	GSTATUS0;
-	S3C24X0_REG32	GSTATUS1;
-	S3C24X0_REG32	GSTATUS2;
-	S3C24X0_REG32	GSTATUS3;
-	S3C24X0_REG32	GSTATUS4;
+    S3C24X0_REG32   GPACON;
+    S3C24X0_REG32   GPADAT;
+    S3C24X0_REG32   res1[2];
+    S3C24X0_REG32   GPBCON;
+    S3C24X0_REG32   GPBDAT;
+    S3C24X0_REG32   GPBUP;
+    S3C24X0_REG32   res2;
+    S3C24X0_REG32   GPCCON;
+    S3C24X0_REG32   GPCDAT;
+    S3C24X0_REG32   GPCUP;
+    S3C24X0_REG32   res3;
+    S3C24X0_REG32   GPDCON;
+    S3C24X0_REG32   GPDDAT;
+    S3C24X0_REG32   GPDUP;
+    S3C24X0_REG32   res4;
+    S3C24X0_REG32   GPECON;
+    S3C24X0_REG32   GPEDAT;
+    S3C24X0_REG32   GPEUP;
+    S3C24X0_REG32   res5;
+    S3C24X0_REG32   GPFCON;
+    S3C24X0_REG32   GPFDAT;
+    S3C24X0_REG32   GPFUP;
+    S3C24X0_REG32   res6;
+    S3C24X0_REG32   GPGCON;
+    S3C24X0_REG32   GPGDAT;
+    S3C24X0_REG32   GPGUP;
+    S3C24X0_REG32   res7;
+    S3C24X0_REG32   GPHCON;
+    S3C24X0_REG32   GPHDAT;
+    S3C24X0_REG32   GPHUP;
+    S3C24X0_REG32   res8;
+
+    S3C24X0_REG32   MISCCR;
+    S3C24X0_REG32   DCLKCON;
+    S3C24X0_REG32   EXTINT0;
+    S3C24X0_REG32   EXTINT1;
+    S3C24X0_REG32   EXTINT2;
+    S3C24X0_REG32   EINTFLT0;
+    S3C24X0_REG32   EINTFLT1;
+    S3C24X0_REG32   EINTFLT2;
+    S3C24X0_REG32   EINTFLT3;
+    S3C24X0_REG32   EINTMASK;
+    S3C24X0_REG32   EINTPEND;
+    S3C24X0_REG32   GSTATUS0;
+    S3C24X0_REG32   GSTATUS1;
+    S3C24X0_REG32   GSTATUS2;
+    S3C24X0_REG32   GSTATUS3;
+    S3C24X0_REG32   GSTATUS4;
+
+    /* s3c2440 */
+    S3C24X0_REG32   res9[4];
+    S3C24X0_REG32   GPJCON;
+    S3C24X0_REG32   GPJDAT;
+    S3C24X0_REG32   GPJUP;
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_GPIO;
 
@@ -457,679 +489,682 @@
 /* RTC (see manual chapter 17) */
 typedef struct {
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res1[67];
-	S3C24X0_REG8	RTCCON;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	TICNT;
-	S3C24X0_REG8	res3[11];
-	S3C24X0_REG8	RTCALM;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG8	ALMSEC;
-	S3C24X0_REG8	res5[3];
-	S3C24X0_REG8	ALMMIN;
-	S3C24X0_REG8	res6[3];
-	S3C24X0_REG8	ALMHOUR;
-	S3C24X0_REG8	res7[3];
-	S3C24X0_REG8	ALMDATE;
-	S3C24X0_REG8	res8[3];
-	S3C24X0_REG8	ALMMON;
-	S3C24X0_REG8	res9[3];
-	S3C24X0_REG8	ALMYEAR;
-	S3C24X0_REG8	res10[3];
-	S3C24X0_REG8	RTCRST;
-	S3C24X0_REG8	res11[3];
-	S3C24X0_REG8	BCDSEC;
-	S3C24X0_REG8	res12[3];
-	S3C24X0_REG8	BCDMIN;
-	S3C24X0_REG8	res13[3];
-	S3C24X0_REG8	BCDHOUR;
-	S3C24X0_REG8	res14[3];
-	S3C24X0_REG8	BCDDATE;
-	S3C24X0_REG8	res15[3];
-	S3C24X0_REG8	BCDDAY;
-	S3C24X0_REG8	res16[3];
-	S3C24X0_REG8	BCDMON;
-	S3C24X0_REG8	res17[3];
-	S3C24X0_REG8	BCDYEAR;
+    S3C24X0_REG8    res1[67];
+    S3C24X0_REG8    RTCCON;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    TICNT;
+    S3C24X0_REG8    res3[11];
+    S3C24X0_REG8    RTCALM;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG8    ALMSEC;
+    S3C24X0_REG8    res5[3];
+    S3C24X0_REG8    ALMMIN;
+    S3C24X0_REG8    res6[3];
+    S3C24X0_REG8    ALMHOUR;
+    S3C24X0_REG8    res7[3];
+    S3C24X0_REG8    ALMDATE;
+    S3C24X0_REG8    res8[3];
+    S3C24X0_REG8    ALMMON;
+    S3C24X0_REG8    res9[3];
+    S3C24X0_REG8    ALMYEAR;
+    S3C24X0_REG8    res10[3];
+    S3C24X0_REG8    RTCRST;
+    S3C24X0_REG8    res11[3];
+    S3C24X0_REG8    BCDSEC;
+    S3C24X0_REG8    res12[3];
+    S3C24X0_REG8    BCDMIN;
+    S3C24X0_REG8    res13[3];
+    S3C24X0_REG8    BCDHOUR;
+    S3C24X0_REG8    res14[3];
+    S3C24X0_REG8    BCDDATE;
+    S3C24X0_REG8    res15[3];
+    S3C24X0_REG8    BCDDAY;
+    S3C24X0_REG8    res16[3];
+    S3C24X0_REG8    BCDMON;
+    S3C24X0_REG8    res17[3];
+    S3C24X0_REG8    BCDYEAR;
 #else /*  little endian */
-	S3C24X0_REG8	res0[64];
-	S3C24X0_REG8	RTCCON;
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	TICNT;
-	S3C24X0_REG8	res2[11];
-	S3C24X0_REG8	RTCALM;
-	S3C24X0_REG8	res3[3];
-	S3C24X0_REG8	ALMSEC;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG8	ALMMIN;
-	S3C24X0_REG8	res5[3];
-	S3C24X0_REG8	ALMHOUR;
-	S3C24X0_REG8	res6[3];
-	S3C24X0_REG8	ALMDATE;
-	S3C24X0_REG8	res7[3];
-	S3C24X0_REG8	ALMMON;
-	S3C24X0_REG8	res8[3];
-	S3C24X0_REG8	ALMYEAR;
-	S3C24X0_REG8	res9[3];
-	S3C24X0_REG8	RTCRST;
-	S3C24X0_REG8	res10[3];
-	S3C24X0_REG8	BCDSEC;
-	S3C24X0_REG8	res11[3];
-	S3C24X0_REG8	BCDMIN;
-	S3C24X0_REG8	res12[3];
-	S3C24X0_REG8	BCDHOUR;
-	S3C24X0_REG8	res13[3];
-	S3C24X0_REG8	BCDDATE;
-	S3C24X0_REG8	res14[3];
-	S3C24X0_REG8	BCDDAY;
-	S3C24X0_REG8	res15[3];
-	S3C24X0_REG8	BCDMON;
-	S3C24X0_REG8	res16[3];
-	S3C24X0_REG8	BCDYEAR;
-	S3C24X0_REG8	res17[3];
+    S3C24X0_REG8    res0[64];
+    S3C24X0_REG8    RTCCON;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    TICNT;
+    S3C24X0_REG8    res2[11];
+    S3C24X0_REG8    RTCALM;
+    S3C24X0_REG8    res3[3];
+    S3C24X0_REG8    ALMSEC;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG8    ALMMIN;
+    S3C24X0_REG8    res5[3];
+    S3C24X0_REG8    ALMHOUR;
+    S3C24X0_REG8    res6[3];
+    S3C24X0_REG8    ALMDATE;
+    S3C24X0_REG8    res7[3];
+    S3C24X0_REG8    ALMMON;
+    S3C24X0_REG8    res8[3];
+    S3C24X0_REG8    ALMYEAR;
+    S3C24X0_REG8    res9[3];
+    S3C24X0_REG8    RTCRST;
+    S3C24X0_REG8    res10[3];
+    S3C24X0_REG8    BCDSEC;
+    S3C24X0_REG8    res11[3];
+    S3C24X0_REG8    BCDMIN;
+    S3C24X0_REG8    res12[3];
+    S3C24X0_REG8    BCDHOUR;
+    S3C24X0_REG8    res13[3];
+    S3C24X0_REG8    BCDDATE;
+    S3C24X0_REG8    res14[3];
+    S3C24X0_REG8    BCDDAY;
+    S3C24X0_REG8    res15[3];
+    S3C24X0_REG8    BCDMON;
+    S3C24X0_REG8    res16[3];
+    S3C24X0_REG8    BCDYEAR;
+    S3C24X0_REG8    res17[3];
 #endif
 } /*__attribute__((__packed__))*/ S3C24X0_RTC;
 
 
 /* ADC (see manual chapter 16) */
 typedef struct {
-	S3C24X0_REG32	ADCCON;
-	S3C24X0_REG32	ADCDAT;
+    S3C24X0_REG32   ADCCON;
+    S3C24X0_REG32   ADCDAT;
 } /*__attribute__((__packed__))*/ S3C2400_ADC;
 
 
 /* ADC (see manual chapter 16) */
 typedef struct {
-	S3C24X0_REG32	ADCCON;
-	S3C24X0_REG32	ADCTSC;
-	S3C24X0_REG32	ADCDLY;
-	S3C24X0_REG32	ADCDAT0;
-	S3C24X0_REG32	ADCDAT1;
+    S3C24X0_REG32   ADCCON;
+    S3C24X0_REG32   ADCTSC;
+    S3C24X0_REG32   ADCDLY;
+    S3C24X0_REG32   ADCDAT0;
+    S3C24X0_REG32   ADCDAT1;
 } /*__attribute__((__packed__))*/ S3C2410_ADC;
 
 
 /* SPI (see manual chapter 22) */
 typedef struct {
-	S3C24X0_REG32	SPCON;
-	S3C24X0_REG32	SPSTA;
-	S3C24X0_REG32	SPPIN;
-	S3C24X0_REG32	SPPRE;
-	S3C24X0_REG32	SPTDAT;
-	S3C24X0_REG32	SPRDAT;
-	S3C24X0_REG32	res[2];
+    S3C24X0_REG32   SPCON;
+    S3C24X0_REG32   SPSTA;
+    S3C24X0_REG32   SPPIN;
+    S3C24X0_REG32   SPPRE;
+    S3C24X0_REG32   SPTDAT;
+    S3C24X0_REG32   SPRDAT;
+    S3C24X0_REG32   res[2];
 } __attribute__((__packed__)) S3C24X0_SPI_CHANNEL;
 
 typedef struct {
-	S3C24X0_SPI_CHANNEL	ch[S3C24X0_SPI_CHANNELS];
+    S3C24X0_SPI_CHANNEL ch[S3C24X0_SPI_CHANNELS];
 } /*__attribute__((__packed__))*/ S3C24X0_SPI;
 
 
 /* MMC INTERFACE (see S3C2400 manual chapter 19) */
 typedef struct {
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	MMCON;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	MMCRR;
-	S3C24X0_REG8	res3[3];
-	S3C24X0_REG8	MMFCON;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG8	MMSTA;
-	S3C24X0_REG16	res5;
-	S3C24X0_REG16	MMFSTA;
-	S3C24X0_REG8	res6[3];
-	S3C24X0_REG8	MMPRE;
-	S3C24X0_REG16	res7;
-	S3C24X0_REG16	MMLEN;
-	S3C24X0_REG8	res8[3];
-	S3C24X0_REG8	MMCR7;
-	S3C24X0_REG32	MMRSP[4];
-	S3C24X0_REG8	res9[3];
-	S3C24X0_REG8	MMCMD0;
-	S3C24X0_REG32	MMCMD1;
-	S3C24X0_REG16	res10;
-	S3C24X0_REG16	MMCR16;
-	S3C24X0_REG8	res11[3];
-	S3C24X0_REG8	MMDAT;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    MMCON;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    MMCRR;
+    S3C24X0_REG8    res3[3];
+    S3C24X0_REG8    MMFCON;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG8    MMSTA;
+    S3C24X0_REG16   res5;
+    S3C24X0_REG16   MMFSTA;
+    S3C24X0_REG8    res6[3];
+    S3C24X0_REG8    MMPRE;
+    S3C24X0_REG16   res7;
+    S3C24X0_REG16   MMLEN;
+    S3C24X0_REG8    res8[3];
+    S3C24X0_REG8    MMCR7;
+    S3C24X0_REG32   MMRSP[4];
+    S3C24X0_REG8    res9[3];
+    S3C24X0_REG8    MMCMD0;
+    S3C24X0_REG32   MMCMD1;
+    S3C24X0_REG16   res10;
+    S3C24X0_REG16   MMCR16;
+    S3C24X0_REG8    res11[3];
+    S3C24X0_REG8    MMDAT;
 #else
-	S3C24X0_REG8	MMCON;
-	S3C24X0_REG8	res1[3];
-	S3C24X0_REG8	MMCRR;
-	S3C24X0_REG8	res2[3];
-	S3C24X0_REG8	MMFCON;
-	S3C24X0_REG8	res3[3];
-	S3C24X0_REG8	MMSTA;
-	S3C24X0_REG8	res4[3];
-	S3C24X0_REG16	MMFSTA;
-	S3C24X0_REG16	res5;
-	S3C24X0_REG8	MMPRE;
-	S3C24X0_REG8	res6[3];
-	S3C24X0_REG16	MMLEN;
-	S3C24X0_REG16	res7;
-	S3C24X0_REG8	MMCR7;
-	S3C24X0_REG8	res8[3];
-	S3C24X0_REG32	MMRSP[4];
-	S3C24X0_REG8	MMCMD0;
-	S3C24X0_REG8	res9[3];
-	S3C24X0_REG32	MMCMD1;
-	S3C24X0_REG16	MMCR16;
-	S3C24X0_REG16	res10;
-	S3C24X0_REG8	MMDAT;
-	S3C24X0_REG8	res11[3];
+    S3C24X0_REG8    MMCON;
+    S3C24X0_REG8    res1[3];
+    S3C24X0_REG8    MMCRR;
+    S3C24X0_REG8    res2[3];
+    S3C24X0_REG8    MMFCON;
+    S3C24X0_REG8    res3[3];
+    S3C24X0_REG8    MMSTA;
+    S3C24X0_REG8    res4[3];
+    S3C24X0_REG16   MMFSTA;
+    S3C24X0_REG16   res5;
+    S3C24X0_REG8    MMPRE;
+    S3C24X0_REG8    res6[3];
+    S3C24X0_REG16   MMLEN;
+    S3C24X0_REG16   res7;
+    S3C24X0_REG8    MMCR7;
+    S3C24X0_REG8    res8[3];
+    S3C24X0_REG32   MMRSP[4];
+    S3C24X0_REG8    MMCMD0;
+    S3C24X0_REG8    res9[3];
+    S3C24X0_REG32   MMCMD1;
+    S3C24X0_REG16   MMCR16;
+    S3C24X0_REG16   res10;
+    S3C24X0_REG8    MMDAT;
+    S3C24X0_REG8    res11[3];
 #endif
 } /*__attribute__((__packed__))*/ S3C2400_MMC;
 
 
 /* SD INTERFACE (see S3C2410 manual chapter 19) */
 typedef struct {
-	S3C24X0_REG32	SDICON;
-	S3C24X0_REG32	SDIPRE;
-	S3C24X0_REG32	SDICARG;
-	S3C24X0_REG32	SDICCON;
-	S3C24X0_REG32	SDICSTA;
-	S3C24X0_REG32	SDIRSP0;
-	S3C24X0_REG32	SDIRSP1;
-	S3C24X0_REG32	SDIRSP2;
-	S3C24X0_REG32	SDIRSP3;
-	S3C24X0_REG32	SDIDTIMER;
-	S3C24X0_REG32	SDIBSIZE;
-	S3C24X0_REG32	SDIDCON;
-	S3C24X0_REG32	SDIDCNT;
-	S3C24X0_REG32	SDIDSTA;
-	S3C24X0_REG32	SDIFSTA;
+    S3C24X0_REG32   SDICON;
+    S3C24X0_REG32   SDIPRE;
+    S3C24X0_REG32   SDICARG;
+    S3C24X0_REG32   SDICCON;
+    S3C24X0_REG32   SDICSTA;
+    S3C24X0_REG32   SDIRSP0;
+    S3C24X0_REG32   SDIRSP1;
+    S3C24X0_REG32   SDIRSP2;
+    S3C24X0_REG32   SDIRSP3;
+    S3C24X0_REG32   SDIDTIMER;
+    S3C24X0_REG32   SDIBSIZE;
+    S3C24X0_REG32   SDIDCON;
+    S3C24X0_REG32   SDIDCNT;
+    S3C24X0_REG32   SDIDSTA;
+    S3C24X0_REG32   SDIFSTA;
 #ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res[3];
-	S3C24X0_REG8	SDIDAT;
+    S3C24X0_REG8    res[3];
+    S3C24X0_REG8    SDIDAT;
 #else
-	S3C24X0_REG8	SDIDAT;
-	S3C24X0_REG8	res[3];
+    S3C24X0_REG8    SDIDAT;
+    S3C24X0_REG8    res[3];
 #endif
-	S3C24X0_REG32	SDIIMSK;
+    S3C24X0_REG32   SDIIMSK;
 } /*__attribute__((__packed__))*/ S3C2410_SDI;
 
 
 #if 0
 /* Memory control */
-#define rBWSCON			(*(volatile unsigned *)0x48000000)
-#define rBANKCON0		(*(volatile unsigned *)0x48000004)
-#define rBANKCON1		(*(volatile unsigned *)0x48000008)
-#define rBANKCON2		(*(volatile unsigned *)0x4800000C)
-#define rBANKCON3		(*(volatile unsigned *)0x48000010)
-#define rBANKCON4		(*(volatile unsigned *)0x48000014)
-#define rBANKCON5		(*(volatile unsigned *)0x48000018)
-#define rBANKCON6		(*(volatile unsigned *)0x4800001C)
-#define rBANKCON7		(*(volatile unsigned *)0x48000020)
-#define rREFRESH		(*(volatile unsigned *)0x48000024)
-#define rBANKSIZE		(*(volatile unsigned *)0x48000028)
-#define rMRSRB6			(*(volatile unsigned *)0x4800002C)
-#define rMRSRB7			(*(volatile unsigned *)0x48000030)
+#define rBWSCON         (*(volatile unsigned *)0x48000000)
+#define rBANKCON0       (*(volatile unsigned *)0x48000004)
+#define rBANKCON1       (*(volatile unsigned *)0x48000008)
+#define rBANKCON2       (*(volatile unsigned *)0x4800000C)
+#define rBANKCON3       (*(volatile unsigned *)0x48000010)
+#define rBANKCON4       (*(volatile unsigned *)0x48000014)
+#define rBANKCON5       (*(volatile unsigned *)0x48000018)
+#define rBANKCON6       (*(volatile unsigned *)0x4800001C)
+#define rBANKCON7       (*(volatile unsigned *)0x48000020)
+#define rREFRESH        (*(volatile unsigned *)0x48000024)
+#define rBANKSIZE       (*(volatile unsigned *)0x48000028)
+#define rMRSRB6         (*(volatile unsigned *)0x4800002C)
+#define rMRSRB7         (*(volatile unsigned *)0x48000030)
 
 
 /* USB HOST */
-#define rHcRevision		(*(volatile unsigned *)0x49000000)
-#define rHcControl		(*(volatile unsigned *)0x49000004)
-#define rHcCommonStatus		(*(volatile unsigned *)0x49000008)
-#define rHcInterruptStatus	(*(volatile unsigned *)0x4900000C)
-#define rHcInterruptEnable	(*(volatile unsigned *)0x49000010)
-#define rHcInterruptDisable	(*(volatile unsigned *)0x49000014)
-#define rHcHCCA			(*(volatile unsigned *)0x49000018)
-#define rHcPeriodCuttendED	(*(volatile unsigned *)0x4900001C)
-#define rHcControlHeadED	(*(volatile unsigned *)0x49000020)
-#define rHcControlCurrentED	(*(volatile unsigned *)0x49000024)
-#define rHcBulkHeadED		(*(volatile unsigned *)0x49000028)
-#define rHcBuldCurrentED	(*(volatile unsigned *)0x4900002C)
-#define rHcDoneHead		(*(volatile unsigned *)0x49000030)
-#define rHcRmInterval		(*(volatile unsigned *)0x49000034)
-#define rHcFmRemaining		(*(volatile unsigned *)0x49000038)
-#define rHcFmNumber		(*(volatile unsigned *)0x4900003C)
-#define rHcPeriodicStart	(*(volatile unsigned *)0x49000040)
-#define rHcLSThreshold		(*(volatile unsigned *)0x49000044)
-#define rHcRhDescriptorA	(*(volatile unsigned *)0x49000048)
-#define rHcRhDescriptorB	(*(volatile unsigned *)0x4900004C)
-#define rHcRhStatus		(*(volatile unsigned *)0x49000050)
-#define rHcRhPortStatus1	(*(volatile unsigned *)0x49000054)
-#define rHcRhPortStatus2	(*(volatile unsigned *)0x49000058)
+#define rHcRevision     (*(volatile unsigned *)0x49000000)
+#define rHcControl      (*(volatile unsigned *)0x49000004)
+#define rHcCommonStatus     (*(volatile unsigned *)0x49000008)
+#define rHcInterruptStatus  (*(volatile unsigned *)0x4900000C)
+#define rHcInterruptEnable  (*(volatile unsigned *)0x49000010)
+#define rHcInterruptDisable (*(volatile unsigned *)0x49000014)
+#define rHcHCCA         (*(volatile unsigned *)0x49000018)
+#define rHcPeriodCuttendED  (*(volatile unsigned *)0x4900001C)
+#define rHcControlHeadED    (*(volatile unsigned *)0x49000020)
+#define rHcControlCurrentED (*(volatile unsigned *)0x49000024)
+#define rHcBulkHeadED       (*(volatile unsigned *)0x49000028)
+#define rHcBuldCurrentED    (*(volatile unsigned *)0x4900002C)
+#define rHcDoneHead     (*(volatile unsigned *)0x49000030)
+#define rHcRmInterval       (*(volatile unsigned *)0x49000034)
+#define rHcFmRemaining      (*(volatile unsigned *)0x49000038)
+#define rHcFmNumber     (*(volatile unsigned *)0x4900003C)
+#define rHcPeriodicStart    (*(volatile unsigned *)0x49000040)
+#define rHcLSThreshold      (*(volatile unsigned *)0x49000044)
+#define rHcRhDescriptorA    (*(volatile unsigned *)0x49000048)
+#define rHcRhDescriptorB    (*(volatile unsigned *)0x4900004C)
+#define rHcRhStatus     (*(volatile unsigned *)0x49000050)
+#define rHcRhPortStatus1    (*(volatile unsigned *)0x49000054)
+#define rHcRhPortStatus2    (*(volatile unsigned *)0x49000058)
 
 
 /* INTERRUPT */
-#define rSRCPND			(*(volatile unsigned *)0x4A000000)
-#define rINTMOD			(*(volatile unsigned *)0x4A000004)
-#define rINTMSK			(*(volatile unsigned *)0x4A000008)
-#define rPRIORITY		(*(volatile unsigned *)0x4A00000C)
-#define rINTPND			(*(volatile unsigned *)0x4A000010)
-#define rINTOFFSET		(*(volatile unsigned *)0x4A000014)
-#define rSUBSRCPND		(*(volatile unsigned *)0x4A000018)
-#define rINTSUBMSK		(*(volatile unsigned *)0x4A00001C)
+#define rSRCPND         (*(volatile unsigned *)0x4A000000)
+#define rINTMOD         (*(volatile unsigned *)0x4A000004)
+#define rINTMSK         (*(volatile unsigned *)0x4A000008)
+#define rPRIORITY       (*(volatile unsigned *)0x4A00000C)
+#define rINTPND         (*(volatile unsigned *)0x4A000010)
+#define rINTOFFSET      (*(volatile unsigned *)0x4A000014)
+#define rSUBSRCPND      (*(volatile unsigned *)0x4A000018)
+#define rINTSUBMSK      (*(volatile unsigned *)0x4A00001C)
 
 
 /* DMA */
-#define rDISRC0			(*(volatile unsigned *)0x4B000000)
-#define rDISRCC0		(*(volatile unsigned *)0x4B000004)
-#define rDIDST0			(*(volatile unsigned *)0x4B000008)
-#define rDIDSTC0		(*(volatile unsigned *)0x4B00000C)
-#define rDCON0			(*(volatile unsigned *)0x4B000010)
-#define rDSTAT0			(*(volatile unsigned *)0x4B000014)
-#define rDCSRC0			(*(volatile unsigned *)0x4B000018)
-#define rDCDST0			(*(volatile unsigned *)0x4B00001C)
-#define rDMASKTRIG0		(*(volatile unsigned *)0x4B000020)
-#define rDISRC1			(*(volatile unsigned *)0x4B000040)
-#define rDISRCC1		(*(volatile unsigned *)0x4B000044)
-#define rDIDST1			(*(volatile unsigned *)0x4B000048)
-#define rDIDSTC1		(*(volatile unsigned *)0x4B00004C)
-#define rDCON1			(*(volatile unsigned *)0x4B000050)
-#define rDSTAT1			(*(volatile unsigned *)0x4B000054)
-#define rDCSRC1			(*(volatile unsigned *)0x4B000058)
-#define rDCDST1			(*(volatile unsigned *)0x4B00005C)
-#define rDMASKTRIG1		(*(volatile unsigned *)0x4B000060)
-#define rDISRC2			(*(volatile unsigned *)0x4B000080)
-#define rDISRCC2		(*(volatile unsigned *)0x4B000084)
-#define rDIDST2			(*(volatile unsigned *)0x4B000088)
-#define rDIDSTC2		(*(volatile unsigned *)0x4B00008C)
-#define rDCON2			(*(volatile unsigned *)0x4B000090)
-#define rDSTAT2			(*(volatile unsigned *)0x4B000094)
-#define rDCSRC2			(*(volatile unsigned *)0x4B000098)
-#define rDCDST2			(*(volatile unsigned *)0x4B00009C)
-#define rDMASKTRIG2		(*(volatile unsigned *)0x4B0000A0)
-#define rDISRC3			(*(volatile unsigned *)0x4B0000C0)
-#define rDISRCC3		(*(volatile unsigned *)0x4B0000C4)
-#define rDIDST3			(*(volatile unsigned *)0x4B0000C8)
-#define rDIDSTC3		(*(volatile unsigned *)0x4B0000CC)
-#define rDCON3			(*(volatile unsigned *)0x4B0000D0)
-#define rDSTAT3			(*(volatile unsigned *)0x4B0000D4)
-#define rDCSRC3			(*(volatile unsigned *)0x4B0000D8)
-#define rDCDST3			(*(volatile unsigned *)0x4B0000DC)
-#define rDMASKTRIG3		(*(volatile unsigned *)0x4B0000E0)
+#define rDISRC0         (*(volatile unsigned *)0x4B000000)
+#define rDISRCC0        (*(volatile unsigned *)0x4B000004)
+#define rDIDST0         (*(volatile unsigned *)0x4B000008)
+#define rDIDSTC0        (*(volatile unsigned *)0x4B00000C)
+#define rDCON0          (*(volatile unsigned *)0x4B000010)
+#define rDSTAT0         (*(volatile unsigned *)0x4B000014)
+#define rDCSRC0         (*(volatile unsigned *)0x4B000018)
+#define rDCDST0         (*(volatile unsigned *)0x4B00001C)
+#define rDMASKTRIG0     (*(volatile unsigned *)0x4B000020)
+#define rDISRC1         (*(volatile unsigned *)0x4B000040)
+#define rDISRCC1        (*(volatile unsigned *)0x4B000044)
+#define rDIDST1         (*(volatile unsigned *)0x4B000048)
+#define rDIDSTC1        (*(volatile unsigned *)0x4B00004C)
+#define rDCON1          (*(volatile unsigned *)0x4B000050)
+#define rDSTAT1         (*(volatile unsigned *)0x4B000054)
+#define rDCSRC1         (*(volatile unsigned *)0x4B000058)
+#define rDCDST1         (*(volatile unsigned *)0x4B00005C)
+#define rDMASKTRIG1     (*(volatile unsigned *)0x4B000060)
+#define rDISRC2         (*(volatile unsigned *)0x4B000080)
+#define rDISRCC2        (*(volatile unsigned *)0x4B000084)
+#define rDIDST2         (*(volatile unsigned *)0x4B000088)
+#define rDIDSTC2        (*(volatile unsigned *)0x4B00008C)
+#define rDCON2          (*(volatile unsigned *)0x4B000090)
+#define rDSTAT2         (*(volatile unsigned *)0x4B000094)
+#define rDCSRC2         (*(volatile unsigned *)0x4B000098)
+#define rDCDST2         (*(volatile unsigned *)0x4B00009C)
+#define rDMASKTRIG2     (*(volatile unsigned *)0x4B0000A0)
+#define rDISRC3         (*(volatile unsigned *)0x4B0000C0)
+#define rDISRCC3        (*(volatile unsigned *)0x4B0000C4)
+#define rDIDST3         (*(volatile unsigned *)0x4B0000C8)
+#define rDIDSTC3        (*(volatile unsigned *)0x4B0000CC)
+#define rDCON3          (*(volatile unsigned *)0x4B0000D0)
+#define rDSTAT3         (*(volatile unsigned *)0x4B0000D4)
+#define rDCSRC3         (*(volatile unsigned *)0x4B0000D8)
+#define rDCDST3         (*(volatile unsigned *)0x4B0000DC)
+#define rDMASKTRIG3     (*(volatile unsigned *)0x4B0000E0)
 
 
 /* CLOCK & POWER MANAGEMENT */
-#define rLOCKTIME		(*(volatile unsigned *)0x4C000000)
-#define rMPLLCON		(*(volatile unsigned *)0x4C000004)
-#define rUPLLCON		(*(volatile unsigned *)0x4C000008)
-#define rCLKCON			(*(volatile unsigned *)0x4C00000C)
-#define rCLKSLOW		(*(volatile unsigned *)0x4C000010)
-#define rCLKDIVN		(*(volatile unsigned *)0x4C000014)
+#define rLOCKTIME       (*(volatile unsigned *)0x4C000000)
+#define rMPLLCON        (*(volatile unsigned *)0x4C000004)
+#define rUPLLCON        (*(volatile unsigned *)0x4C000008)
+#define rCLKCON         (*(volatile unsigned *)0x4C00000C)
+#define rCLKSLOW        (*(volatile unsigned *)0x4C000010)
+#define rCLKDIVN        (*(volatile unsigned *)0x4C000014)
 
 
 /* LCD CONTROLLER */
-#define rLCDCON1		(*(volatile unsigned *)0x4D000000)
-#define rLCDCON2		(*(volatile unsigned *)0x4D000004)
-#define rLCDCON3		(*(volatile unsigned *)0x4D000008)
-#define rLCDCON4		(*(volatile unsigned *)0x4D00000C)
-#define rLCDCON5		(*(volatile unsigned *)0x4D000010)
-#define rLCDSADDR1		(*(volatile unsigned *)0x4D000014)
-#define rLCDSADDR2		(*(volatile unsigned *)0x4D000018)
-#define rLCDSADDR3		(*(volatile unsigned *)0x4D00001C)
-#define rREDLUT			(*(volatile unsigned *)0x4D000020)
-#define rGREENLUT		(*(volatile unsigned *)0x4D000024)
-#define rBLUELUT		(*(volatile unsigned *)0x4D000028)
-#define rDITHMODE		(*(volatile unsigned *)0x4D00004C)
-#define rTPAL			(*(volatile unsigned *)0x4D000050)
-#define rLCDINTPND		(*(volatile unsigned *)0x4D000054)
-#define rLCDSRCPND		(*(volatile unsigned *)0x4D000058)
-#define rLCDINTMSK		(*(volatile unsigned *)0x4D00005C)
+#define rLCDCON1        (*(volatile unsigned *)0x4D000000)
+#define rLCDCON2        (*(volatile unsigned *)0x4D000004)
+#define rLCDCON3        (*(volatile unsigned *)0x4D000008)
+#define rLCDCON4        (*(volatile unsigned *)0x4D00000C)
+#define rLCDCON5        (*(volatile unsigned *)0x4D000010)
+#define rLCDSADDR1      (*(volatile unsigned *)0x4D000014)
+#define rLCDSADDR2      (*(volatile unsigned *)0x4D000018)
+#define rLCDSADDR3      (*(volatile unsigned *)0x4D00001C)
+#define rREDLUT         (*(volatile unsigned *)0x4D000020)
+#define rGREENLUT       (*(volatile unsigned *)0x4D000024)
+#define rBLUELUT        (*(volatile unsigned *)0x4D000028)
+#define rDITHMODE       (*(volatile unsigned *)0x4D00004C)
+#define rTPAL           (*(volatile unsigned *)0x4D000050)
+#define rLCDINTPND      (*(volatile unsigned *)0x4D000054)
+#define rLCDSRCPND      (*(volatile unsigned *)0x4D000058)
+#define rLCDINTMSK      (*(volatile unsigned *)0x4D00005C)
 
 
 /* NAND FLASH */
-#define rNFCONF			(*(volatile unsigned *)0x4E000000)
-#define rNFCMD			(*(volatile unsigned *)0x4E000004)
-#define rNFADDR			(*(volatile unsigned *)0x4E000008)
-#define rNFDATA			(*(volatile unsigned *)0x4E00000C)
-#define rNFSTAT			(*(volatile unsigned *)0x4E000010)
-#define rNFECC			(*(volatile unsigned *)0x4E000014)
+#define rNFCONF         (*(volatile unsigned *)0x4E000000)
+#define rNFCMD          (*(volatile unsigned *)0x4E000004)
+#define rNFADDR         (*(volatile unsigned *)0x4E000008)
+#define rNFDATA         (*(volatile unsigned *)0x4E00000C)
+#define rNFSTAT         (*(volatile unsigned *)0x4E000010)
+#define rNFECC          (*(volatile unsigned *)0x4E000014)
 
 
 /* UART */
-#define rULCON0			(*(volatile unsigned *)0x50000000)
-#define rUCON0			(*(volatile unsigned *)0x50000004)
-#define rUFCON0			(*(volatile unsigned *)0x50000008)
-#define rUMCON0			(*(volatile unsigned *)0x5000000C)
-#define rUTRSTAT0		(*(volatile unsigned *)0x50000010)
-#define rUERSTAT0		(*(volatile unsigned *)0x50000014)
-#define rUFSTAT0		(*(volatile unsigned *)0x50000018)
-#define rUMSTAT0		(*(volatile unsigned *)0x5000001C)
-#define rUBRDIV0		(*(volatile unsigned *)0x50000028)
-
-#define rULCON1			(*(volatile unsigned *)0x50004000)
-#define rUCON1			(*(volatile unsigned *)0x50004004)
-#define rUFCON1			(*(volatile unsigned *)0x50004008)
-#define rUMCON1			(*(volatile unsigned *)0x5000400C)
-#define rUTRSTAT1		(*(volatile unsigned *)0x50004010)
-#define rUERSTAT1		(*(volatile unsigned *)0x50004014)
-#define rUFSTAT1		(*(volatile unsigned *)0x50004018)
-#define rUMSTAT1		(*(volatile unsigned *)0x5000401C)
-#define rUBRDIV1		(*(volatile unsigned *)0x50004028)
-
-#define rULCON2			(*(volatile unsigned *)0x50008000)
-#define rUCON2			(*(volatile unsigned *)0x50008004)
-#define rUFCON2			(*(volatile unsigned *)0x50008008)
-#define rUTRSTAT2		(*(volatile unsigned *)0x50008010)
-#define rUERSTAT2		(*(volatile unsigned *)0x50008014)
-#define rUFSTAT2		(*(volatile unsigned *)0x50008018)
-#define rUBRDIV2		(*(volatile unsigned *)0x50008028)
+#define rULCON0         (*(volatile unsigned *)0x50000000)
+#define rUCON0          (*(volatile unsigned *)0x50000004)
+#define rUFCON0         (*(volatile unsigned *)0x50000008)
+#define rUMCON0         (*(volatile unsigned *)0x5000000C)
+#define rUTRSTAT0       (*(volatile unsigned *)0x50000010)
+#define rUERSTAT0       (*(volatile unsigned *)0x50000014)
+#define rUFSTAT0        (*(volatile unsigned *)0x50000018)
+#define rUMSTAT0        (*(volatile unsigned *)0x5000001C)
+#define rUBRDIV0        (*(volatile unsigned *)0x50000028)
+
+#define rULCON1         (*(volatile unsigned *)0x50004000)
+#define rUCON1          (*(volatile unsigned *)0x50004004)
+#define rUFCON1         (*(volatile unsigned *)0x50004008)
+#define rUMCON1         (*(volatile unsigned *)0x5000400C)
+#define rUTRSTAT1       (*(volatile unsigned *)0x50004010)
+#define rUERSTAT1       (*(volatile unsigned *)0x50004014)
+#define rUFSTAT1        (*(volatile unsigned *)0x50004018)
+#define rUMSTAT1        (*(volatile unsigned *)0x5000401C)
+#define rUBRDIV1        (*(volatile unsigned *)0x50004028)
+
+#define rULCON2         (*(volatile unsigned *)0x50008000)
+#define rUCON2          (*(volatile unsigned *)0x50008004)
+#define rUFCON2         (*(volatile unsigned *)0x50008008)
+#define rUTRSTAT2       (*(volatile unsigned *)0x50008010)
+#define rUERSTAT2       (*(volatile unsigned *)0x50008014)
+#define rUFSTAT2        (*(volatile unsigned *)0x50008018)
+#define rUBRDIV2        (*(volatile unsigned *)0x50008028)
 
 #ifdef __BIG_ENDIAN
-#define rUTXH0			(*(volatile unsigned char *)0x50000023)
-#define rURXH0			(*(volatile unsigned char *)0x50000027)
-#define rUTXH1			(*(volatile unsigned char *)0x50004023)
-#define rURXH1			(*(volatile unsigned char *)0x50004027)
-#define rUTXH2			(*(volatile unsigned char *)0x50008023)
-#define rURXH2			(*(volatile unsigned char *)0x50008027)
-
-#define WrUTXH0(ch)		(*(volatile unsigned char *)0x50000023)=(unsigned char)(ch)
-#define RdURXH0()		(*(volatile unsigned char *)0x50000027)
-#define WrUTXH1(ch)		(*(volatile unsigned char *)0x50004023)=(unsigned char)(ch)
-#define RdURXH1()		(*(volatile unsigned char *)0x50004027)
-#define WrUTXH2(ch)		(*(volatile unsigned char *)0x50008023)=(unsigned char)(ch)
-#define RdURXH2()		(*(volatile unsigned char *)0x50008027)
-
-#define UTXH0			(0x50000020+3)  /* byte_access address by DMA */
-#define URXH0			(0x50000024+3)
-#define UTXH1			(0x50004020+3)
-#define URXH1			(0x50004024+3)
-#define UTXH2			(0x50008020+3)
-#define URXH2			(0x50008024+3)
+#define rUTXH0          (*(volatile unsigned char *)0x50000023)
+#define rURXH0          (*(volatile unsigned char *)0x50000027)
+#define rUTXH1          (*(volatile unsigned char *)0x50004023)
+#define rURXH1          (*(volatile unsigned char *)0x50004027)
+#define rUTXH2          (*(volatile unsigned char *)0x50008023)
+#define rURXH2          (*(volatile unsigned char *)0x50008027)
+
+#define WrUTXH0(ch)     (*(volatile unsigned char *)0x50000023)=(unsigned char)(ch)
+#define RdURXH0()       (*(volatile unsigned char *)0x50000027)
+#define WrUTXH1(ch)     (*(volatile unsigned char *)0x50004023)=(unsigned char)(ch)
+#define RdURXH1()       (*(volatile unsigned char *)0x50004027)
+#define WrUTXH2(ch)     (*(volatile unsigned char *)0x50008023)=(unsigned char)(ch)
+#define RdURXH2()       (*(volatile unsigned char *)0x50008027)
+
+#define UTXH0           (0x50000020+3)  /* byte_access address by DMA */
+#define URXH0           (0x50000024+3)
+#define UTXH1           (0x50004020+3)
+#define URXH1           (0x50004024+3)
+#define UTXH2           (0x50008020+3)
+#define URXH2           (0x50008024+3)
 
 #else /* Little Endian */
-#define rUTXH0			(*(volatile unsigned char *)0x50000020)
-#define rURXH0			(*(volatile unsigned char *)0x50000024)
-#define rUTXH1			(*(volatile unsigned char *)0x50004020)
-#define rURXH1			(*(volatile unsigned char *)0x50004024)
-#define rUTXH2			(*(volatile unsigned char *)0x50008020)
-#define rURXH2			(*(volatile unsigned char *)0x50008024)
-
-#define WrUTXH0(ch)		(*(volatile unsigned char *)0x50000020)=(unsigned char)(ch)
-#define RdURXH0()		(*(volatile unsigned char *)0x50000024)
-#define WrUTXH1(ch)		(*(volatile unsigned char *)0x50004020)=(unsigned char)(ch)
-#define RdURXH1()		(*(volatile unsigned char *)0x50004024)
-#define WrUTXH2(ch)		(*(volatile unsigned char *)0x50008020)=(unsigned char)(ch)
-#define RdURXH2()		(*(volatile unsigned char *)0x50008024)
-
-#define UTXH0			(0x50000020)    /* byte_access address by DMA */
-#define URXH0			(0x50000024)
-#define UTXH1			(0x50004020)
-#define URXH1			(0x50004024)
-#define UTXH2			(0x50008020)
-#define URXH2			(0x50008024)
+#define rUTXH0          (*(volatile unsigned char *)0x50000020)
+#define rURXH0          (*(volatile unsigned char *)0x50000024)
+#define rUTXH1          (*(volatile unsigned char *)0x50004020)
+#define rURXH1          (*(volatile unsigned char *)0x50004024)
+#define rUTXH2          (*(volatile unsigned char *)0x50008020)
+#define rURXH2          (*(volatile unsigned char *)0x50008024)
+
+#define WrUTXH0(ch)     (*(volatile unsigned char *)0x50000020)=(unsigned char)(ch)
+#define RdURXH0()       (*(volatile unsigned char *)0x50000024)
+#define WrUTXH1(ch)     (*(volatile unsigned char *)0x50004020)=(unsigned char)(ch)
+#define RdURXH1()       (*(volatile unsigned char *)0x50004024)
+#define WrUTXH2(ch)     (*(volatile unsigned char *)0x50008020)=(unsigned char)(ch)
+#define RdURXH2()       (*(volatile unsigned char *)0x50008024)
+
+#define UTXH0           (0x50000020)    /* byte_access address by DMA */
+#define URXH0           (0x50000024)
+#define UTXH1           (0x50004020)
+#define URXH1           (0x50004024)
+#define UTXH2           (0x50008020)
+#define URXH2           (0x50008024)
 #endif
 
 
 /* PWM TIMER */
-#define rTCFG0			(*(volatile unsigned *)0x51000000)
-#define rTCFG1			(*(volatile unsigned *)0x51000004)
-#define rTCON			(*(volatile unsigned *)0x51000008)
-#define rTCNTB0			(*(volatile unsigned *)0x5100000C)
-#define rTCMPB0			(*(volatile unsigned *)0x51000010)
-#define rTCNTO0			(*(volatile unsigned *)0x51000014)
-#define rTCNTB1			(*(volatile unsigned *)0x51000018)
-#define rTCMPB1			(*(volatile unsigned *)0x5100001C)
-#define rTCNTO1			(*(volatile unsigned *)0x51000020)
-#define rTCNTB2			(*(volatile unsigned *)0x51000024)
-#define rTCMPB2			(*(volatile unsigned *)0x51000028)
-#define rTCNTO2			(*(volatile unsigned *)0x5100002C)
-#define rTCNTB3			(*(volatile unsigned *)0x51000030)
-#define rTCMPB3			(*(volatile unsigned *)0x51000034)
-#define rTCNTO3			(*(volatile unsigned *)0x51000038)
-#define rTCNTB4			(*(volatile unsigned *)0x5100003C)
-#define rTCNTO4			(*(volatile unsigned *)0x51000040)
+#define rTCFG0          (*(volatile unsigned *)0x51000000)
+#define rTCFG1          (*(volatile unsigned *)0x51000004)
+#define rTCON           (*(volatile unsigned *)0x51000008)
+#define rTCNTB0         (*(volatile unsigned *)0x5100000C)
+#define rTCMPB0         (*(volatile unsigned *)0x51000010)
+#define rTCNTO0         (*(volatile unsigned *)0x51000014)
+#define rTCNTB1         (*(volatile unsigned *)0x51000018)
+#define rTCMPB1         (*(volatile unsigned *)0x5100001C)
+#define rTCNTO1         (*(volatile unsigned *)0x51000020)
+#define rTCNTB2         (*(volatile unsigned *)0x51000024)
+#define rTCMPB2         (*(volatile unsigned *)0x51000028)
+#define rTCNTO2         (*(volatile unsigned *)0x5100002C)
+#define rTCNTB3         (*(volatile unsigned *)0x51000030)
+#define rTCMPB3         (*(volatile unsigned *)0x51000034)
+#define rTCNTO3         (*(volatile unsigned *)0x51000038)
+#define rTCNTB4         (*(volatile unsigned *)0x5100003C)
+#define rTCNTO4         (*(volatile unsigned *)0x51000040)
 
 
 /* USB DEVICE */
 #ifdef __BIG_ENDIAN
-#define rFUNC_ADDR_REG		(*(volatile unsigned char *)0x52000143)
-#define rPWR_REG		(*(volatile unsigned char *)0x52000147)
-#define rEP_INT_REG		(*(volatile unsigned char *)0x5200014B)
-#define rUSB_INT_REG		(*(volatile unsigned char *)0x5200015B)
-#define rEP_INT_EN_REG		(*(volatile unsigned char *)0x5200015F)
-#define rUSB_INT_EN_REG		(*(volatile unsigned char *)0x5200016F)
-#define rFRAME_NUM1_REG		(*(volatile unsigned char *)0x52000173)
-#define rFRAME_NUM2_REG		(*(volatile unsigned char *)0x52000177)
-#define rINDEX_REG		(*(volatile unsigned char *)0x5200017B)
-#define rMAXP_REG		(*(volatile unsigned char *)0x52000183)
-#define rEP0_CSR		(*(volatile unsigned char *)0x52000187)
-#define rIN_CSR1_REG		(*(volatile unsigned char *)0x52000187)
-#define rIN_CSR2_REG		(*(volatile unsigned char *)0x5200018B)
-#define rOUT_CSR1_REG		(*(volatile unsigned char *)0x52000193)
-#define rOUT_CSR2_REG		(*(volatile unsigned char *)0x52000197)
-#define rOUT_FIFO_CNT1_REG	(*(volatile unsigned char *)0x5200019B)
-#define rOUT_FIFO_CNT2_REG	(*(volatile unsigned char *)0x5200019F)
-#define rEP0_FIFO		(*(volatile unsigned char *)0x520001C3)
-#define rEP1_FIFO		(*(volatile unsigned char *)0x520001C7)
-#define rEP2_FIFO		(*(volatile unsigned char *)0x520001CB)
-#define rEP3_FIFO		(*(volatile unsigned char *)0x520001CF)
-#define rEP4_FIFO		(*(volatile unsigned char *)0x520001D3)
-#define rEP1_DMA_CON		(*(volatile unsigned char *)0x52000203)
-#define rEP1_DMA_UNIT		(*(volatile unsigned char *)0x52000207)
-#define rEP1_DMA_FIFO		(*(volatile unsigned char *)0x5200020B)
-#define rEP1_DMA_TX_LO		(*(volatile unsigned char *)0x5200020F)
-#define rEP1_DMA_TX_MD		(*(volatile unsigned char *)0x52000213)
-#define rEP1_DMA_TX_HI		(*(volatile unsigned char *)0x52000217)
-#define rEP2_DMA_CON		(*(volatile unsigned char *)0x5200021B)
-#define rEP2_DMA_UNIT		(*(volatile unsigned char *)0x5200021F)
-#define rEP2_DMA_FIFO		(*(volatile unsigned char *)0x52000223)
-#define rEP2_DMA_TX_LO		(*(volatile unsigned char *)0x52000227)
-#define rEP2_DMA_TX_MD		(*(volatile unsigned char *)0x5200022B)
-#define rEP2_DMA_TX_HI		(*(volatile unsigned char *)0x5200022F)
-#define rEP3_DMA_CON		(*(volatile unsigned char *)0x52000243)
-#define rEP3_DMA_UNIT		(*(volatile unsigned char *)0x52000247)
-#define rEP3_DMA_FIFO		(*(volatile unsigned char *)0x5200024B)
-#define rEP3_DMA_TX_LO		(*(volatile unsigned char *)0x5200024F)
-#define rEP3_DMA_TX_MD		(*(volatile unsigned char *)0x52000253)
-#define rEP3_DMA_TX_HI		(*(volatile unsigned char *)0x52000257)
-#define rEP4_DMA_CON		(*(volatile unsigned char *)0x5200025B)
-#define rEP4_DMA_UNIT		(*(volatile unsigned char *)0x5200025F)
-#define rEP4_DMA_FIFO		(*(volatile unsigned char *)0x52000263)
-#define rEP4_DMA_TX_LO		(*(volatile unsigned char *)0x52000267)
-#define rEP4_DMA_TX_MD		(*(volatile unsigned char *)0x5200026B)
-#define rEP4_DMA_TX_HI		(*(volatile unsigned char *)0x5200026F)
+#define rFUNC_ADDR_REG      (*(volatile unsigned char *)0x52000143)
+#define rPWR_REG        (*(volatile unsigned char *)0x52000147)
+#define rEP_INT_REG     (*(volatile unsigned char *)0x5200014B)
+#define rUSB_INT_REG        (*(volatile unsigned char *)0x5200015B)
+#define rEP_INT_EN_REG      (*(volatile unsigned char *)0x5200015F)
+#define rUSB_INT_EN_REG     (*(volatile unsigned char *)0x5200016F)
+#define rFRAME_NUM1_REG     (*(volatile unsigned char *)0x52000173)
+#define rFRAME_NUM2_REG     (*(volatile unsigned char *)0x52000177)
+#define rINDEX_REG      (*(volatile unsigned char *)0x5200017B)
+#define rMAXP_REG       (*(volatile unsigned char *)0x52000183)
+#define rEP0_CSR        (*(volatile unsigned char *)0x52000187)
+#define rIN_CSR1_REG        (*(volatile unsigned char *)0x52000187)
+#define rIN_CSR2_REG        (*(volatile unsigned char *)0x5200018B)
+#define rOUT_CSR1_REG       (*(volatile unsigned char *)0x52000193)
+#define rOUT_CSR2_REG       (*(volatile unsigned char *)0x52000197)
+#define rOUT_FIFO_CNT1_REG  (*(volatile unsigned char *)0x5200019B)
+#define rOUT_FIFO_CNT2_REG  (*(volatile unsigned char *)0x5200019F)
+#define rEP0_FIFO       (*(volatile unsigned char *)0x520001C3)
+#define rEP1_FIFO       (*(volatile unsigned char *)0x520001C7)
+#define rEP2_FIFO       (*(volatile unsigned char *)0x520001CB)
+#define rEP3_FIFO       (*(volatile unsigned char *)0x520001CF)
+#define rEP4_FIFO       (*(volatile unsigned char *)0x520001D3)
+#define rEP1_DMA_CON        (*(volatile unsigned char *)0x52000203)
+#define rEP1_DMA_UNIT       (*(volatile unsigned char *)0x52000207)
+#define rEP1_DMA_FIFO       (*(volatile unsigned char *)0x5200020B)
+#define rEP1_DMA_TX_LO      (*(volatile unsigned char *)0x5200020F)
+#define rEP1_DMA_TX_MD      (*(volatile unsigned char *)0x52000213)
+#define rEP1_DMA_TX_HI      (*(volatile unsigned char *)0x52000217)
+#define rEP2_DMA_CON        (*(volatile unsigned char *)0x5200021B)
+#define rEP2_DMA_UNIT       (*(volatile unsigned char *)0x5200021F)
+#define rEP2_DMA_FIFO       (*(volatile unsigned char *)0x52000223)
+#define rEP2_DMA_TX_LO      (*(volatile unsigned char *)0x52000227)
+#define rEP2_DMA_TX_MD      (*(volatile unsigned char *)0x5200022B)
+#define rEP2_DMA_TX_HI      (*(volatile unsigned char *)0x5200022F)
+#define rEP3_DMA_CON        (*(volatile unsigned char *)0x52000243)
+#define rEP3_DMA_UNIT       (*(volatile unsigned char *)0x52000247)
+#define rEP3_DMA_FIFO       (*(volatile unsigned char *)0x5200024B)
+#define rEP3_DMA_TX_LO      (*(volatile unsigned char *)0x5200024F)
+#define rEP3_DMA_TX_MD      (*(volatile unsigned char *)0x52000253)
+#define rEP3_DMA_TX_HI      (*(volatile unsigned char *)0x52000257)
+#define rEP4_DMA_CON        (*(volatile unsigned char *)0x5200025B)
+#define rEP4_DMA_UNIT       (*(volatile unsigned char *)0x5200025F)
+#define rEP4_DMA_FIFO       (*(volatile unsigned char *)0x52000263)
+#define rEP4_DMA_TX_LO      (*(volatile unsigned char *)0x52000267)
+#define rEP4_DMA_TX_MD      (*(volatile unsigned char *)0x5200026B)
+#define rEP4_DMA_TX_HI      (*(volatile unsigned char *)0x5200026F)
 #else /*  little endian */
-#define rFUNC_ADDR_REG		(*(volatile unsigned char *)0x52000140)
-#define rPWR_REG		(*(volatile unsigned char *)0x52000144)
-#define rEP_INT_REG		(*(volatile unsigned char *)0x52000148)
-#define rUSB_INT_REG		(*(volatile unsigned char *)0x52000158)
-#define rEP_INT_EN_REG		(*(volatile unsigned char *)0x5200015C)
-#define rUSB_INT_EN_REG		(*(volatile unsigned char *)0x5200016C)
-#define rFRAME_NUM1_REG		(*(volatile unsigned char *)0x52000170)
-#define rFRAME_NUM2_REG		(*(volatile unsigned char *)0x52000174)
-#define rINDEX_REG		(*(volatile unsigned char *)0x52000178)
-#define rMAXP_REG		(*(volatile unsigned char *)0x52000180)
-#define rEP0_CSR		(*(volatile unsigned char *)0x52000184)
-#define rIN_CSR1_REG		(*(volatile unsigned char *)0x52000184)
-#define rIN_CSR2_REG		(*(volatile unsigned char *)0x52000188)
-#define rOUT_CSR1_REG		(*(volatile unsigned char *)0x52000190)
-#define rOUT_CSR2_REG		(*(volatile unsigned char *)0x52000194)
-#define rOUT_FIFO_CNT1_REG	(*(volatile unsigned char *)0x52000198)
-#define rOUT_FIFO_CNT2_REG	(*(volatile unsigned char *)0x5200019C)
-#define rEP0_FIFO		(*(volatile unsigned char *)0x520001C0)
-#define rEP1_FIFO		(*(volatile unsigned char *)0x520001C4)
-#define rEP2_FIFO		(*(volatile unsigned char *)0x520001C8)
-#define rEP3_FIFO		(*(volatile unsigned char *)0x520001CC)
-#define rEP4_FIFO		(*(volatile unsigned char *)0x520001D0)
-#define rEP1_DMA_CON		(*(volatile unsigned char *)0x52000200)
-#define rEP1_DMA_UNIT		(*(volatile unsigned char *)0x52000204)
-#define rEP1_DMA_FIFO		(*(volatile unsigned char *)0x52000208)
-#define rEP1_DMA_TX_LO		(*(volatile unsigned char *)0x5200020C)
-#define rEP1_DMA_TX_MD		(*(volatile unsigned char *)0x52000210)
-#define rEP1_DMA_TX_HI		(*(volatile unsigned char *)0x52000214)
-#define rEP2_DMA_CON		(*(volatile unsigned char *)0x52000218)
-#define rEP2_DMA_UNIT		(*(volatile unsigned char *)0x5200021C)
-#define rEP2_DMA_FIFO		(*(volatile unsigned char *)0x52000220)
-#define rEP2_DMA_TX_LO		(*(volatile unsigned char *)0x52000224)
-#define rEP2_DMA_TX_MD		(*(volatile unsigned char *)0x52000228)
-#define rEP2_DMA_TX_HI		(*(volatile unsigned char *)0x5200022C)
-#define rEP3_DMA_CON		(*(volatile unsigned char *)0x52000240)
-#define rEP3_DMA_UNIT		(*(volatile unsigned char *)0x52000244)
-#define rEP3_DMA_FIFO		(*(volatile unsigned char *)0x52000248)
-#define rEP3_DMA_TX_LO		(*(volatile unsigned char *)0x5200024C)
-#define rEP3_DMA_TX_MD		(*(volatile unsigned char *)0x52000250)
-#define rEP3_DMA_TX_HI		(*(volatile unsigned char *)0x52000254)
-#define rEP4_DMA_CON		(*(volatile unsigned char *)0x52000258)
-#define rEP4_DMA_UNIT		(*(volatile unsigned char *)0x5200025C)
-#define rEP4_DMA_FIFO		(*(volatile unsigned char *)0x52000260)
-#define rEP4_DMA_TX_LO		(*(volatile unsigned char *)0x52000264)
-#define rEP4_DMA_TX_MD		(*(volatile unsigned char *)0x52000268)
-#define rEP4_DMA_TX_HI		(*(volatile unsigned char *)0x5200026C)
+#define rFUNC_ADDR_REG      (*(volatile unsigned char *)0x52000140)
+#define rPWR_REG        (*(volatile unsigned char *)0x52000144)
+#define rEP_INT_REG     (*(volatile unsigned char *)0x52000148)
+#define rUSB_INT_REG        (*(volatile unsigned char *)0x52000158)
+#define rEP_INT_EN_REG      (*(volatile unsigned char *)0x5200015C)
+#define rUSB_INT_EN_REG     (*(volatile unsigned char *)0x5200016C)
+#define rFRAME_NUM1_REG     (*(volatile unsigned char *)0x52000170)
+#define rFRAME_NUM2_REG     (*(volatile unsigned char *)0x52000174)
+#define rINDEX_REG      (*(volatile unsigned char *)0x52000178)
+#define rMAXP_REG       (*(volatile unsigned char *)0x52000180)
+#define rEP0_CSR        (*(volatile unsigned char *)0x52000184)
+#define rIN_CSR1_REG        (*(volatile unsigned char *)0x52000184)
+#define rIN_CSR2_REG        (*(volatile unsigned char *)0x52000188)
+#define rOUT_CSR1_REG       (*(volatile unsigned char *)0x52000190)
+#define rOUT_CSR2_REG       (*(volatile unsigned char *)0x52000194)
+#define rOUT_FIFO_CNT1_REG  (*(volatile unsigned char *)0x52000198)
+#define rOUT_FIFO_CNT2_REG  (*(volatile unsigned char *)0x5200019C)
+#define rEP0_FIFO       (*(volatile unsigned char *)0x520001C0)
+#define rEP1_FIFO       (*(volatile unsigned char *)0x520001C4)
+#define rEP2_FIFO       (*(volatile unsigned char *)0x520001C8)
+#define rEP3_FIFO       (*(volatile unsigned char *)0x520001CC)
+#define rEP4_FIFO       (*(volatile unsigned char *)0x520001D0)
+#define rEP1_DMA_CON        (*(volatile unsigned char *)0x52000200)
+#define rEP1_DMA_UNIT       (*(volatile unsigned char *)0x52000204)
+#define rEP1_DMA_FIFO       (*(volatile unsigned char *)0x52000208)
+#define rEP1_DMA_TX_LO      (*(volatile unsigned char *)0x5200020C)
+#define rEP1_DMA_TX_MD      (*(volatile unsigned char *)0x52000210)
+#define rEP1_DMA_TX_HI      (*(volatile unsigned char *)0x52000214)
+#define rEP2_DMA_CON        (*(volatile unsigned char *)0x52000218)
+#define rEP2_DMA_UNIT       (*(volatile unsigned char *)0x5200021C)
+#define rEP2_DMA_FIFO       (*(volatile unsigned char *)0x52000220)
+#define rEP2_DMA_TX_LO      (*(volatile unsigned char *)0x52000224)
+#define rEP2_DMA_TX_MD      (*(volatile unsigned char *)0x52000228)
+#define rEP2_DMA_TX_HI      (*(volatile unsigned char *)0x5200022C)
+#define rEP3_DMA_CON        (*(volatile unsigned char *)0x52000240)
+#define rEP3_DMA_UNIT       (*(volatile unsigned char *)0x52000244)
+#define rEP3_DMA_FIFO       (*(volatile unsigned char *)0x52000248)
+#define rEP3_DMA_TX_LO      (*(volatile unsigned char *)0x5200024C)
+#define rEP3_DMA_TX_MD      (*(volatile unsigned char *)0x52000250)
+#define rEP3_DMA_TX_HI      (*(volatile unsigned char *)0x52000254)
+#define rEP4_DMA_CON        (*(volatile unsigned char *)0x52000258)
+#define rEP4_DMA_UNIT       (*(volatile unsigned char *)0x5200025C)
+#define rEP4_DMA_FIFO       (*(volatile unsigned char *)0x52000260)
+#define rEP4_DMA_TX_LO      (*(volatile unsigned char *)0x52000264)
+#define rEP4_DMA_TX_MD      (*(volatile unsigned char *)0x52000268)
+#define rEP4_DMA_TX_HI      (*(volatile unsigned char *)0x5200026C)
 #endif /*  __BIG_ENDIAN */
 
 
 /* WATCH DOG TIMER */
-#define rWTCON			(*(volatile unsigned *)0x53000000)
-#define rWTDAT			(*(volatile unsigned *)0x53000004)
-#define rWTCNT			(*(volatile unsigned *)0x53000008)
+#define rWTCON          (*(volatile unsigned *)0x53000000)
+#define rWTDAT          (*(volatile unsigned *)0x53000004)
+#define rWTCNT          (*(volatile unsigned *)0x53000008)
 
 
 /* IIC */
-#define rIICCON			(*(volatile unsigned *)0x54000000)
-#define rIICSTAT		(*(volatile unsigned *)0x54000004)
-#define rIICADD			(*(volatile unsigned *)0x54000008)
-#define rIICDS			(*(volatile unsigned *)0x5400000C)
+#define rIICCON         (*(volatile unsigned *)0x54000000)
+#define rIICSTAT        (*(volatile unsigned *)0x54000004)
+#define rIICADD         (*(volatile unsigned *)0x54000008)
+#define rIICDS          (*(volatile unsigned *)0x5400000C)
 
 
 /* IIS */
-#define rIISCON			(*(volatile unsigned *)0x55000000)
-#define rIISMOD			(*(volatile unsigned *)0x55000004)
-#define rIISPSR			(*(volatile unsigned *)0x55000008)
-#define rIISFCON		(*(volatile unsigned *)0x5500000C)
+#define rIISCON         (*(volatile unsigned *)0x55000000)
+#define rIISMOD         (*(volatile unsigned *)0x55000004)
+#define rIISPSR         (*(volatile unsigned *)0x55000008)
+#define rIISFCON        (*(volatile unsigned *)0x5500000C)
 
 #ifdef __BIG_ENDIAN
-#define IISFIF			((volatile unsigned short *)0x55000012)
+#define IISFIF          ((volatile unsigned short *)0x55000012)
 #else /*  little endian */
-#define IISFIF			((volatile unsigned short *)0x55000010)
+#define IISFIF          ((volatile unsigned short *)0x55000010)
 #endif
 
 
 /* I/O PORT */
-#define rGPACON			(*(volatile unsigned *)0x56000000)
-#define rGPADAT			(*(volatile unsigned *)0x56000004)
+#define rGPACON         (*(volatile unsigned *)0x56000000)
+#define rGPADAT         (*(volatile unsigned *)0x56000004)
 
-#define rGPBCON			(*(volatile unsigned *)0x56000010)
-#define rGPBDAT			(*(volatile unsigned *)0x56000014)
-#define rGPBUP			(*(volatile unsigned *)0x56000018)
-
-#define rGPCCON			(*(volatile unsigned *)0x56000020)
-#define rGPCDAT			(*(volatile unsigned *)0x56000024)
-#define rGPCUP			(*(volatile unsigned *)0x56000028)
-
-#define rGPDCON			(*(volatile unsigned *)0x56000030)
-#define rGPDDAT			(*(volatile unsigned *)0x56000034)
-#define rGPDUP			(*(volatile unsigned *)0x56000038)
-
-#define rGPECON			(*(volatile unsigned *)0x56000040)
-#define rGPEDAT			(*(volatile unsigned *)0x56000044)
-#define rGPEUP			(*(volatile unsigned *)0x56000048)
-
-#define rGPFCON			(*(volatile unsigned *)0x56000050)
-#define rGPFDAT			(*(volatile unsigned *)0x56000054)
-#define rGPFUP			(*(volatile unsigned *)0x56000058)
-
-#define rGPGCON			(*(volatile unsigned *)0x56000060)
-#define rGPGDAT			(*(volatile unsigned *)0x56000064)
-#define rGPGUP			(*(volatile unsigned *)0x56000068)
-
-#define rGPHCON			(*(volatile unsigned *)0x56000070)
-#define rGPHDAT			(*(volatile unsigned *)0x56000074)
-#define rGPHUP			(*(volatile unsigned *)0x56000078)
-
-#define rMISCCR			(*(volatile unsigned *)0x56000080)
-#define rDCLKCON		(*(volatile unsigned *)0x56000084)
-#define rEXTINT0		(*(volatile unsigned *)0x56000088)
-#define rEXTINT1		(*(volatile unsigned *)0x5600008C)
-#define rEXTINT2		(*(volatile unsigned *)0x56000090)
-#define rEINTFLT0		(*(volatile unsigned *)0x56000094)
-#define rEINTFLT1		(*(volatile unsigned *)0x56000098)
-#define rEINTFLT2		(*(volatile unsigned *)0x5600009C)
-#define rEINTFLT3		(*(volatile unsigned *)0x560000A0)
-#define rEINTMASK		(*(volatile unsigned *)0x560000A4)
-#define rEINTPEND		(*(volatile unsigned *)0x560000A8)
-#define rGSTATUS0		(*(volatile unsigned *)0x560000AC)
-#define rGSTATUS1		(*(volatile unsigned *)0x560000B0)
+#define rGPBCON         (*(volatile unsigned *)0x56000010)
+#define rGPBDAT         (*(volatile unsigned *)0x56000014)
+#define rGPBUP          (*(volatile unsigned *)0x56000018)
+
+#define rGPCCON         (*(volatile unsigned *)0x56000020)
+#define rGPCDAT         (*(volatile unsigned *)0x56000024)
+#define rGPCUP          (*(volatile unsigned *)0x56000028)
+
+#define rGPDCON         (*(volatile unsigned *)0x56000030)
+#define rGPDDAT         (*(volatile unsigned *)0x56000034)
+#define rGPDUP          (*(volatile unsigned *)0x56000038)
+
+#define rGPECON         (*(volatile unsigned *)0x56000040)
+#define rGPEDAT         (*(volatile unsigned *)0x56000044)
+#define rGPEUP          (*(volatile unsigned *)0x56000048)
+
+#define rGPFCON         (*(volatile unsigned *)0x56000050)
+#define rGPFDAT         (*(volatile unsigned *)0x56000054)
+#define rGPFUP          (*(volatile unsigned *)0x56000058)
+
+#define rGPGCON         (*(volatile unsigned *)0x56000060)
+#define rGPGDAT         (*(volatile unsigned *)0x56000064)
+#define rGPGUP          (*(volatile unsigned *)0x56000068)
+
+#define rGPHCON         (*(volatile unsigned *)0x56000070)
+#define rGPHDAT         (*(volatile unsigned *)0x56000074)
+#define rGPHUP          (*(volatile unsigned *)0x56000078)
+
+#define rMISCCR         (*(volatile unsigned *)0x56000080)
+#define rDCLKCON        (*(volatile unsigned *)0x56000084)
+#define rEXTINT0        (*(volatile unsigned *)0x56000088)
+#define rEXTINT1        (*(volatile unsigned *)0x5600008C)
+#define rEXTINT2        (*(volatile unsigned *)0x56000090)
+#define rEINTFLT0       (*(volatile unsigned *)0x56000094)
+#define rEINTFLT1       (*(volatile unsigned *)0x56000098)
+#define rEINTFLT2       (*(volatile unsigned *)0x5600009C)
+#define rEINTFLT3       (*(volatile unsigned *)0x560000A0)
+#define rEINTMASK       (*(volatile unsigned *)0x560000A4)
+#define rEINTPEND       (*(volatile unsigned *)0x560000A8)
+#define rGSTATUS0       (*(volatile unsigned *)0x560000AC)
+#define rGSTATUS1       (*(volatile unsigned *)0x560000B0)
 
 
 /* RTC */
 #ifdef __BIG_ENDIAN
-#define rRTCCON			(*(volatile unsigned char *)0x57000043)
-#define rTICNT			(*(volatile unsigned char *)0x57000047)
-#define rRTCALM			(*(volatile unsigned char *)0x57000053)
-#define rALMSEC			(*(volatile unsigned char *)0x57000057)
-#define rALMMIN			(*(volatile unsigned char *)0x5700005B)
-#define rALMHOUR		(*(volatile unsigned char *)0x5700005F)
-#define rALMDATE		(*(volatile unsigned char *)0x57000063)
-#define rALMMON			(*(volatile unsigned char *)0x57000067)
-#define rALMYEAR		(*(volatile unsigned char *)0x5700006B)
-#define rRTCRST			(*(volatile unsigned char *)0x5700006F)
-#define rBCDSEC			(*(volatile unsigned char *)0x57000073)
-#define rBCDMIN			(*(volatile unsigned char *)0x57000077)
-#define rBCDHOUR		(*(volatile unsigned char *)0x5700007B)
-#define rBCDDATE		(*(volatile unsigned char *)0x5700007F)
-#define rBCDDAY			(*(volatile unsigned char *)0x57000083)
-#define rBCDMON			(*(volatile unsigned char *)0x57000087)
-#define rBCDYEAR		(*(volatile unsigned char *)0x5700008B)
+#define rRTCCON         (*(volatile unsigned char *)0x57000043)
+#define rTICNT          (*(volatile unsigned char *)0x57000047)
+#define rRTCALM         (*(volatile unsigned char *)0x57000053)
+#define rALMSEC         (*(volatile unsigned char *)0x57000057)
+#define rALMMIN         (*(volatile unsigned char *)0x5700005B)
+#define rALMHOUR        (*(volatile unsigned char *)0x5700005F)
+#define rALMDATE        (*(volatile unsigned char *)0x57000063)
+#define rALMMON         (*(volatile unsigned char *)0x57000067)
+#define rALMYEAR        (*(volatile unsigned char *)0x5700006B)
+#define rRTCRST         (*(volatile unsigned char *)0x5700006F)
+#define rBCDSEC         (*(volatile unsigned char *)0x57000073)
+#define rBCDMIN         (*(volatile unsigned char *)0x57000077)
+#define rBCDHOUR        (*(volatile unsigned char *)0x5700007B)
+#define rBCDDATE        (*(volatile unsigned char *)0x5700007F)
+#define rBCDDAY         (*(volatile unsigned char *)0x57000083)
+#define rBCDMON         (*(volatile unsigned char *)0x57000087)
+#define rBCDYEAR        (*(volatile unsigned char *)0x5700008B)
 #else /*  little endian */
-#define rRTCCON			(*(volatile unsigned char *)0x57000040)
-#define rTICNT			(*(volatile unsigned char *)0x57000044)
-#define rRTCALM			(*(volatile unsigned char *)0x57000050)
-#define rALMSEC			(*(volatile unsigned char *)0x57000054)
-#define rALMMIN			(*(volatile unsigned char *)0x57000058)
-#define rALMHOUR		(*(volatile unsigned char *)0x5700005C)
-#define rALMDATE		(*(volatile unsigned char *)0x57000060)
-#define rALMMON			(*(volatile unsigned char *)0x57000064)
-#define rALMYEAR		(*(volatile unsigned char *)0x57000068)
-#define rRTCRST			(*(volatile unsigned char *)0x5700006C)
-#define rBCDSEC			(*(volatile unsigned char *)0x57000070)
-#define rBCDMIN			(*(volatile unsigned char *)0x57000074)
-#define rBCDHOUR		(*(volatile unsigned char *)0x57000078)
-#define rBCDDATE		(*(volatile unsigned char *)0x5700007C)
-#define rBCDDAY			(*(volatile unsigned char *)0x57000080)
-#define rBCDMON			(*(volatile unsigned char *)0x57000084)
-#define rBCDYEAR		(*(volatile unsigned char *)0x57000088)
+#define rRTCCON         (*(volatile unsigned char *)0x57000040)
+#define rTICNT          (*(volatile unsigned char *)0x57000044)
+#define rRTCALM         (*(volatile unsigned char *)0x57000050)
+#define rALMSEC         (*(volatile unsigned char *)0x57000054)
+#define rALMMIN         (*(volatile unsigned char *)0x57000058)
+#define rALMHOUR        (*(volatile unsigned char *)0x5700005C)
+#define rALMDATE        (*(volatile unsigned char *)0x57000060)
+#define rALMMON         (*(volatile unsigned char *)0x57000064)
+#define rALMYEAR        (*(volatile unsigned char *)0x57000068)
+#define rRTCRST         (*(volatile unsigned char *)0x5700006C)
+#define rBCDSEC         (*(volatile unsigned char *)0x57000070)
+#define rBCDMIN         (*(volatile unsigned char *)0x57000074)
+#define rBCDHOUR        (*(volatile unsigned char *)0x57000078)
+#define rBCDDATE        (*(volatile unsigned char *)0x5700007C)
+#define rBCDDAY         (*(volatile unsigned char *)0x57000080)
+#define rBCDMON         (*(volatile unsigned char *)0x57000084)
+#define rBCDYEAR        (*(volatile unsigned char *)0x57000088)
 #endif
 
 
 /* ADC */
-#define rADCCON			(*(volatile unsigned *)0x58000000)
-#define rADCTSC			(*(volatile unsigned *)0x58000004)
-#define rADCDLY			(*(volatile unsigned *)0x58000008)
-#define rADCDAT0		(*(volatile unsigned *)0x5800000C)
-#define rADCDAT1		(*(volatile unsigned *)0x58000010)
+#define rADCCON         (*(volatile unsigned *)0x58000000)
+#define rADCTSC         (*(volatile unsigned *)0x58000004)
+#define rADCDLY         (*(volatile unsigned *)0x58000008)
+#define rADCDAT0        (*(volatile unsigned *)0x5800000C)
+#define rADCDAT1        (*(volatile unsigned *)0x58000010)
 
 
 /* SPI */
-#define rSPCON0			(*(volatile unsigned *)0x59000000)
-#define rSPSTA0			(*(volatile unsigned *)0x59000004)
-#define rSPPIN0			(*(volatile unsigned *)0x59000008)
-#define rSPPRE0			(*(volatile unsigned *)0x5900000C)
-#define rSPTDAT0		(*(volatile unsigned *)0x59000010)
-#define rSPRDAT0		(*(volatile unsigned *)0x59000014)
-#define rSPCON1			(*(volatile unsigned *)0x59000020)
-#define rSPSTA1			(*(volatile unsigned *)0x59000024)
-#define rSPPIN1			(*(volatile unsigned *)0x59000028)
-#define rSPPRE1			(*(volatile unsigned *)0x5900002C)
-#define rSPTDAT1		(*(volatile unsigned *)0x59000030)
-#define rSPRDAT1		(*(volatile unsigned *)0x59000034)
+#define rSPCON0         (*(volatile unsigned *)0x59000000)
+#define rSPSTA0         (*(volatile unsigned *)0x59000004)
+#define rSPPIN0         (*(volatile unsigned *)0x59000008)
+#define rSPPRE0         (*(volatile unsigned *)0x5900000C)
+#define rSPTDAT0        (*(volatile unsigned *)0x59000010)
+#define rSPRDAT0        (*(volatile unsigned *)0x59000014)
+#define rSPCON1         (*(volatile unsigned *)0x59000020)
+#define rSPSTA1         (*(volatile unsigned *)0x59000024)
+#define rSPPIN1         (*(volatile unsigned *)0x59000028)
+#define rSPPRE1         (*(volatile unsigned *)0x5900002C)
+#define rSPTDAT1        (*(volatile unsigned *)0x59000030)
+#define rSPRDAT1        (*(volatile unsigned *)0x59000034)
 
 
 /* SD INTERFACE */
-#define rSDICON			(*(volatile unsigned *)0x5A000000)
-#define rSDIPRE			(*(volatile unsigned *)0x5A000004)
-#define rSDICmdArg		(*(volatile unsigned *)0x5A000008)
-#define rSDICmdCon		(*(volatile unsigned *)0x5A00000C)
-#define rSDICmdSta		(*(volatile unsigned *)0x5A000010)
-#define rSDIRSP0		(*(volatile unsigned *)0x5A000014)
-#define rSDIRSP1		(*(volatile unsigned *)0x5A000018)
-#define rSDIRSP2		(*(volatile unsigned *)0x5A00001C)
-#define rSDIRSP3		(*(volatile unsigned *)0x5A000020)
-#define rSDIDTimer		(*(volatile unsigned *)0x5A000024)
-#define rSDIBSize		(*(volatile unsigned *)0x5A000028)
-#define rSDIDatCon		(*(volatile unsigned *)0x5A00002C)
-#define rSDIDatCnt		(*(volatile unsigned *)0x5A000030)
-#define rSDIDatSta		(*(volatile unsigned *)0x5A000034)
-#define rSDIFSTA		(*(volatile unsigned *)0x5A000038)
+#define rSDICON         (*(volatile unsigned *)0x5A000000)
+#define rSDIPRE         (*(volatile unsigned *)0x5A000004)
+#define rSDICmdArg      (*(volatile unsigned *)0x5A000008)
+#define rSDICmdCon      (*(volatile unsigned *)0x5A00000C)
+#define rSDICmdSta      (*(volatile unsigned *)0x5A000010)
+#define rSDIRSP0        (*(volatile unsigned *)0x5A000014)
+#define rSDIRSP1        (*(volatile unsigned *)0x5A000018)
+#define rSDIRSP2        (*(volatile unsigned *)0x5A00001C)
+#define rSDIRSP3        (*(volatile unsigned *)0x5A000020)
+#define rSDIDTimer      (*(volatile unsigned *)0x5A000024)
+#define rSDIBSize       (*(volatile unsigned *)0x5A000028)
+#define rSDIDatCon      (*(volatile unsigned *)0x5A00002C)
+#define rSDIDatCnt      (*(volatile unsigned *)0x5A000030)
+#define rSDIDatSta      (*(volatile unsigned *)0x5A000034)
+#define rSDIFSTA        (*(volatile unsigned *)0x5A000038)
 #ifdef __BIG_ENDIAN
-#define rSDIDAT			(*(volatile unsigned char *)0x5A00003F)
+#define rSDIDAT         (*(volatile unsigned char *)0x5A00003F)
 #else
-#define rSDIDAT			(*(volatile unsigned char *)0x5A00003C)
+#define rSDIDAT         (*(volatile unsigned char *)0x5A00003C)
 #endif
-#define rSDIIntMsk		(*(volatile unsigned *)0x5A000040)
+#define rSDIIntMsk      (*(volatile unsigned *)0x5A000040)
 
 #endif
 
+#define rGSTATUS1       (*(volatile unsigned *)0x560000B0)
+#define isS3C2410 		((rGSTATUS1 & 0xffff0000) == 0x32410000)
+
 #endif /*__S3C24X0_H__*/
diff -urN u-boot-1.1.6_jz2440/Makefile u-boot-1.1.6_nand_ok/Makefile
--- u-boot-1.1.6_jz2440/Makefile	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_nand_ok/Makefile	2010-11-26 12:54:37.830153999 +0800
@@ -206,8 +206,8 @@
 LIBS += drivers/libdrivers.a
 LIBS += drivers/nand/libnand.a
 LIBS += drivers/nand_legacy/libnand_legacy.a
+//LIBS += drivers/usb/libusb.a
 LIBS += drivers/sk98lin/libsk98lin.a
-LIBS += post/libpost.a post/cpu/libcpu.a
 LIBS += common/libcommon.a
 LIBS += $(BOARDLIBS)
 
@@ -266,11 +266,15 @@
 			-Map u-boot.map -o u-boot
 
 $(OBJS):
+	echo $(OBJS)	
 		$(MAKE) -C cpu/$(CPU) $(if $(REMOTE_BUILD),$@,$(notdir $@))
 
 $(LIBS):
 		$(MAKE) -C $(dir $(subst $(obj),,$@))
 
+usb:
+	$(MAKE) -C drivers/usb
+
 $(SUBDIRS):
 		$(MAKE) -C $@ all
 
@@ -1879,6 +1883,9 @@
 smdk2410_config	:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm920t smdk2410 NULL s3c24x0
 
+100ask24x0_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t 100ask24x0 NULL s3c24x0
+
 SX1_config :		unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm925t sx1
 
diff -urN u-boot-1.1.6_jz2440/drivers/dm9000x.c u-boot-1.1.6_nand_ok/drivers/dm9000x.c
--- u-boot-1.1.6_jz2440/drivers/dm9000x.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_nand_ok/drivers/dm9000x.c	2010-11-26 12:54:38.306059089 +0800
@@ -17,17 +17,17 @@
   (C)Copyright 1997-1998 DAVICOM Semiconductor,Inc. All Rights Reserved.
 
 V0.11	06/20/2001	REG_0A bit3=1, default enable BP with DA match
-	06/22/2001 	Support DM9801 progrmming
-	 	 	E3: R25 = ((R24 + NF) & 0x00ff) | 0xf000
-		 	E4: R25 = ((R24 + NF) & 0x00ff) | 0xc200
-     		R17 = (R17 & 0xfff0) | NF + 3
-		 	E5: R25 = ((R24 + NF - 3) & 0x00ff) | 0xc200
-     		R17 = (R17 & 0xfff0) | NF
+	06/22/2001	Support DM9801 progrmming
+			E3: R25 = ((R24 + NF) & 0x00ff) | 0xf000
+			E4: R25 = ((R24 + NF) & 0x00ff) | 0xc200
+		R17 = (R17 & 0xfff0) | NF + 3
+			E5: R25 = ((R24 + NF - 3) & 0x00ff) | 0xc200
+		R17 = (R17 & 0xfff0) | NF
 
-v1.00               	modify by simon 2001.9.5
+v1.00			modify by simon 2001.9.5
 	                change for kernel 2.4.x
 
-v1.1   11/09/2001      	fix force mode bug
+v1.1   11/09/2001	fix force mode bug
 
 v1.2   03/18/2003       Weilun Huang <weilun_huang@davicom.com.tw>:
 			Fixed phy reset.
@@ -36,17 +36,32 @@
 
 --------------------------------------
 
-       12/15/2003       Initial port to u-boot by Sascha Hauer <saschahauer@web.de>
+       12/15/2003       Initial port to u-boot by
+       			Sascha Hauer <saschahauer@web.de>
+
+       06/03/2008	Remy Bohmer <linux@bohmer.net>
+			- Fixed the driver to work with DM9000A.
+			  (check on ISR receive status bit before reading the
+			  FIFO as described in DM9000 programming guide and
+			  application notes)
+			- Added autodetect of databus width.
+			- Made debug code compile again.
+			- Adapt eth_send such that it matches the DM9000*
+			  application notes. Needed to make it work properly
+			  for DM9000A.
+			- Adapted reset procedure to match DM9000 application
+			  notes (i.e. double reset)
+			- some minor code cleanups
+			These changes are tested with DM9000{A,EP,E} together
+			with a 200MHz Atmel AT91SAM92161 core
 
 TODO: Homerun NIC and longrun NIC are not functional, only internal at the
       moment.
 */
-
 #include <common.h>
 #include <command.h>
 #include <net.h>
 #include <asm/io.h>
-
 #ifdef CONFIG_DRIVER_DM9000
 
 #include "dm9000x.h"
@@ -59,10 +74,22 @@
 /* #define CONFIG_DM9000_DEBUG */
 
 #ifdef CONFIG_DM9000_DEBUG
-#define DM9000_DBG(fmt,args...) printf(fmt ,##args)
-#else				/*  */
+#define DM9000_DBG(fmt,args...) printf(fmt, ##args)
+#define DM9000_DMP_PACKET(func,packet,length)  \
+	do { \
+		int i; 							\
+		printf(func ": length: %d\n", length);			\
+		for (i = 0; i < length; i++) {				\
+			if (i % 8 == 0)					\
+				printf("\n%s: %02x: ", func, i);	\
+			printf("%02x ", ((unsigned char *) packet)[i]);	\
+		} printf("\n");						\
+	} while(0)
+#else
 #define DM9000_DBG(fmt,args...)
-#endif				/*  */
+#define DM9000_DMP_PACKET(func,packet,length)
+#endif
+
 enum DM9000_PHY_mode { DM9000_10MHD = 0, DM9000_100MHD =
 	    1, DM9000_10MFD = 4, DM9000_100MFD = 5, DM9000_AUTO =
 	    8, DM9000_1M_HPNA = 0x10
@@ -84,8 +111,11 @@
 	u8 device_wait_reset;	/* device state */
 	u8 nic_type;		/* NIC type */
 	unsigned char srom[128];
+	void (*outblk)(volatile void *data_ptr, int count);
+	void (*inblk)(void *data_ptr, int count);
+	void (*rx_status)(u16 *RxStatus, u16 *RxLen);
 } board_info_t;
-board_info_t dmfe_info;
+static board_info_t dm9000_info;
 
 /* For module input parameter */
 static int media_mode = DM9000_AUTO;
@@ -99,7 +129,7 @@
 static int dm9000_probe(void);
 static u16 phy_read(int);
 static void phy_write(int, u16);
-static u16 read_srom_word(int);
+u16 read_srom_word(int);
 static u8 DM9000_ior(int);
 static void DM9000_iow(int reg, u8 value);
 
@@ -112,6 +142,16 @@
 #define DM9000_inw(r) (*(volatile u16 *)r)
 #define DM9000_inl(r) (*(volatile u32 *)r)
 
+static inline int is_zero_ether_addr(const u8 *addr)
+{
+	return !(addr[0] | addr[1] | addr[2] | addr[3] | addr[4] | addr[5]);
+}
+
+static inline int is_multicast_ether_addr(const u8 *addr)
+{
+	return (0x01 & addr[0]);
+}
+
 #ifdef CONFIG_DM9000_DEBUG
 static void
 dump_regs(void)
@@ -124,10 +164,85 @@
 	DM9000_DBG("TSRII (0x04): %02x\n", DM9000_ior(4));
 	DM9000_DBG("RCR   (0x05): %02x\n", DM9000_ior(5));
 	DM9000_DBG("RSR   (0x06): %02x\n", DM9000_ior(6));
-	DM9000_DBG("ISR   (0xFE): %02x\n", DM9000_ior(ISR));
+	DM9000_DBG("ISR   (0xFE): %02x\n", DM9000_ior(DM9000_ISR));
 	DM9000_DBG("\n");
 }
-#endif				/*  */
+#endif
+
+static void dm9000_outblk_8bit(volatile void *data_ptr, int count)
+{
+	int i;
+	for (i = 0; i < count; i++)
+		DM9000_outb((((u8 *) data_ptr)[i] & 0xff), DM9000_DATA);
+}
+
+static void dm9000_outblk_16bit(volatile void *data_ptr, int count)
+{
+	int i;
+	u32 tmplen = (count + 1) / 2;
+
+	for (i = 0; i < tmplen; i++)
+		DM9000_outw(((u16 *) data_ptr)[i], DM9000_DATA);
+}
+static void dm9000_outblk_32bit(volatile void *data_ptr, int count)
+{
+	int i;
+	u32 tmplen = (count + 3) / 4;
+
+	for (i = 0; i < tmplen; i++)
+		DM9000_outl(((u32 *) data_ptr)[i], DM9000_DATA);
+}
+
+static void dm9000_inblk_8bit(void *data_ptr, int count)
+{
+	int i;
+	for (i = 0; i < count; i++)
+		((u8 *) data_ptr)[i] = DM9000_inb(DM9000_DATA);
+}
+
+static void dm9000_inblk_16bit(void *data_ptr, int count)
+{
+	int i;
+	u32 tmplen = (count + 1) / 2;
+
+	for (i = 0; i < tmplen; i++)
+		((u16 *) data_ptr)[i] = DM9000_inw(DM9000_DATA);
+}
+static void dm9000_inblk_32bit(void *data_ptr, int count)
+{
+	int i;
+	u32 tmplen = (count + 3) / 4;
+
+	for (i = 0; i < tmplen; i++)
+		((u32 *) data_ptr)[i] = DM9000_inl(DM9000_DATA);
+}
+
+static void dm9000_rx_status_32bit(u16 *RxStatus, u16 *RxLen)
+{
+	u32 tmpdata;
+
+	DM9000_outb(DM9000_MRCMD, DM9000_IO);
+
+	tmpdata = DM9000_inl(DM9000_DATA);
+	*RxStatus = tmpdata;
+	*RxLen = tmpdata >> 16;
+}
+
+static void dm9000_rx_status_16bit(u16 *RxStatus, u16 *RxLen)
+{
+	DM9000_outb(DM9000_MRCMD, DM9000_IO);
+
+	*RxStatus = DM9000_inw(DM9000_DATA);
+	*RxLen = DM9000_inw(DM9000_DATA);
+}
+
+static void dm9000_rx_status_8bit(u16 *RxStatus, u16 *RxLen)
+{
+	DM9000_outb(DM9000_MRCMD, DM9000_IO);
+
+	*RxStatus = DM9000_inb(DM9000_DATA) + (DM9000_inb(DM9000_DATA) << 8);
+	*RxLen = DM9000_inb(DM9000_DATA) + (DM9000_inb(DM9000_DATA) << 8);
+}
 
 /*
   Search DM9000 board, allocate space and register it
@@ -236,7 +351,7 @@
 static void
 identify_nic(void)
 {
-	struct board_info *db = &dmfe_info;	/* Point a board information structure */
+	struct board_info *db = &dm9000_info;
 	u16 phy_reg3;
 	DM9000_iow(DM9000_NCR, NCR_EXT_PHY);
 	phy_reg3 = phy_read(3);
@@ -263,9 +378,35 @@
 static void
 dm9000_reset(void)
 {
-	DM9000_DBG("resetting\n");
-	DM9000_iow(DM9000_NCR, NCR_RST);
-	udelay(1000);		/* delay 1ms */
+	DM9000_DBG("resetting DM9000\n");
+
+	/* Reset DM9000,
+	   see DM9000 Application Notes V1.22 Jun 11, 2004 page 29 */
+
+	/* DEBUG: Make all GPIO pins outputs */
+	DM9000_iow(DM9000_GPCR, 0x0F);
+	/* Step 1: Power internal PHY by writing 0 to GPIO0 pin */
+	DM9000_iow(DM9000_GPR, 0);
+	/* Step 2: Software reset */
+	DM9000_iow(DM9000_NCR, 3);
+
+	do {
+		DM9000_DBG("resetting the DM9000, 1st reset\n");
+		udelay(25); /* Wait at least 20 us */
+	} while (DM9000_ior(DM9000_NCR) & 1);
+
+	DM9000_iow(DM9000_NCR, 0);
+	DM9000_iow(DM9000_NCR, 3); /* Issue a second reset */
+
+	do {
+		DM9000_DBG("resetting the DM9000, 2nd reset\n");
+		udelay(25); /* Wait at least 20 us */
+	} while (DM9000_ior(DM9000_NCR) & 1);
+
+	/* Check whether the ethernet controller is present */
+	if ((DM9000_ior(DM9000_PIDL) != 0x0) ||
+	    (DM9000_ior(DM9000_PIDH) != 0x90))
+		printf("ERROR: resetting DM9000 -> not responding\n");
 }
 
 /* Initilize dm9000 board
@@ -274,12 +415,46 @@
 eth_init(bd_t * bd)
 {
 	int i, oft, lnk;
+	u8 io_mode;
+	struct board_info *db = &dm9000_info;
+
 	DM9000_DBG("eth_init()\n");
 
 	/* RESET device */
 	dm9000_reset();
 	dm9000_probe();
 
+	/* Auto-detect 8/16/32 bit mode, ISR Bit 6+7 indicate bus width */
+	io_mode = DM9000_ior(DM9000_ISR) >> 6;
+
+	switch (io_mode) {
+	case 0x0:  /* 16-bit mode */
+		printf("DM9000: running in 16 bit mode\n");
+		db->outblk    = dm9000_outblk_16bit;
+		db->inblk     = dm9000_inblk_16bit;
+		db->rx_status = dm9000_rx_status_16bit;
+		break;
+	case 0x01:  /* 32-bit mode */
+		printf("DM9000: running in 32 bit mode\n");
+		db->outblk    = dm9000_outblk_32bit;
+		db->inblk     = dm9000_inblk_32bit;
+		db->rx_status = dm9000_rx_status_32bit;
+		break;
+	case 0x02: /* 8 bit mode */
+		printf("DM9000: running in 8 bit mode\n");
+		db->outblk    = dm9000_outblk_8bit;
+		db->inblk     = dm9000_inblk_8bit;
+		db->rx_status = dm9000_rx_status_8bit;
+		break;
+	default:
+		/* Assume 8 bit mode, will probably not work anyway */
+		printf("DM9000: Undefined IO-mode:0x%x\n", io_mode);
+		db->outblk    = dm9000_outblk_8bit;
+		db->inblk     = dm9000_inblk_8bit;
+		db->rx_status = dm9000_rx_status_8bit;
+		break;
+	}
+
 	/* NIC Type: FASTETHER, HOMERUN, LONGRUN */
 	identify_nic();
 
@@ -289,19 +464,43 @@
 	/* Set PHY */
 	set_PHY_mode();
 
-	/* Program operating register */
-	DM9000_iow(DM9000_NCR, 0x0);	/* only intern phy supported by now */
-	DM9000_iow(DM9000_TCR, 0);	/* TX Polling clear */
-	DM9000_iow(DM9000_BPTR, 0x3f);	/* Less 3Kb, 200us */
-	DM9000_iow(DM9000_FCTR, FCTR_HWOT(3) | FCTR_LWOT(8));	/* Flow Control : High/Low Water */
-	DM9000_iow(DM9000_FCR, 0x0);	/* SH FIXME: This looks strange! Flow Control */
-	DM9000_iow(DM9000_SMCR, 0);	/* Special Mode */
-	DM9000_iow(DM9000_NSR, NSR_WAKEST | NSR_TX2END | NSR_TX1END);	/* clear TX status */
-	DM9000_iow(DM9000_ISR, 0x0f);	/* Clear interrupt status */
+	/* Program operating register, only intern phy supported by now */
+	DM9000_iow(DM9000_NCR, 0x0);
+	/* TX Polling clear */
+	DM9000_iow(DM9000_TCR, 0);
+	/* Less 3Kb, 200us */
+	DM9000_iow(DM9000_BPTR, 0x3f);
+	/* Flow Control : High/Low Water */
+	DM9000_iow(DM9000_FCTR, FCTR_HWOT(3) | FCTR_LWOT(8));
+	/* SH FIXME: This looks strange! Flow Control */
+	DM9000_iow(DM9000_FCR, 0x0);
+	/* Special Mode */
+	DM9000_iow(DM9000_SMCR, 0);
+	/* clear TX status */
+	DM9000_iow(DM9000_NSR, NSR_WAKEST | NSR_TX2END | NSR_TX1END);
+	/* Clear interrupt status */
+	DM9000_iow(DM9000_ISR, 0x0f);
 
 	/* Set Node address */
+#ifndef CONFIG_AT91SAM9261EK
 	for (i = 0; i < 6; i++)
 		((u16 *) bd->bi_enetaddr)[i] = read_srom_word(i);
+#endif
+
+	if (is_zero_ether_addr(bd->bi_enetaddr) ||
+	    is_multicast_ether_addr(bd->bi_enetaddr)) {
+		/* try reading from environment */
+		u8 i;
+		char *s, *e;
+		s = getenv ("ethaddr");
+		for (i = 0; i < 6; ++i) {
+			bd->bi_enetaddr[i] = s ?
+				simple_strtoul (s, &e, 16) : 0;
+			if (s)
+				s = (*e) ? e + 1 : e;
+		}
+	}
+
 	printf("MAC: %02x:%02x:%02x:%02x:%02x:%02x\n", bd->bi_enetaddr[0],
 	       bd->bi_enetaddr[1], bd->bi_enetaddr[2], bd->bi_enetaddr[3],
 	       bd->bi_enetaddr[4], bd->bi_enetaddr[5]);
@@ -316,8 +515,11 @@
 	DM9000_DBG("\n");
 
 	/* Activate DM9000 */
-	DM9000_iow(DM9000_RCR, RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN);	/* RX enable */
-	DM9000_iow(DM9000_IMR, IMR_PAR);	/* Enable TX/RX interrupt mask */
+	/* RX enable */
+	DM9000_iow(DM9000_RCR, RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN);
+	/* Enable TX/RX interrupt mask */
+	DM9000_iow(DM9000_IMR, IMR_PAR);
+
 	i = 0;
 	while (!(phy_read(1) & 0x20)) {	/* autonegation complete bit */
 		udelay(1000);
@@ -359,54 +561,37 @@
 int
 eth_send(volatile void *packet, int length)
 {
-	char *data_ptr;
-	u32 tmplen, i;
 	int tmo;
-	DM9000_DBG("eth_send: length: %d\n", length);
-	for (i = 0; i < length; i++) {
-		if (i % 8 == 0)
-			DM9000_DBG("\nSend: 02x: ", i);
-		DM9000_DBG("%02x ", ((unsigned char *) packet)[i]);
-	} DM9000_DBG("\n");
+	struct board_info *db = &dm9000_info;
 
-	/* Move data to DM9000 TX RAM */
-	data_ptr = (char *) packet;
-	DM9000_outb(DM9000_MWCMD, DM9000_IO);
+	DM9000_DMP_PACKET("eth_send", packet, length);
 
-#ifdef CONFIG_DM9000_USE_8BIT
-	/* Byte mode */
-	for (i = 0; i < length; i++)
-		DM9000_outb((data_ptr[i] & 0xff), DM9000_DATA);
-
-#endif				/*  */
-#ifdef CONFIG_DM9000_USE_16BIT
-	tmplen = (length + 1) / 2;
-	for (i = 0; i < tmplen; i++)
-		DM9000_outw(((u16 *) data_ptr)[i], DM9000_DATA);
+	DM9000_iow(DM9000_ISR, IMR_PTM); /* Clear Tx bit in ISR */
 
-#endif				/*  */
-#ifdef CONFIG_DM9000_USE_32BIT
-	tmplen = (length + 3) / 4;
-	for (i = 0; i < tmplen; i++)
-		DM9000_outl(((u32 *) data_ptr)[i], DM9000_DATA);
+	/* Move data to DM9000 TX RAM */
+	DM9000_outb(DM9000_MWCMD, DM9000_IO); /* Prepare for TX-data */
 
-#endif				/*  */
+	/* push the data to the TX-fifo */
+	(db->outblk)(packet, length);
 
 	/* Set TX length to DM9000 */
 	DM9000_iow(DM9000_TXPLL, length & 0xff);
 	DM9000_iow(DM9000_TXPLH, (length >> 8) & 0xff);
 
 	/* Issue TX polling command */
-	DM9000_iow(DM9000_TCR, TCR_TXREQ);	/* Cleared after TX complete */
+	DM9000_iow(DM9000_TCR, TCR_TXREQ); /* Cleared after TX complete */
 
 	/* wait for end of transmission */
 	tmo = get_timer(0) + 5 * CFG_HZ;
-	while (DM9000_ior(DM9000_TCR) & TCR_TXREQ) {
+	while ( !(DM9000_ior(DM9000_NSR) & (NSR_TX1END | NSR_TX2END)) ||
+		!(DM9000_ior(DM9000_ISR) & IMR_PTM) ) {
 		if (get_timer(0) >= tmo) {
 			printf("transmission timeout\n");
 			break;
 		}
 	}
+	DM9000_iow(DM9000_ISR, IMR_PTM); /* Clear Tx bit in ISR */
+
 	DM9000_DBG("transmit done\n\n");
 	return 0;
 }
@@ -435,86 +620,67 @@
 {
 	u8 rxbyte, *rdptr = (u8 *) NetRxPackets[0];
 	u16 RxStatus, RxLen = 0;
-	u32 tmplen, i;
-#ifdef CONFIG_DM9000_USE_32BIT
-	u32 tmpdata;
-#endif
+	struct board_info *db = &dm9000_info;
 
-	/* Check packet ready or not */
-	DM9000_ior(DM9000_MRCMDX);	/* Dummy read */
-	rxbyte = DM9000_inb(DM9000_DATA);	/* Got most updated data */
-	if (rxbyte == 0)
+	/* Check packet ready or not, we must check
+	   the ISR status first for DM9000A */
+	if (!(DM9000_ior(DM9000_ISR) & 0x01)) /* Rx-ISR bit must be set. */
 		return 0;
 
-	/* Status check: this byte must be 0 or 1 */
-	if (rxbyte > 1) {
-		DM9000_iow(DM9000_RCR, 0x00);	/* Stop Device */
-		DM9000_iow(DM9000_ISR, 0x80);	/* Stop INT request */
-		DM9000_DBG("rx status check: %d\n", rxbyte);
-	}
-	DM9000_DBG("receiving packet\n");
-
-	/* A packet ready now  & Get status/length */
-	DM9000_outb(DM9000_MRCMD, DM9000_IO);
+	DM9000_iow(DM9000_ISR, 0x01); /* clear PR status latched in bit 0 */
 
-#ifdef CONFIG_DM9000_USE_8BIT
-	RxStatus = DM9000_inb(DM9000_DATA) + (DM9000_inb(DM9000_DATA) << 8);
-	RxLen = DM9000_inb(DM9000_DATA) + (DM9000_inb(DM9000_DATA) << 8);
-
-#endif				/*  */
-#ifdef CONFIG_DM9000_USE_16BIT
-	RxStatus = DM9000_inw(DM9000_DATA);
-	RxLen = DM9000_inw(DM9000_DATA);
+	/* There is _at least_ 1 package in the fifo, read them all */
+	for (;;) {
+		DM9000_ior(DM9000_MRCMDX);	/* Dummy read */
+
+		/* Get most updated data,
+		   only look at bits 0:1, See application notes DM9000 */
+		rxbyte = DM9000_inb(DM9000_DATA) & 0x03;
+
+		/* Status check: this byte must be 0 or 1 */
+		if (rxbyte > DM9000_PKT_RDY) {
+			DM9000_iow(DM9000_RCR, 0x00);	/* Stop Device */
+			DM9000_iow(DM9000_ISR, 0x80);	/* Stop INT request */
+			printf("DM9000 error: status check fail: 0x%x\n",
+				rxbyte);
+			return 0;
+		}
 
-#endif				/*  */
-#ifdef CONFIG_DM9000_USE_32BIT
-	tmpdata = DM9000_inl(DM9000_DATA);
-	RxStatus = tmpdata;
-	RxLen = tmpdata >> 16;
+		if (rxbyte != DM9000_PKT_RDY)
+			return 0; /* No packet received, ignore */
 
-#endif				/*  */
-	DM9000_DBG("rx status: 0x%04x rx len: %d\n", RxStatus, RxLen);
+		DM9000_DBG("receiving packet\n");
 
-	/* Move data from DM9000 */
-	/* Read received packet from RX SRAM */
-#ifdef CONFIG_DM9000_USE_8BIT
-	for (i = 0; i < RxLen; i++)
-		rdptr[i] = DM9000_inb(DM9000_DATA);
-
-#endif				/*  */
-#ifdef CONFIG_DM9000_USE_16BIT
-	tmplen = (RxLen + 1) / 2;
-	for (i = 0; i < tmplen; i++)
-		((u16 *) rdptr)[i] = DM9000_inw(DM9000_DATA);
+		/* A packet ready now  & Get status/length */
+		(db->rx_status)(&RxStatus, &RxLen);
 
-#endif				/*  */
-#ifdef CONFIG_DM9000_USE_32BIT
-	tmplen = (RxLen + 3) / 4;
-	for (i = 0; i < tmplen; i++)
-		((u32 *) rdptr)[i] = DM9000_inl(DM9000_DATA);
+		DM9000_DBG("rx status: 0x%04x rx len: %d\n", RxStatus, RxLen);
+
+		/* Move data from DM9000 */
+		/* Read received packet from RX SRAM */
+		(db->inblk)(rdptr, RxLen);
+
+		if ((RxStatus & 0xbf00) || (RxLen < 0x40)
+			|| (RxLen > DM9000_PKT_MAX)) {
+			if (RxStatus & 0x100) {
+				printf("rx fifo error\n");
+			}
+			if (RxStatus & 0x200) {
+				printf("rx crc error\n");
+			}
+			if (RxStatus & 0x8000) {
+				printf("rx length error\n");
+			}
+			if (RxLen > DM9000_PKT_MAX) {
+				printf("rx length too big\n");
+				dm9000_reset();
+			}
+		} else {
+			DM9000_DMP_PACKET("eth_rx", rdptr, RxLen);
 
-#endif				/*  */
-	if ((RxStatus & 0xbf00) || (RxLen < 0x40)
-	    || (RxLen > DM9000_PKT_MAX)) {
-		if (RxStatus & 0x100) {
-			printf("rx fifo error\n");
+			DM9000_DBG("passing packet to upper layer\n");
+			NetReceive(NetRxPackets[0], RxLen);
 		}
-		if (RxStatus & 0x200) {
-			printf("rx crc error\n");
-		}
-		if (RxStatus & 0x8000) {
-			printf("rx length error\n");
-		}
-		if (RxLen > DM9000_PKT_MAX) {
-			printf("rx length too big\n");
-			dm9000_reset();
-		}
-	} else {
-
-		/* Pass to upper layer */
-		DM9000_DBG("passing packet to upper layer\n");
-		NetReceive(NetRxPackets[0], RxLen);
-		return RxLen;
 	}
 	return 0;
 }
@@ -522,16 +688,28 @@
 /*
   Read a word data from SROM
 */
-static u16
+u16
 read_srom_word(int offset)
 {
 	DM9000_iow(DM9000_EPAR, offset);
 	DM9000_iow(DM9000_EPCR, 0x4);
-	udelay(200);
+	udelay(8000);
 	DM9000_iow(DM9000_EPCR, 0x0);
 	return (DM9000_ior(DM9000_EPDRL) + (DM9000_ior(DM9000_EPDRH) << 8));
 }
 
+void
+write_srom_word(int offset, u16 val)
+{
+	DM9000_iow(DM9000_EPAR, offset);
+	DM9000_iow(DM9000_EPDRH, ((val >> 8) & 0xff));
+	DM9000_iow(DM9000_EPDRL, (val & 0xff));
+	DM9000_iow(DM9000_EPCR, 0x12);
+	udelay(8000);
+	DM9000_iow(DM9000_EPCR, 0);
+}
+
+
 /*
    Read a byte from I/O port
 */
@@ -563,12 +741,12 @@
 	/* Fill the phyxcer register into REG_0C */
 	DM9000_iow(DM9000_EPAR, DM9000_PHY | reg);
 	DM9000_iow(DM9000_EPCR, 0xc);	/* Issue phyxcer read command */
-	udelay(100);		/* Wait read complete */
+	udelay(100);			/* Wait read complete */
 	DM9000_iow(DM9000_EPCR, 0x0);	/* Clear phyxcer read command */
 	val = (DM9000_ior(DM9000_EPDRH) << 8) | DM9000_ior(DM9000_EPDRL);
 
 	/* The read data keeps on REG_0D & REG_0E */
-	DM9000_DBG("phy_read(%d): %d\n", reg, val);
+	DM9000_DBG("phy_read(0x%x): 0x%x\n", reg, val);
 	return val;
 }
 
@@ -586,8 +764,9 @@
 	DM9000_iow(DM9000_EPDRL, (value & 0xff));
 	DM9000_iow(DM9000_EPDRH, ((value >> 8) & 0xff));
 	DM9000_iow(DM9000_EPCR, 0xa);	/* Issue phyxcer write command */
-	udelay(500);		/* Wait write complete */
+	udelay(500);			/* Wait write complete */
 	DM9000_iow(DM9000_EPCR, 0x0);	/* Clear phyxcer write command */
-	DM9000_DBG("phy_write(reg:%d, value:%d)\n", reg, value);
+	DM9000_DBG("phy_write(reg:0x%x, value:0x%x)\n", reg, value);
 }
-#endif				/* CONFIG_DRIVER_DM9000 */
+
+#endif /* CONFIG_DRIVER_DM9000 */

diff -urN u-boot-1.1.6_jz2440/common/cmd_nand_legacy.c u-boot-1.1.6_nand_ok/common/cmd_nand_legacy.c
--- u-boot-1.1.6_jz2440/common/cmd_nand_legacy.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_nand_ok/common/cmd_nand_legacy.c	2010-11-26 12:54:38.130318758 +0800
@@ -0,0 +1,999 @@
+/*
+ * Driver for NAND support, Rick Bronson
+ * borrowed heavily from:
+ * (c) 1999 Machine Vision Holdings, Inc.
+ * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
+ *
+ * Added 16-bit nand support
+ * (C) 2004 Texas Instruments
+ */
+
+#include <common.h>
+
+
+#ifndef CFG_NAND_LEGACY
+/*
+ *
+ * New NAND support
+ *
+ */
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+
+#include <command.h>
+#include <watchdog.h>
+#include <malloc.h>
+#include <asm/byteorder.h>
+
+#ifdef CONFIG_SHOW_BOOT_PROGRESS
+# include <status_led.h>
+# define SHOW_BOOT_PROGRESS(arg)	show_boot_progress(arg)
+#else
+# define SHOW_BOOT_PROGRESS(arg)
+#endif
+
+#include <jffs2/jffs2.h>
+#include <nand.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
+
+/* parition handling routines */
+int mtdparts_init(void);
+int id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num);
+int find_dev_and_part(const char *id, struct mtd_device **dev,
+		u8 *part_num, struct part_info **part);
+#endif
+
+extern nand_info_t nand_info[];       /* info for NAND chips */
+
+static int nand_dump_oob(nand_info_t *nand, ulong off)
+{
+	return 0;
+}
+
+static int nand_dump(nand_info_t *nand, ulong off)
+{
+	int i;
+	u_char *buf, *p;
+
+	buf = malloc(nand->oobblock + nand->oobsize);
+	if (!buf) {
+		puts("No memory for page buffer\n");
+		return 1;
+	}
+	off &= ~(nand->oobblock - 1);
+	i = nand_read_raw(nand, buf, off, nand->oobblock, nand->oobsize);
+	if (i < 0) {
+		printf("Error (%d) reading page %08x\n", i, off);
+		free(buf);
+		return 1;
+	}
+	printf("Page %08x dump:\n", off);
+	i = nand->oobblock >> 4; p = buf;
+	while (i--) {
+		printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x"
+			"  %02x %02x %02x %02x %02x %02x %02x %02x\n",
+			p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
+			p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+		p += 16;
+	}
+	puts("OOB:\n");
+	i = nand->oobsize >> 3;
+	while (i--) {
+		printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
+			p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
+		p += 8;
+	}
+	free(buf);
+
+	return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+
+static inline int str2long(char *p, ulong *num)
+{
+	char *endptr;
+
+	*num = simple_strtoul(p, &endptr, 16);
+	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
+}
+
+static int
+arg_off_size(int argc, char *argv[], nand_info_t *nand, ulong *off, ulong *size)
+{
+	int idx = nand_curr_device;
+#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
+	struct mtd_device *dev;
+	struct part_info *part;
+	u8 pnum;
+
+	if (argc >= 1 && !(str2long(argv[0], off))) {
+		if ((mtdparts_init() == 0) &&
+		    (find_dev_and_part(argv[0], &dev, &pnum, &part) == 0)) {
+			if (dev->id->type != MTD_DEV_TYPE_NAND) {
+				puts("not a NAND device\n");
+				return -1;
+			}
+			*off = part->offset;
+			if (argc >= 2) {
+				if (!(str2long(argv[1], size))) {
+					printf("'%s' is not a number\n", argv[1]);
+					return -1;
+				}
+				if (*size > part->size)
+					*size = part->size;
+			} else {
+				*size = part->size;
+			}
+			idx = dev->id->num;
+			*nand = nand_info[idx];
+			goto out;
+		}
+	}
+#endif
+
+	if (argc >= 1) {
+		if (!(str2long(argv[0], off))) {
+			printf("'%s' is not a number\n", argv[0]);
+			return -1;
+		}
+	} else {
+		*off = 0;
+	}
+
+	if (argc >= 2) {
+		if (!(str2long(argv[1], size))) {
+			printf("'%s' is not a number\n", argv[1]);
+			return -1;
+		}
+	} else {
+		*size = nand->size - *off;
+	}
+
+#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
+out:
+#endif
+	printf("device %d ", idx);
+	if (*size == nand->size)
+		puts("whole chip\n");
+	else
+		printf("offset 0x%x, size 0x%x\n", *off, *size);
+	return 0;
+}
+
+int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	int i, dev, ret;
+	ulong addr, off, size;
+	char *cmd, *s;
+	nand_info_t *nand;
+	int quiet = 0;
+	const char *quiet_str = getenv("quiet");
+
+	/* at least two arguments please */
+	if (argc < 2)
+		goto usage;
+
+	if (quiet_str)
+		quiet = simple_strtoul(quiet_str, NULL, 0) != 0;
+
+	cmd = argv[1];
+
+	if (strcmp(cmd, "info") == 0) {
+
+		putc('\n');
+		for (i = 0; i < CFG_MAX_NAND_DEVICE; i++) {
+			if (nand_info[i].name)
+				printf("Device %d: %s, sector size %lu KiB\n",
+					i, nand_info[i].name,
+					nand_info[i].erasesize >> 10);
+		}
+		return 0;
+	}
+
+	if (strcmp(cmd, "device") == 0) {
+
+		if (argc < 3) {
+			if ((nand_curr_device < 0) ||
+			    (nand_curr_device >= CFG_MAX_NAND_DEVICE))
+				puts("\nno devices available\n");
+			else
+				printf("\nDevice %d: %s\n", nand_curr_device,
+					nand_info[nand_curr_device].name);
+			return 0;
+		}
+		dev = (int)simple_strtoul(argv[2], NULL, 10);
+		if (dev < 0 || dev >= CFG_MAX_NAND_DEVICE || !nand_info[dev].name) {
+			puts("No such device\n");
+			return 1;
+		}
+		printf("Device %d: %s", dev, nand_info[dev].name);
+		puts("... is now current device\n");
+		nand_curr_device = dev;
+
+#ifdef CFG_NAND_SELECT_DEVICE
+		/*
+		 * Select the chip in the board/cpu specific driver
+		 */
+		board_nand_select_device(nand_info[dev].priv, dev);
+#endif
+
+		return 0;
+	}
+
+	if (strcmp(cmd, "bad") != 0 && strcmp(cmd, "erase") != 0 &&
+	    strncmp(cmd, "dump", 4) != 0 &&
+	    strncmp(cmd, "read", 4) != 0 && strncmp(cmd, "write", 5) != 0 &&
+	    strcmp(cmd, "scrub") != 0 && strcmp(cmd, "markbad") != 0 &&
+	    strcmp(cmd, "biterr") != 0 &&
+	    strcmp(cmd, "lock") != 0 && strcmp(cmd, "unlock") != 0 )
+		goto usage;
+
+	/* the following commands operate on the current device */
+	if (nand_curr_device < 0 || nand_curr_device >= CFG_MAX_NAND_DEVICE ||
+	    !nand_info[nand_curr_device].name) {
+		puts("\nno devices available\n");
+		return 1;
+	}
+	nand = &nand_info[nand_curr_device];
+
+	if (strcmp(cmd, "bad") == 0) {
+		printf("\nDevice %d bad blocks:\n", nand_curr_device);
+		for (off = 0; off < nand->size; off += nand->erasesize)
+			if (nand_block_isbad(nand, off))
+				printf("  %08x\n", off);
+		return 0;
+	}
+
+	/*
+	 * Syntax is:
+	 *   0    1     2       3    4
+	 *   nand erase [clean] [off size]
+	 */
+	if (strcmp(cmd, "erase") == 0 || strcmp(cmd, "scrub") == 0) {
+		nand_erase_options_t opts;
+		/* "clean" at index 2 means request to write cleanmarker */
+		int clean = argc > 2 && !strcmp("clean", argv[2]);
+		int o = clean ? 3 : 2;
+		int scrub = !strcmp(cmd, "scrub");
+
+		printf("\nNAND %s: ", scrub ? "scrub" : "erase");
+		/* skip first two or three arguments, look for offset and size */
+		if (arg_off_size(argc - o, argv + o, nand, &off, &size) != 0)
+			return 1;
+
+		memset(&opts, 0, sizeof(opts));
+		opts.offset = off;
+		opts.length = size;
+		opts.jffs2  = clean;
+		opts.quiet  = quiet;
+
+		if (scrub) {
+			puts("Warning: "
+			     "scrub option will erase all factory set "
+			     "bad blocks!\n"
+			     "         "
+			     "There is no reliable way to recover them.\n"
+			     "         "
+			     "Use this command only for testing purposes "
+			     "if you\n"
+			     "         "
+			     "are sure of what you are doing!\n"
+			     "\nReally scrub this NAND flash? <y/N>\n");
+
+			if (getc() == 'y' && getc() == '\r') {
+				opts.scrub = 1;
+			} else {
+				puts("scrub aborted\n");
+				return -1;
+			}
+		}
+		ret = nand_erase_opts(nand, &opts);
+		printf("%s\n", ret ? "ERROR" : "OK");
+
+		return ret == 0 ? 0 : 1;
+	}
+
+	if (strncmp(cmd, "dump", 4) == 0) {
+		if (argc < 3)
+			goto usage;
+
+		s = strchr(cmd, '.');
+		off = (int)simple_strtoul(argv[2], NULL, 16);
+
+		if (s != NULL && strcmp(s, ".oob") == 0)
+			ret = nand_dump_oob(nand, off);
+		else
+			ret = nand_dump(nand, off);
+
+		return ret == 0 ? 1 : 0;
+
+	}
+
+	/* read write */
+	if (strncmp(cmd, "read", 4) == 0 || strncmp(cmd, "write", 5) == 0) {
+		int read;
+
+		if (argc < 4)
+			goto usage;
+
+		addr = (ulong)simple_strtoul(argv[2], NULL, 16);
+
+		read = strncmp(cmd, "read", 4) == 0; /* 1 = read, 0 = write */
+		printf("\nNAND %s: ", read ? "read" : "write");
+		if (arg_off_size(argc - 3, argv + 3, nand, &off, &size) != 0)
+			return 1;
+
+		s = strchr(cmd, '.');
+		if (s != NULL &&
+		    (!strcmp(s, ".jffs2") || !strcmp(s, ".e") || !strcmp(s, ".i"))) {
+			if (read) {
+				/* read */
+				nand_read_options_t opts;
+				memset(&opts, 0, sizeof(opts));
+				opts.buffer	= (u_char*) addr;
+				opts.length	= size;
+				opts.offset	= off;
+				opts.quiet      = quiet;
+				ret = nand_read_opts(nand, &opts);
+			} else {
+				/* write */
+				nand_write_options_t opts;
+				memset(&opts, 0, sizeof(opts));
+				opts.buffer	= (u_char*) addr;
+				opts.length	= size;
+				opts.offset	= off;
+				/* opts.forcejffs2 = 1; */
+				opts.pad	= 1;
+				opts.blockalign = 1;
+				opts.quiet      = quiet;
+				ret = nand_write_opts(nand, &opts);
+			}
+		} else {
+			if (read)
+				ret = nand_read(nand, off, &size, (u_char *)addr);
+			else
+				ret = nand_write(nand, off, &size, (u_char *)addr);
+		}
+
+		printf(" %d bytes %s: %s\n", size,
+		       read ? "read" : "written", ret ? "ERROR" : "OK");
+
+		return ret == 0 ? 0 : 1;
+	}
+
+	if (strcmp(cmd, "markbad") == 0) {
+		addr = (ulong)simple_strtoul(argv[2], NULL, 16);
+
+		int ret = nand->block_markbad(nand, addr);
+		if (ret == 0) {
+			printf("block 0x%08lx successfully marked as bad\n",
+			       (ulong) addr);
+			return 0;
+		} else {
+			printf("block 0x%08lx NOT marked as bad! ERROR %d\n",
+			       (ulong) addr, ret);
+		}
+		return 1;
+	}
+	if (strcmp(cmd, "biterr") == 0) {
+		/* todo */
+		return 1;
+	}
+
+	if (strcmp(cmd, "lock") == 0) {
+		int tight  = 0;
+		int status = 0;
+		if (argc == 3) {
+			if (!strcmp("tight", argv[2]))
+				tight = 1;
+			if (!strcmp("status", argv[2]))
+				status = 1;
+		}
+
+		if (status) {
+			ulong block_start = 0;
+			ulong off;
+			int last_status = -1;
+
+			struct nand_chip *nand_chip = nand->priv;
+			/* check the WP bit */
+			nand_chip->cmdfunc (nand, NAND_CMD_STATUS, -1, -1);
+			printf("device is %swrite protected\n",
+			       (nand_chip->read_byte(nand) & 0x80 ?
+				"NOT " : "" ) );
+
+			for (off = 0; off < nand->size; off += nand->oobblock) {
+				int s = nand_get_lock_status(nand, off);
+
+				/* print message only if status has changed
+				 * or at end of chip
+				 */
+				if (off == nand->size - nand->oobblock
+				    || (s != last_status && off != 0))	{
+
+					printf("%08x - %08x: %8d pages %s%s%s\n",
+					       block_start,
+					       off-1,
+					       (off-block_start)/nand->oobblock,
+					       ((last_status & NAND_LOCK_STATUS_TIGHT) ? "TIGHT " : ""),
+					       ((last_status & NAND_LOCK_STATUS_LOCK) ? "LOCK " : ""),
+					       ((last_status & NAND_LOCK_STATUS_UNLOCK) ? "UNLOCK " : ""));
+				}
+
+				last_status = s;
+		       }
+		} else {
+			if (!nand_lock(nand, tight)) {
+				puts("NAND flash successfully locked\n");
+			} else {
+				puts("Error locking NAND flash\n");
+				return 1;
+			}
+		}
+		return 0;
+	}
+
+	if (strcmp(cmd, "unlock") == 0) {
+		if (arg_off_size(argc - 2, argv + 2, nand, &off, &size) < 0)
+			return 1;
+
+		if (!nand_unlock(nand, off, size)) {
+			puts("NAND flash successfully unlocked\n");
+		} else {
+			puts("Error unlocking NAND flash, "
+			     "write and erase will probably fail\n");
+			return 1;
+		}
+		return 0;
+	}
+
+usage:
+	printf("Usage:\n%s\n", cmdtp->usage);
+	return 1;
+}
+
+U_BOOT_CMD(nand, 5, 1, do_nand,
+	"nand    - NAND sub-system\n",
+	"info                  - show available NAND devices\n"
+	"nand device [dev]     - show or set current device\n"
+	"nand read[.jffs2]     - addr off|partition size\n"
+	"nand write[.jffs2]    - addr off|partiton size - read/write `size' bytes starting\n"
+	"    at offset `off' to/from memory address `addr'\n"
+	"nand erase [clean] [off size] - erase `size' bytes from\n"
+	"    offset `off' (entire device if not specified)\n"
+	"nand bad - show bad blocks\n"
+	"nand dump[.oob] off - dump page\n"
+	"nand scrub - really clean NAND erasing bad blocks (UNSAFE)\n"
+	"nand markbad off - mark bad block at offset (UNSAFE)\n"
+	"nand biterr off - make a bit error at offset (UNSAFE)\n"
+	"nand lock [tight] [status] - bring nand to lock state or display locked pages\n"
+	"nand unlock [offset] [size] - unlock section\n");
+
+static int nand_load_image(cmd_tbl_t *cmdtp, nand_info_t *nand,
+			   ulong offset, ulong addr, char *cmd)
+{
+	int r;
+	char *ep;
+	ulong cnt;
+	image_header_t *hdr;
+
+	printf("\nLoading from %s, offset 0x%lx\n", nand->name, offset);
+
+	cnt = nand->oobblock;
+	r = nand_read(nand, offset, &cnt, (u_char *) addr);
+	if (r) {
+		puts("** Read error\n");
+		SHOW_BOOT_PROGRESS(-1);
+		return 1;
+	}
+
+	hdr = (image_header_t *) addr;
+
+	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
+		printf("\n** Bad Magic Number 0x%x **\n", hdr->ih_magic);
+		SHOW_BOOT_PROGRESS(-1);
+		return 1;
+	}
+
+	print_image_hdr(hdr);
+
+	cnt = (ntohl(hdr->ih_size) + sizeof (image_header_t));
+
+	r = nand_read(nand, offset, &cnt, (u_char *) addr);
+	if (r) {
+		puts("** Read error\n");
+		SHOW_BOOT_PROGRESS(-1);
+		return 1;
+	}
+
+	/* Loading ok, update default load address */
+
+	load_addr = addr;
+
+	/* Check if we should attempt an auto-start */
+	if (((ep = getenv("autostart")) != NULL) && (strcmp(ep, "yes") == 0)) {
+		char *local_args[2];
+		extern int do_bootm(cmd_tbl_t *, int, int, char *[]);
+
+		local_args[0] = cmd;
+		local_args[1] = NULL;
+
+		printf("Automatic boot of image at addr 0x%08lx ...\n", addr);
+
+		do_bootm(cmdtp, 0, 1, local_args);
+		return 1;
+	}
+	return 0;
+}
+
+int do_nandboot(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	char *boot_device = NULL;
+	int idx;
+	ulong addr, offset = 0;
+#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
+	struct mtd_device *dev;
+	struct part_info *part;
+	u8 pnum;
+
+	if (argc >= 2) {
+		char *p = (argc == 2) ? argv[1] : argv[2];
+		if (!(str2long(p, &addr)) && (mtdparts_init() == 0) &&
+		    (find_dev_and_part(p, &dev, &pnum, &part) == 0)) {
+			if (dev->id->type != MTD_DEV_TYPE_NAND) {
+				puts("Not a NAND device\n");
+				return 1;
+			}
+			if (argc > 3)
+				goto usage;
+			if (argc == 3)
+				addr = simple_strtoul(argv[2], NULL, 16);
+			else
+				addr = CFG_LOAD_ADDR;
+			return nand_load_image(cmdtp, &nand_info[dev->id->num],
+					       part->offset, addr, argv[0]);
+		}
+	}
+#endif
+
+	switch (argc) {
+	case 1:
+		addr = CFG_LOAD_ADDR;
+		boot_device = getenv("bootdevice");
+		break;
+	case 2:
+		addr = simple_strtoul(argv[1], NULL, 16);
+		boot_device = getenv("bootdevice");
+		break;
+	case 3:
+		addr = simple_strtoul(argv[1], NULL, 16);
+		boot_device = argv[2];
+		break;
+	case 4:
+		addr = simple_strtoul(argv[1], NULL, 16);
+		boot_device = argv[2];
+		offset = simple_strtoul(argv[3], NULL, 16);
+		break;
+	default:
+#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
+usage:
+#endif
+		printf("Usage:\n%s\n", cmdtp->usage);
+		SHOW_BOOT_PROGRESS(-1);
+		return 1;
+	}
+
+	if (!boot_device) {
+		puts("\n** No boot device **\n");
+		SHOW_BOOT_PROGRESS(-1);
+		return 1;
+	}
+
+	idx = simple_strtoul(boot_device, NULL, 16);
+
+	if (idx < 0 || idx >= CFG_MAX_NAND_DEVICE || !nand_info[idx].name) {
+		printf("\n** Device %d not available\n", idx);
+		SHOW_BOOT_PROGRESS(-1);
+		return 1;
+	}
+
+	return nand_load_image(cmdtp, &nand_info[idx], offset, addr, argv[0]);
+}
+
+U_BOOT_CMD(nboot, 4, 1, do_nandboot,
+	"nboot   - boot from NAND device\n",
+	"[partition] | [[[loadAddr] dev] offset]\n");
+
+#endif				/* (CONFIG_COMMANDS & CFG_CMD_NAND) */
+
+#else /* CFG_NAND_LEGACY */
+/*
+ *
+ * Legacy NAND support - to be phased out
+ *
+ */
+#include <command.h>
+#include <malloc.h>
+#include <asm/io.h>
+#include <watchdog.h>
+
+#ifdef CONFIG_SHOW_BOOT_PROGRESS
+# include <status_led.h>
+# define SHOW_BOOT_PROGRESS(arg)	show_boot_progress(arg)
+#else
+# define SHOW_BOOT_PROGRESS(arg)
+#endif
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+#include <linux/mtd/nand_legacy.h>
+#if 0
+#include <linux/mtd/nand_ids.h>
+#include <jffs2/jffs2.h>
+#endif
+
+#ifdef CONFIG_OMAP1510
+void archflashwp(void *archdata, int wp);
+#endif
+
+#define ROUND_DOWN(value,boundary)      ((value) & (~((boundary)-1)))
+
+#undef	NAND_DEBUG
+#undef	PSYCHO_DEBUG
+
+/* ****************** WARNING *********************
+ * When ALLOW_ERASE_BAD_DEBUG is non-zero the erase command will
+ * erase (or at least attempt to erase) blocks that are marked
+ * bad. This can be very handy if you are _sure_ that the block
+ * is OK, say because you marked a good block bad to test bad
+ * block handling and you are done testing, or if you have
+ * accidentally marked blocks bad.
+ *
+ * Erasing factory marked bad blocks is a _bad_ idea. If the
+ * erase succeeds there is no reliable way to find them again,
+ * and attempting to program or erase bad blocks can affect
+ * the data in _other_ (good) blocks.
+ */
+#define	 ALLOW_ERASE_BAD_DEBUG 0
+
+#define CONFIG_MTD_NAND_ECC  /* enable ECC */
+#define CONFIG_MTD_NAND_ECC_JFFS2
+
+/* bits for nand_legacy_rw() `cmd'; or together as needed */
+#define NANDRW_READ	0x01
+#define NANDRW_WRITE	0x00
+#define NANDRW_JFFS2	0x02
+#define NANDRW_JFFS2_SKIP	0x04
+#define NANDRW_YAFFS	0x08    /* to write yaffs image, www.100ask.net */
+
+/*
+ * Imports from nand_legacy.c
+ */
+extern struct nand_chip nand_dev_desc[CFG_MAX_NAND_DEVICE];
+extern int curr_device;
+extern int nand_legacy_erase(struct nand_chip *nand, size_t ofs,
+			    size_t len, int clean);
+extern int nand_legacy_rw(struct nand_chip *nand, int cmd, size_t start,
+			 size_t len, size_t *retlen, u_char *buf);
+extern void nand_print(struct nand_chip *nand);
+extern void nand_print_bad(struct nand_chip *nand);
+extern int nand_read_oob(struct nand_chip *nand, size_t ofs,
+			       size_t len, size_t *retlen, u_char *buf);
+extern int nand_write_oob(struct nand_chip *nand, size_t ofs,
+				size_t len, size_t *retlen, const u_char *buf);
+
+
+int do_nand (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    int rcode = 0;
+
+    switch (argc) {
+    case 0:
+    case 1:
+	printf ("Usage:\n%s\n", cmdtp->usage);
+	return 1;
+    case 2:
+	if (strcmp(argv[1],"info") == 0) {
+		int i;
+
+		putc ('\n');
+
+		for (i=0; i<CFG_MAX_NAND_DEVICE; ++i) {
+			if(nand_dev_desc[i].ChipID == NAND_ChipID_UNKNOWN)
+				continue; /* list only known devices */
+			printf ("Device %d: ", i);
+			nand_print(&nand_dev_desc[i]);
+		}
+		return 0;
+
+	} else if (strcmp(argv[1],"device") == 0) {
+		if ((curr_device < 0) || (curr_device >= CFG_MAX_NAND_DEVICE)) {
+			puts ("\nno devices available\n");
+			return 1;
+		}
+		printf ("\nDevice %d: ", curr_device);
+		nand_print(&nand_dev_desc[curr_device]);
+		return 0;
+
+	} else if (strcmp(argv[1],"bad") == 0) {
+		if ((curr_device < 0) || (curr_device >= CFG_MAX_NAND_DEVICE)) {
+			puts ("\nno devices available\n");
+			return 1;
+		}
+		printf ("\nDevice %d bad blocks:\n", curr_device);
+		nand_print_bad(&nand_dev_desc[curr_device]);
+		return 0;
+
+	}
+	printf ("Usage:\n%s\n", cmdtp->usage);
+	return 1;
+    case 3:
+	if (strcmp(argv[1],"device") == 0) {
+		int dev = (int)simple_strtoul(argv[2], NULL, 10);
+
+		printf ("\nDevice %d: ", dev);
+		if (dev >= CFG_MAX_NAND_DEVICE) {
+			puts ("unknown device\n");
+			return 1;
+		}
+		nand_print(&nand_dev_desc[dev]);
+		/*nand_print (dev);*/
+
+		if (nand_dev_desc[dev].ChipID == NAND_ChipID_UNKNOWN) {
+			return 1;
+		}
+
+		curr_device = dev;
+
+		puts ("... is now current device\n");
+
+		return 0;
+	}
+	else if (strcmp(argv[1],"erase") == 0 && strcmp(argv[2], "clean") == 0) {
+		struct nand_chip* nand = &nand_dev_desc[curr_device];
+		ulong off = 0;
+		ulong size = nand->totlen;
+		int ret;
+
+		printf ("\nNAND erase: device %d offset %ld, size %ld ... ",
+			curr_device, off, size);
+
+		ret = nand_legacy_erase (nand, off, size, 1);
+
+		printf("%s\n", ret ? "ERROR" : "OK");
+
+		return ret;
+	}
+
+	printf ("Usage:\n%s\n", cmdtp->usage);
+	return 1;
+    default:
+	/* at least 4 args */
+
+	if (strncmp(argv[1], "read", 4) == 0 ||
+	    strncmp(argv[1], "write", 5) == 0) {
+		ulong addr = simple_strtoul(argv[2], NULL, 16);
+		ulong off  = simple_strtoul(argv[3], NULL, 16);
+		ulong size = simple_strtoul(argv[4], NULL, 16);
+		int cmd    = (strncmp(argv[1], "read", 4) == 0) ?
+				NANDRW_READ : NANDRW_WRITE;
+		int ret, total;
+		char* cmdtail = strchr(argv[1], '.');
+
+		// if (cmdtail && !strncmp(cmdtail, ".oob", 2)) {
+		/* fixed by www.100ask.net */
+		if (cmdtail && !strcmp(cmdtail, ".oob")) {
+			/* read out-of-band data */
+			if (cmd & NANDRW_READ) {
+				ret = nand_read_oob(nand_dev_desc + curr_device,
+						    off, size, (size_t *)&total,
+						    (u_char*)addr);
+			}
+			else {
+				ret = nand_write_oob(nand_dev_desc + curr_device,
+						     off, size, (size_t *)&total,
+						     (u_char*)addr);
+			}
+			return ret;
+		}
+		//else if (cmdtail && !strncmp(cmdtail, ".jffs2", 2))
+		/* fixed by www.100ask.net */
+		else if (cmdtail && !strcmp(cmdtail, ".jffs2"))
+			cmd |= NANDRW_JFFS2;	/* skip bad blocks */
+		//else if (cmdtail && !strncmp(cmdtail, ".jffs2s", 2)) {
+		/* fixed by www.100ask.net */
+		else if ((cmd & NANDRW_WRITE) && cmdtail && !strcmp(cmdtail, ".jffs2s")) {
+			cmd |= NANDRW_JFFS2;	/* skip bad blocks (on read too) */
+			if (cmd & NANDRW_READ)
+				cmd |= NANDRW_JFFS2_SKIP;	/* skip bad blocks (on read too) */
+		}
+        /* write yaffs image, www.100ask.net */
+		else if (cmdtail && !strcmp(cmdtail, ".yaffs")) {
+			cmd |= NANDRW_YAFFS;
+		}
+#ifdef SXNI855T
+		/* need ".e" same as ".j" for compatibility with older units */
+		else if (cmdtail && !strcmp(cmdtail, ".e"))
+			cmd |= NANDRW_JFFS2;	/* skip bad blocks */
+#endif
+#ifdef CFG_NAND_SKIP_BAD_DOT_I
+		/* need ".i" same as ".jffs2s" for compatibility with older units (esd) */
+		/* ".i" for image -> read skips bad block (no 0xff) */
+		else if (cmdtail && !strcmp(cmdtail, ".i")) {
+			cmd |= NANDRW_JFFS2;	/* skip bad blocks (on read too) */
+			if (cmd & NANDRW_READ)
+				cmd |= NANDRW_JFFS2_SKIP;	/* skip bad blocks (on read too) */
+		}
+#endif /* CFG_NAND_SKIP_BAD_DOT_I */
+		else if (cmdtail) {
+			printf ("Usage:\n%s\n", cmdtp->usage);
+			return 1;
+		}
+
+		printf ("\nNAND %s: device %d offset %ld, size %ld ...\n",
+			(cmd & NANDRW_READ) ? "read" : "write",
+			curr_device, off, size);
+
+		ret = nand_legacy_rw(nand_dev_desc + curr_device, cmd, off, size,
+			     (size_t *)&total, (u_char*)addr);
+
+		printf (" %d bytes %s: %s\n", total,
+			(cmd & NANDRW_READ) ? "read" : "written",
+			ret ? "ERROR" : "OK");
+
+		return ret;
+	} else if (strcmp(argv[1],"erase") == 0 &&
+		   (argc == 4 || strcmp("clean", argv[2]) == 0)) {
+		int clean = argc == 5;
+		ulong off = simple_strtoul(argv[2 + clean], NULL, 16);
+		ulong size = simple_strtoul(argv[3 + clean], NULL, 16);
+		int ret;
+
+		printf ("\nNAND erase: device %d offset %ld, size %ld ...\n",
+			curr_device, off, size);
+
+		ret = nand_legacy_erase (nand_dev_desc + curr_device,
+					off, size, clean);
+
+		printf("%s\n", ret ? "ERROR" : "OK");
+
+		return ret;
+	} else {
+		printf ("Usage:\n%s\n", cmdtp->usage);
+		rcode = 1;
+	}
+
+	return rcode;
+    }
+}
+
+U_BOOT_CMD(
+	nand,	5,	1,	do_nand,
+	"nand    - legacy NAND sub-system\n",
+	"info  - show available NAND devices\n"
+	"nand device [dev] - show or set current device\n"
+	"nand read[.jffs2[s]]  addr off size\n"
+	"nand write[.jffs2] addr off size - read/write `size' bytes starting\n"
+	"    at offset `off' to/from memory address `addr'\n"
+	"nand erase [clean] [off size] - erase `size' bytes from\n"
+	"    offset `off' (entire device if not specified)\n"
+	"nand bad - show bad blocks\n"
+	"nand read.oob addr off size - read out-of-band data\n"
+	"nand write.oob addr off size - read out-of-band data\n"
+	"nand write.yaffs addr off size - write the `size' byte yaffs image starting\n"
+	"    at offset `off' from memory address `addr'\n"
+);
+
+int do_nandboot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	char *boot_device = NULL;
+	char *ep;
+	int dev;
+	ulong cnt;
+	ulong addr;
+	ulong offset = 0;
+	image_header_t *hdr;
+	int rcode = 0;
+	switch (argc) {
+	case 1:
+		addr = CFG_LOAD_ADDR;
+		boot_device = getenv ("bootdevice");
+		break;
+	case 2:
+		addr = simple_strtoul(argv[1], NULL, 16);
+		boot_device = getenv ("bootdevice");
+		break;
+	case 3:
+		addr = simple_strtoul(argv[1], NULL, 16);
+		boot_device = argv[2];
+		break;
+	case 4:
+		addr = simple_strtoul(argv[1], NULL, 16);
+		boot_device = argv[2];
+		offset = simple_strtoul(argv[3], NULL, 16);
+		break;
+	default:
+		printf ("Usage:\n%s\n", cmdtp->usage);
+		SHOW_BOOT_PROGRESS (-1);
+		return 1;
+	}
+
+	if (!boot_device) {
+		puts ("\n** No boot device **\n");
+		SHOW_BOOT_PROGRESS (-1);
+		return 1;
+	}
+
+	dev = simple_strtoul(boot_device, &ep, 16);
+
+	if ((dev >= CFG_MAX_NAND_DEVICE) ||
+	    (nand_dev_desc[dev].ChipID == NAND_ChipID_UNKNOWN)) {
+		printf ("\n** Device %d not available\n", dev);
+		SHOW_BOOT_PROGRESS (-1);
+		return 1;
+	}
+
+	printf ("\nLoading from device %d: %s at 0x%lx (offset 0x%lx)\n",
+		dev, nand_dev_desc[dev].name, nand_dev_desc[dev].IO_ADDR,
+		offset);
+
+	if (nand_legacy_rw (nand_dev_desc + dev, NANDRW_READ, offset,
+			SECTORSIZE, NULL, (u_char *)addr)) {
+		printf ("** Read error on %d\n", dev);
+		SHOW_BOOT_PROGRESS (-1);
+		return 1;
+	}
+
+	hdr = (image_header_t *)addr;
+
+	if (ntohl(hdr->ih_magic) == IH_MAGIC) {
+
+		print_image_hdr (hdr);
+
+		cnt = (ntohl(hdr->ih_size) + sizeof(image_header_t));
+		cnt -= SECTORSIZE;
+	} else {
+		printf ("\n** Bad Magic Number 0x%x **\n", ntohl(hdr->ih_magic));
+		SHOW_BOOT_PROGRESS (-1);
+		return 1;
+	}
+
+	if (nand_legacy_rw (nand_dev_desc + dev, NANDRW_READ,
+			offset + SECTORSIZE, cnt, NULL,
+			(u_char *)(addr+SECTORSIZE))) {
+		printf ("** Read error on %d\n", dev);
+		SHOW_BOOT_PROGRESS (-1);
+		return 1;
+	}
+
+	/* Loading ok, update default load address */
+
+	load_addr = addr;
+
+	/* Check if we should attempt an auto-start */
+	if (((ep = getenv("autostart")) != NULL) && (strcmp(ep,"yes") == 0)) {
+		char *local_args[2];
+		extern int do_bootm (cmd_tbl_t *, int, int, char *[]);
+
+		local_args[0] = argv[0];
+		local_args[1] = NULL;
+
+		printf ("Automatic boot of image at addr 0x%08lx ...\n", addr);
+
+		do_bootm (cmdtp, 0, 1, local_args);
+		rcode = 1;
+	}
+	return rcode;
+}
+
+U_BOOT_CMD(
+	nboot,	4,	1,	do_nandboot,
+	"nboot   - boot from NAND device\n",
+	"loadAddr dev\n"
+);
+
+#endif /* (CONFIG_COMMANDS & CFG_CMD_NAND) */
+
+#endif /* CFG_NAND_LEGACY */
diff -urN u-boot-1.1.6_jz2440/drivers/nand_legacy/nand_legacy.c u-boot-1.1.6_nand_ok/drivers/nand_legacy/nand_legacy.c
--- u-boot-1.1.6_jz2440/drivers/nand_legacy/nand_legacy.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_nand_ok/drivers/nand_legacy/nand_legacy.c	2010-11-26 12:54:38.414220270 +0800
@@ -60,6 +60,7 @@
 #define NANDRW_WRITE	0x00
 #define NANDRW_JFFS2	0x02
 #define NANDRW_JFFS2_SKIP	0x04
+#define NANDRW_YAFFS	0x08    /* to write yaffs image, www.100ask.net */
 
 
 /*
@@ -185,6 +186,31 @@
 	 */
 	unsigned long eblk = ~0;	/* force mismatch on first pass */
 	unsigned long erasesize = nand->erasesize;
+    int bfirstyaffsblk = 1;
+    int page;
+    unsigned long badblk=0, prgmblk=0;
+    unsigned long badblks=0, prgmblks = 0;
+    unsigned long allblks;
+
+    allblks = (erasesize/nand->oobblock)*(nand->oobblock+nand->oobsize);
+    allblks = (len + allblks - 1) / allblks;
+    
+	if ((cmd & NANDRW_YAFFS) && (len % (nand->oobblock + nand->oobsize))) {
+        printf("Length of the yaffs image should be times of (%d +%d), now it is %d\n", nand->oobblock, nand->oobsize, len);
+        return -1;
+    }
+
+    if ((cmd & NANDRW_YAFFS) && (start % erasesize)) {
+        printf("Start address of the flash should be %d align\n", erasesize);
+        return -1;
+    }
+
+	if (cmd & (NANDRW_WRITE | NANDRW_YAFFS)) {
+        printf("Flash params: oobblock = %d, oobsize = %d, erasesize = %d\n", nand->oobblock, nand->oobsize, nand->erasesize);
+    	printf("Programming NAND with yaffs image, length = %d\n", len);
+        printf(" Block Programming(addr/count) --- Block bad(addr/count) --- Block programed/All(%%)\n");
+        printf("------------------------------------------------------------------------------------\n");
+	}
 
 	while (len) {
 		if ((start & (-erasesize)) != eblk) {
@@ -193,6 +219,8 @@
 			 */
 			eblk = start & (-erasesize); /* start of block */
 			if (check_block(nand, eblk)) {
+                badblk = eblk;
+                badblks++;
 				if (cmd == (NANDRW_READ | NANDRW_JFFS2)) {
 					while (len > 0 &&
 					       start - eblk < erasesize) {
@@ -209,6 +237,12 @@
 					/* skip bad block */
 					start += erasesize;
 					continue;
+				} else if (cmd == (NANDRW_WRITE | NANDRW_YAFFS)) {
+				    /* by www.100ask.net */
+                    printf("       0x%08x/%05d               0x%08x/%05d          %05d/%05d=%02d%%\r", prgmblk, prgmblks, badblk, badblks, prgmblks, allblks, prgmblks*100/allblks);
+					/* skip bad block */
+					start += erasesize;
+					continue;
 				} else {
 					ret = 1;
 					break;
@@ -221,7 +255,33 @@
 		if((start != ROUND_DOWN(start, 0x200)) || (len < 0x200))
 			printf("Warning block writes should be at least 512 bytes and start on a 512 byte boundry\n");
 
-		if (cmd & NANDRW_READ) {
+        /* for yaffs, by www.100ask.net */
+		if (cmd & (NANDRW_WRITE | NANDRW_YAFFS)) {
+			/* Do some programming, but not in the first block */			
+            if (!bfirstyaffsblk) {
+                prgmblk = start;
+                prgmblks++;
+                printf("       0x%08x/%05d               0x%08x/%05d          %05d/%05d=%02d%%\r", prgmblk, prgmblks, badblk, badblks, prgmblks, allblks, prgmblks*100/allblks);
+                for (page = 0; (page < erasesize/nand->oobblock) && (len - page*(nand->oobblock+nand->oobsize) > 0); page++) {
+        			ret = nand_write_ecc(nand, start+page*nand->oobblock,
+        					    nand->oobblock, (size_t *)&n,
+        					    (u_char*)buf+page*(nand->oobblock+nand->oobsize), (u_char *)0); /* without ecc */
+                    if (!ret) 
+                        ret = nand_write_oob(nand, start+page*nand->oobblock,
+    						     nand->oobsize, (size_t *)&n,
+    						     (u_char*)buf+page*(nand->oobblock+nand->oobsize)+nand->oobblock);
+                    if (ret)
+                        break;
+                }
+                n = page * (nand->oobblock+nand->oobsize);
+            } else {
+                bfirstyaffsblk = 0;
+                n = 0;
+                start += erasesize;     /* skip first block */
+                ret = 0;
+                page = 0;
+            }
+		} else if (cmd & NANDRW_READ) {
 			ret = nand_read_ecc(nand, start,
 					   min(len, eblk + erasesize - start),
 					   (size_t *)&n, (u_char*)buf, (u_char *)eccbuf);
@@ -234,14 +294,18 @@
 		if (ret)
 			break;
 
-		start  += n;
+		if (cmd & (NANDRW_WRITE | NANDRW_YAFFS))
+    		start  += page * nand->oobblock;
+        else
+    		start  += n;
+        
 		buf   += n;
 		total += n;
 		len   -= n;
 	}
 	if (retlen)
 		*retlen = total;
-
+    printf("\n");
 	return ret;
 }
 
@@ -759,6 +823,7 @@
 
 /*
  *	Nand_page_program function is used for write and writev !
+ *  Change By www.100ask.net, if ecc_code is null, write without ECC
  */
 static int nand_write_page (struct nand_chip *nand,
 			    int page, int col, int last, u_char * ecc_code)
@@ -766,6 +831,7 @@
 
 	int i;
 	unsigned long nandptr = nand->IO_ADDR;
+    int writecnt;
 
 #ifdef CONFIG_MTD_NAND_ECC
 #ifdef CONFIG_MTD_NAND_VERIFY_WRITE
@@ -778,8 +844,9 @@
 
 #ifdef CONFIG_MTD_NAND_ECC
 	/* Zero out the ECC array */
-	for (i = 0; i < 6; i++)
-		ecc_code[i] = 0x00;
+    if (ecc_code)   /* www.100ask.net */
+    	for (i = 0; i < 6; i++)
+    		ecc_code[i] = 0x00;
 
 	/* Read back previous written data, if col > 0 */
 	if (col) {
@@ -807,7 +874,9 @@
 	}
 
 	/* Calculate and write the ECC if we have enough data */
-	if ((col < nand->eccsize) && (last >= nand->eccsize)) {
+	//if ((col < nand->eccsize) && (last >= nand->eccsize)) {
+    /* if ecc_code is null, write without ecc, www.100ask.net */
+	if (ecc_code && (col < nand->eccsize) && (last >= nand->eccsize)) {
 		nand_calculate_ecc (&nand->data_buf[0], &(ecc_code[0]));
 		for (i = 0; i < 3; i++) {
 			nand->data_buf[(nand->oobblock +
@@ -820,7 +889,9 @@
 	}
 
 	/* Calculate and write the second ECC if we have enough data */
-	if ((nand->oobblock == 512) && (last == nand->oobblock)) {
+	//if ((nand->oobblock == 512) && (last == nand->oobblock)) {
+    /* if ecc_code is null, write without ecc, www.100ask.net */
+	if (ecc_code && (nand->oobblock == 512) && (last == nand->oobblock)) {
 		nand_calculate_ecc (&nand->data_buf[256], &(ecc_code[3]));
 		for (i = 3; i < 6; i++) {
 			nand->data_buf[(nand->oobblock +
@@ -851,15 +922,21 @@
 			      (page << nand->page_shift) + col);
 	}
 
+    /* if ecc_code is null, write without ecc, www.100ask.net */
+    if (ecc_code)
+        writecnt = nand->oobblock + nand->oobsize;
+    else
+        writecnt = nand->oobblock;
+
 	/* Write out complete page of data */
 	if (nand->bus16) {
-		for (i = 0; i < (nand->oobblock + nand->oobsize); i += 2) {
+		for (i = 0; i < writecnt; i += 2) {
 			WRITE_NAND (nand->data_buf[i] +
 				    (nand->data_buf[i + 1] << 8),
 				    nand->IO_ADDR);
 		}
 	} else {
-		for (i = 0; i < (nand->oobblock + nand->oobsize); i++)
+		for (i = 0; i < writecnt; i++)
 			WRITE_NAND (nand->data_buf[i], nand->IO_ADDR);
 	}
 
@@ -933,35 +1010,38 @@
 	 * We also want to check that the ECC bytes wrote
 	 * correctly for the same reasons stated above.
 	 */
-	NanD_Command (nand, NAND_CMD_READOOB);
-	if (nand->bus16) {
-		NanD_Address (nand, ADDR_COLUMN_PAGE,
-			      (page << nand->page_shift) + (col >> 1));
-	} else {
-		NanD_Address (nand, ADDR_COLUMN_PAGE,
-			      (page << nand->page_shift) + col);
-	}
-	if (nand->bus16) {
-		for (i = 0; i < nand->oobsize; i += 2) {
-			u16 val;
-
-			val = READ_NAND (nand->IO_ADDR);
-			nand->data_buf[i] = val & 0xff;
-			nand->data_buf[i + 1] = val >> 8;
-		}
-	} else {
-		for (i = 0; i < nand->oobsize; i++) {
-			nand->data_buf[i] = READ_NAND (nand->IO_ADDR);
-		}
-	}
-	for (i = 0; i < ecc_bytes; i++) {
-		if ((nand->data_buf[(oob_config.ecc_pos[i])] != ecc_code[i]) && ecc_code[i]) {
-			printf ("%s: Failed ECC write "
-				"verify, page 0x%08x, "
-				"%6i bytes were succesful\n",
-				__FUNCTION__, page, i);
-			return -1;
-		}
+    /* if ecc_code is null, write without ecc, www.100ask.net */
+	if (ecc_code) {
+    	NanD_Command (nand, NAND_CMD_READOOB);
+    	if (nand->bus16) {
+    		NanD_Address (nand, ADDR_COLUMN_PAGE,
+    			      (page << nand->page_shift) + (col >> 1));
+    	} else {
+    		NanD_Address (nand, ADDR_COLUMN_PAGE,
+    			      (page << nand->page_shift) + col);
+    	}
+    	if (nand->bus16) {
+    		for (i = 0; i < nand->oobsize; i += 2) {
+    			u16 val;
+
+    			val = READ_NAND (nand->IO_ADDR);
+    			nand->data_buf[i] = val & 0xff;
+    			nand->data_buf[i + 1] = val >> 8;
+    		}
+    	} else {
+    		for (i = 0; i < nand->oobsize; i++) {
+    			nand->data_buf[i] = READ_NAND (nand->IO_ADDR);
+    		}
+    	}
+    	for (i = 0; i < ecc_bytes; i++) {
+    		if ((nand->data_buf[(oob_config.ecc_pos[i])] != ecc_code[i]) && ecc_code[i]) {
+    			printf ("%s: Failed ECC write "
+    				"verify, page 0x%08x, "
+    				"%6i bytes were succesful\n",
+    				__FUNCTION__, page, i);
+    			return -1;
+    		}
+    	}
 	}
 #endif	/* CONFIG_MTD_NAND_ECC */
 #endif	/* CONFIG_MTD_NAND_VERIFY_WRITE */
@@ -1053,6 +1133,7 @@
 	return ret;
 }
 
+
 /* read from the 16 bytes of oob data that correspond to a 512 byte
  * page or 2 256-byte pages.
  */
@@ -1132,6 +1213,17 @@
 
 	/* issue the Read2 command to set the pointer to the Spare Data Area. */
 	NanD_Command(nand, NAND_CMD_READOOB);
+
+/* bug fixed by www.100ask.net
+ * write oob sequence: 
+ *  1. NAND_CMD_READOOB
+ *  2. NAND_CMD_SEQIN
+ *  3. Address
+ *  4. Data
+ *  5. NAND_CMD_PAGEPROG
+ *  6. NAND_CMD_STATUS
+ */
+#if 0   
 	if (nand->bus16) {
  		NanD_Address(nand, ADDR_COLUMN_PAGE,
 			     ((ofs >> nand->page_shift) << nand->page_shift) +
@@ -1139,7 +1231,7 @@
 	} else {
  		NanD_Address(nand, ADDR_COLUMN_PAGE, ofs);
 	}
-
+#endif
 	/* update address for 2M x 8bit devices. OOB starts on the second */
 	/* page to maintain compatibility with nand_read_ecc. */
 	if (nand->page256) {
diff -urN u-boot-1.1.6/common/Makefile u-boot-1.1.6_nand_ok/common/Makefile
--- u-boot-1.1.6/common/Makefile	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_nand_ok/common/Makefile	2010-11-26 12:54:38.150155640 +0800
@@ -40,7 +40,7 @@
 	  cmd_nand.o cmd_net.o cmd_nvedit.o \
 	  cmd_pci.o cmd_pcmcia.o cmd_portio.o \
 	  cmd_reginfo.o cmd_reiser.o cmd_scsi.o cmd_spi.o cmd_universe.o \
-	  cmd_usb.o cmd_vfd.o \
+	  #cmd_usb.o cmd_usbslave.o cmd_menu.o cmd_vfd.o \
 	  command.o console.o devices.o dlmalloc.o docecc.o \
 	  environment.o env_common.o \
 	  env_nand.o env_dataflash.o env_flash.o env_eeprom.o \
diff -urN u-boot-1.1.6/Makefile u-boot-1.1.6_nand_ok/Makefile
--- u-boot-1.1.6/Makefile	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_nand_ok/Makefile	2010-11-26 12:54:37.830153999 +0800
@@ -206,8 +206,8 @@
 LIBS += drivers/libdrivers.a
 LIBS += drivers/nand/libnand.a
 LIBS += drivers/nand_legacy/libnand_legacy.a
+LIBS += drivers/usb/libusb.a
 LIBS += drivers/sk98lin/libsk98lin.a
-LIBS += post/libpost.a post/cpu/libcpu.a
 LIBS += common/libcommon.a
 LIBS += $(BOARDLIBS)
 
@@ -266,11 +266,15 @@
 			-Map u-boot.map -o u-boot
 
 $(OBJS):
+	echo $(OBJS)	
 		$(MAKE) -C cpu/$(CPU) $(if $(REMOTE_BUILD),$@,$(notdir $@))
 
 $(LIBS):
 		$(MAKE) -C $(dir $(subst $(obj),,$@))
 
+usb:
+	$(MAKE) -C drivers/usb
+
 $(SUBDIRS):
 		$(MAKE) -C $@ all
 
@@ -1879,6 +1883,9 @@
 smdk2410_config	:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm920t smdk2410 NULL s3c24x0
 
+100ask24x0_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t 100ask24x0 NULL s3c24x0
+
 SX1_config :		unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm925t sx1

diff -urN u-boot-1.1.6/drivers/nand/nand_util.c u-boot-1.1.6_jz2440/drivers/nand/nand_util.c
--- u-boot-1.1.6/drivers/nand/nand_util.c	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_jz2440/drivers/nand/nand_util.c	2010-11-26 12:54:38.402251606 +0800
@@ -4,12 +4,12 @@
  * Copyright (C) 2006 by Weiss-Electronic GmbH.
  * All rights reserved.
  *
- * @author:	Guido Classen <clagix@gmail.com>
- * @descr:	NAND Flash support
+ * @author: Guido Classen <clagix@gmail.com>
+ * @descr:  NAND Flash support
  * @references: borrowed heavily from Linux mtd-utils code:
- *		flash_eraseall.c by Arcom Control System Ltd
- *		nandwrite.c by Steven J. Hill (sjhill@realitydiluted.com)
- *			       and Thomas Gleixner (tglx@linutronix.de)
+ *      flash_eraseall.c by Arcom Control System Ltd
+ *      nandwrite.c by Steven J. Hill (sjhill@realitydiluted.com)
+ *                 and Thomas Gleixner (tglx@linutronix.de)
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -20,7 +20,7 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
@@ -42,7 +42,7 @@
 #include <jffs2/jffs2.h>
 
 typedef struct erase_info erase_info_t;
-typedef struct mtd_info	  mtd_info_t;
+typedef struct mtd_info   mtd_info_t;
 
 /* support only for native endian JFFS2 */
 #define cpu_to_je16(x) (x)
@@ -51,199 +51,199 @@
 /*****************************************************************************/
 static int nand_block_bad_scrub(struct mtd_info *mtd, loff_t ofs, int getchip)
 {
-	return 0;
+    return 0;
 }
 
 /**
  * nand_erase_opts: - erase NAND flash with support for various options
- *		      (jffs2 formating)
+ *            (jffs2 formating)
  *
- * @param meminfo	NAND device to erase
- * @param opts		options,  @see struct nand_erase_options
- * @return		0 in case of success
+ * @param meminfo   NAND device to erase
+ * @param opts      options,  @see struct nand_erase_options
+ * @return      0 in case of success
  *
  * This code is ported from flash_eraseall.c from Linux mtd utils by
  * Arcom Control System Ltd.
  */
 int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts)
 {
-	struct jffs2_unknown_node cleanmarker;
-	int clmpos = 0;
-	int clmlen = 8;
-	erase_info_t erase;
-	ulong erase_length;
-	int isNAND;
-	int bbtest = 1;
-	int result;
-	int percent_complete = -1;
-	int (*nand_block_bad_old)(struct mtd_info *, loff_t, int) = NULL;
-	const char *mtd_device = meminfo->name;
-
-	memset(&erase, 0, sizeof(erase));
-
-	erase.mtd = meminfo;
-	erase.len  = meminfo->erasesize;
-	erase.addr = opts->offset;
-	erase_length = opts->length;
-
-	isNAND = meminfo->type == MTD_NANDFLASH ? 1 : 0;
-
-	if (opts->jffs2) {
-		cleanmarker.magic = cpu_to_je16 (JFFS2_MAGIC_BITMASK);
-		cleanmarker.nodetype = cpu_to_je16 (JFFS2_NODETYPE_CLEANMARKER);
-		if (isNAND) {
-			struct nand_oobinfo *oobinfo = &meminfo->oobinfo;
-
-			/* check for autoplacement */
-			if (oobinfo->useecc == MTD_NANDECC_AUTOPLACE) {
-				/* get the position of the free bytes */
-				if (!oobinfo->oobfree[0][1]) {
-					printf(" Eeep. Autoplacement selected "
-					       "and no empty space in oob\n");
-					return -1;
-				}
-				clmpos = oobinfo->oobfree[0][0];
-				clmlen = oobinfo->oobfree[0][1];
-				if (clmlen > 8)
-					clmlen = 8;
-			} else {
-				/* legacy mode */
-				switch (meminfo->oobsize) {
-				case 8:
-					clmpos = 6;
-					clmlen = 2;
-					break;
-				case 16:
-					clmpos = 8;
-					clmlen = 8;
-					break;
-				case 64:
-					clmpos = 16;
-					clmlen = 8;
-					break;
-				}
-			}
-
-			cleanmarker.totlen = cpu_to_je32(8);
-		} else {
-			cleanmarker.totlen =
-				cpu_to_je32(sizeof(struct jffs2_unknown_node));
-		}
-		cleanmarker.hdr_crc =  cpu_to_je32(
-			crc32_no_comp(0, (unsigned char *) &cleanmarker,
-				      sizeof(struct jffs2_unknown_node) - 4));
-	}
-
-	/* scrub option allows to erase badblock. To prevent internal
-	 * check from erase() method, set block check method to dummy
-	 * and disable bad block table while erasing.
-	 */
-	if (opts->scrub) {
-		struct nand_chip *priv_nand = meminfo->priv;
-
-		nand_block_bad_old = priv_nand->block_bad;
-		priv_nand->block_bad = nand_block_bad_scrub;
-		/* we don't need the bad block table anymore...
-		 * after scrub, there are no bad blocks left!
-		 */
-		if (priv_nand->bbt) {
-			kfree(priv_nand->bbt);
-		}
-		priv_nand->bbt = NULL;
-	}
-
-	for (;
-	     erase.addr < opts->offset + erase_length;
-	     erase.addr += meminfo->erasesize) {
-
-		WATCHDOG_RESET ();
-
-		if (!opts->scrub && bbtest) {
-			int ret = meminfo->block_isbad(meminfo, erase.addr);
-			if (ret > 0) {
-				if (!opts->quiet)
-					printf("\rSkipping bad block at  "
-					       "0x%08x                   "
-					       "                         \n",
-					       erase.addr);
-				continue;
-
-			} else if (ret < 0) {
-				printf("\n%s: MTD get bad block failed: %d\n",
-				       mtd_device,
-				       ret);
-				return -1;
-			}
-		}
-
-		result = meminfo->erase(meminfo, &erase);
-		if (result != 0) {
-			printf("\n%s: MTD Erase failure: %d\n",
-			       mtd_device, result);
-			continue;
-		}
-
-		/* format for JFFS2 ? */
-		if (opts->jffs2) {
-
-			/* write cleanmarker */
-			if (isNAND) {
-				size_t written;
-				result = meminfo->write_oob(meminfo,
-							    erase.addr + clmpos,
-							    clmlen,
-							    &written,
-							    (unsigned char *)
-							    &cleanmarker);
-				if (result != 0) {
-					printf("\n%s: MTD writeoob failure: %d\n",
-					       mtd_device, result);
-					continue;
-				}
-			} else {
-				printf("\n%s: this erase routine only supports"
-				       " NAND devices!\n",
-				       mtd_device);
-			}
-		}
-
-		if (!opts->quiet) {
-			int percent = (int)
-				((unsigned long long)
-				 (erase.addr+meminfo->erasesize-opts->offset)
-				 * 100 / erase_length);
-
-			/* output progress message only at whole percent
-			 * steps to reduce the number of messages printed
-			 * on (slow) serial consoles
-			 */
-			if (percent != percent_complete) {
-				percent_complete = percent;
-
-				printf("\rErasing at 0x%x -- %3d%% complete.",
-				       erase.addr, percent);
-
-				if (opts->jffs2 && result == 0)
-					printf(" Cleanmarker written at 0x%x.",
-					       erase.addr);
-			}
-		}
-	}
-	if (!opts->quiet)
-		printf("\n");
-
-	if (nand_block_bad_old) {
-		struct nand_chip *priv_nand = meminfo->priv;
-
-		priv_nand->block_bad = nand_block_bad_old;
-		priv_nand->scan_bbt(meminfo);
-	}
+    struct jffs2_unknown_node cleanmarker;
+    int clmpos = 0;
+    int clmlen = 8;
+    erase_info_t erase;
+    ulong erase_length;
+    int isNAND;
+    int bbtest = 1;
+    int result;
+    int percent_complete = -1;
+    int (*nand_block_bad_old)(struct mtd_info *, loff_t, int) = NULL;
+    const char *mtd_device = meminfo->name;
+
+    memset(&erase, 0, sizeof(erase));
+
+    erase.mtd = meminfo;
+    erase.len  = meminfo->erasesize;
+    erase.addr = opts->offset;
+    erase_length = opts->length;
+
+    isNAND = meminfo->type == MTD_NANDFLASH ? 1 : 0;
+
+    if (opts->jffs2) {
+        cleanmarker.magic = cpu_to_je16 (JFFS2_MAGIC_BITMASK);
+        cleanmarker.nodetype = cpu_to_je16 (JFFS2_NODETYPE_CLEANMARKER);
+        if (isNAND) {
+            struct nand_oobinfo *oobinfo = &meminfo->oobinfo;
+
+            /* check for autoplacement */
+            if (oobinfo->useecc == MTD_NANDECC_AUTOPLACE) {
+                /* get the position of the free bytes */
+                if (!oobinfo->oobfree[0][1]) {
+                    printf(" Eeep. Autoplacement selected "
+                           "and no empty space in oob\n");
+                    return -1;
+                }
+                clmpos = oobinfo->oobfree[0][0];
+                clmlen = oobinfo->oobfree[0][1];
+                if (clmlen > 8)
+                    clmlen = 8;
+            } else {
+                /* legacy mode */
+                switch (meminfo->oobsize) {
+                case 8:
+                    clmpos = 6;
+                    clmlen = 2;
+                    break;
+                case 16:
+                    clmpos = 8;
+                    clmlen = 8;
+                    break;
+                case 64:
+                    clmpos = 16;
+                    clmlen = 8;
+                    break;
+                }
+            }
+
+            cleanmarker.totlen = cpu_to_je32(8);
+        } else {
+            cleanmarker.totlen =
+                cpu_to_je32(sizeof(struct jffs2_unknown_node));
+        }
+        cleanmarker.hdr_crc =  cpu_to_je32(
+            crc32_no_comp(0, (unsigned char *) &cleanmarker,
+                      sizeof(struct jffs2_unknown_node) - 4));
+    }
+
+    /* scrub option allows to erase badblock. To prevent internal
+     * check from erase() method, set block check method to dummy
+     * and disable bad block table while erasing.
+     */
+    if (opts->scrub) {
+        struct nand_chip *priv_nand = meminfo->priv;
+
+        nand_block_bad_old = priv_nand->block_bad;
+        priv_nand->block_bad = nand_block_bad_scrub;
+        /* we don't need the bad block table anymore...
+         * after scrub, there are no bad blocks left!
+         */
+        if (priv_nand->bbt) {
+            kfree(priv_nand->bbt);
+        }
+        priv_nand->bbt = NULL;
+    }
+
+    for (;
+         erase.addr < opts->offset + erase_length;
+         erase.addr += meminfo->erasesize) {
+
+        WATCHDOG_RESET ();
+
+        if (!opts->scrub && bbtest) {
+            int ret = meminfo->block_isbad(meminfo, erase.addr);
+            if (ret > 0) {
+                if (!opts->quiet)
+                    printf("\rSkipping bad block at  "
+                           "0x%08x                   "
+                           "                         \n",
+                           erase.addr);
+                continue;
+
+            } else if (ret < 0) {
+                printf("\n%s: MTD get bad block failed: %d\n",
+                       mtd_device,
+                       ret);
+                return -1;
+            }
+        }
+
+        result = meminfo->erase(meminfo, &erase);
+        if (result != 0) {
+            printf("\n%s: MTD Erase failure: %d\n",
+                   mtd_device, result);
+            continue;
+        }
+
+        /* format for JFFS2 ? */
+        if (opts->jffs2) {
+
+            /* write cleanmarker */
+            if (isNAND) {
+                size_t written;
+                result = meminfo->write_oob(meminfo,
+                                erase.addr + clmpos,
+                                clmlen,
+                                &written,
+                                (unsigned char *)
+                                &cleanmarker);
+                if (result != 0) {
+                    printf("\n%s: MTD writeoob failure: %d\n",
+                           mtd_device, result);
+                    continue;
+                }
+            } else {
+                printf("\n%s: this erase routine only supports"
+                       " NAND devices!\n",
+                       mtd_device);
+            }
+        }
+
+        if (!opts->quiet) {
+            int percent = (int)
+                ((unsigned long long)
+                 (erase.addr+meminfo->erasesize-opts->offset)
+                 * 100 / erase_length);
+
+            /* output progress message only at whole percent
+             * steps to reduce the number of messages printed
+             * on (slow) serial consoles
+             */
+            if (percent != percent_complete) {
+                percent_complete = percent;
+
+                printf("\rErasing at 0x%x -- %3d%% complete.",
+                       erase.addr, percent);
+
+                if (opts->jffs2 && result == 0)
+                    printf(" Cleanmarker written at 0x%x.",
+                           erase.addr);
+            }
+        }
+    }
+    if (!opts->quiet)
+        printf("\n");
+
+    if (nand_block_bad_old) {
+        struct nand_chip *priv_nand = meminfo->priv;
+
+        priv_nand->block_bad = nand_block_bad_old;
+        priv_nand->scan_bbt(meminfo);
+    }
 
-	return 0;
+    return 0;
 }
 
-#define MAX_PAGE_SIZE	2048
-#define MAX_OOB_SIZE	64
+#define MAX_PAGE_SIZE   2048
+#define MAX_OOB_SIZE    64
 
 /*
  * buffer array used for writing data
@@ -253,454 +253,485 @@
 
 /* OOB layouts to pass into the kernel as default */
 static struct nand_oobinfo none_oobinfo = {
-	.useecc = MTD_NANDECC_OFF,
+    .useecc = MTD_NANDECC_OFF,
 };
 
 static struct nand_oobinfo jffs2_oobinfo = {
-	.useecc = MTD_NANDECC_PLACE,
-	.eccbytes = 6,
-	.eccpos = { 0, 1, 2, 3, 6, 7 }
+    .useecc = MTD_NANDECC_PLACE,
+    .eccbytes = 6,
+    .eccpos = { 0, 1, 2, 3, 6, 7 }
 };
 
 static struct nand_oobinfo yaffs_oobinfo = {
-	.useecc = MTD_NANDECC_PLACE,
-	.eccbytes = 6,
-	.eccpos = { 8, 9, 10, 13, 14, 15}
+    .useecc = MTD_NANDECC_PLACE,
+    .eccbytes = 6,
+    .eccpos = { 8, 9, 10, 13, 14, 15}
 };
 
 static struct nand_oobinfo autoplace_oobinfo = {
-	.useecc = MTD_NANDECC_AUTOPLACE
+    .useecc = MTD_NANDECC_AUTOPLACE
 };
 
 /**
  * nand_write_opts: - write image to NAND flash with support for various options
  *
- * @param meminfo	NAND device to erase
- * @param opts		write options (@see nand_write_options)
- * @return		0 in case of success
+ * @param meminfo   NAND device to erase
+ * @param opts      write options (@see nand_write_options)
+ * @return      0 in case of success
  *
  * This code is ported from nandwrite.c from Linux mtd utils by
  * Steven J. Hill and Thomas Gleixner.
  */
 int nand_write_opts(nand_info_t *meminfo, const nand_write_options_t *opts)
 {
-	int imglen = 0;
-	int pagelen;
-	int baderaseblock;
-	int blockstart = -1;
-	loff_t offs;
-	int readlen;
-	int oobinfochanged = 0;
-	int percent_complete = -1;
-	struct nand_oobinfo old_oobinfo;
-	ulong mtdoffset = opts->offset;
-	ulong erasesize_blockalign;
-	u_char *buffer = opts->buffer;
-	size_t written;
-	int result;
-
-	if (opts->pad && opts->writeoob) {
-		printf("Can't pad when oob data is present.\n");
-		return -1;
-	}
-
-	/* set erasesize to specified number of blocks - to match
-	 * jffs2 (virtual) block size */
-	if (opts->blockalign == 0) {
-		erasesize_blockalign = meminfo->erasesize;
-	} else {
-		erasesize_blockalign = meminfo->erasesize * opts->blockalign;
-	}
-
-	/* make sure device page sizes are valid */
-	if (!(meminfo->oobsize == 16 && meminfo->oobblock == 512)
-	    && !(meminfo->oobsize == 8 && meminfo->oobblock == 256)
-	    && !(meminfo->oobsize == 64 && meminfo->oobblock == 2048)) {
-		printf("Unknown flash (not normal NAND)\n");
-		return -1;
-	}
-
-	/* read the current oob info */
-	memcpy(&old_oobinfo, &meminfo->oobinfo, sizeof(old_oobinfo));
-
-	/* write without ecc? */
-	if (opts->noecc) {
-		memcpy(&meminfo->oobinfo, &none_oobinfo,
-		       sizeof(meminfo->oobinfo));
-		oobinfochanged = 1;
-	}
-
-	/* autoplace ECC? */
-	if (opts->autoplace && (old_oobinfo.useecc != MTD_NANDECC_AUTOPLACE)) {
-
-		memcpy(&meminfo->oobinfo, &autoplace_oobinfo,
-		       sizeof(meminfo->oobinfo));
-		oobinfochanged = 1;
-	}
-
-	/* force OOB layout for jffs2 or yaffs? */
-	if (opts->forcejffs2 || opts->forceyaffs) {
-		struct nand_oobinfo *oobsel =
-			opts->forcejffs2 ? &jffs2_oobinfo : &yaffs_oobinfo;
-
-		if (meminfo->oobsize == 8) {
-			if (opts->forceyaffs) {
-				printf("YAFSS cannot operate on "
-				       "256 Byte page size\n");
-				goto restoreoob;
-			}
-			/* Adjust number of ecc bytes */
-			jffs2_oobinfo.eccbytes = 3;
-		}
-
-		memcpy(&meminfo->oobinfo, oobsel, sizeof(meminfo->oobinfo));
-	}
-
-	/* get image length */
-	imglen = opts->length;
-	pagelen = meminfo->oobblock
-		+ ((opts->writeoob != 0) ? meminfo->oobsize : 0);
-
-	/* check, if file is pagealigned */
-	if ((!opts->pad) && ((imglen % pagelen) != 0)) {
-		printf("Input block length is not page aligned\n");
-		goto restoreoob;
-	}
-
-	/* check, if length fits into device */
-	if (((imglen / pagelen) * meminfo->oobblock)
-	     > (meminfo->size - opts->offset)) {
-		printf("Image %d bytes, NAND page %d bytes, "
-		       "OOB area %u bytes, device size %u bytes\n",
-		       imglen, pagelen, meminfo->oobblock, meminfo->size);
-		printf("Input block does not fit into device\n");
-		goto restoreoob;
-	}
-
-	if (!opts->quiet)
-		printf("\n");
-
-	/* get data from input and write to the device */
-	while (imglen && (mtdoffset < meminfo->size)) {
-
-		WATCHDOG_RESET ();
-
-		/*
-		 * new eraseblock, check for bad block(s). Stay in the
-		 * loop to be sure if the offset changes because of
-		 * a bad block, that the next block that will be
-		 * written to is also checked. Thus avoiding errors if
-		 * the block(s) after the skipped block(s) is also bad
-		 * (number of blocks depending on the blockalign
-		 */
-		while (blockstart != (mtdoffset & (~erasesize_blockalign+1))) {
-			blockstart = mtdoffset & (~erasesize_blockalign+1);
-			offs = blockstart;
-			baderaseblock = 0;
-
-			/* check all the blocks in an erase block for
-			 * bad blocks */
-			do {
-				int ret = meminfo->block_isbad(meminfo, offs);
-
-				if (ret < 0) {
-					printf("Bad block check failed\n");
-					goto restoreoob;
-				}
-				if (ret == 1) {
-					baderaseblock = 1;
-					if (!opts->quiet)
-						printf("\rBad block at 0x%lx "
-						       "in erase block from "
-						       "0x%x will be skipped\n",
-						       (long) offs,
-						       blockstart);
-				}
-
-				if (baderaseblock) {
-					mtdoffset = blockstart
-						+ erasesize_blockalign;
-				}
-				offs +=	 erasesize_blockalign
-					/ opts->blockalign;
-			} while (offs < blockstart + erasesize_blockalign);
-		}
-
-		readlen = meminfo->oobblock;
-		if (opts->pad && (imglen < readlen)) {
-			readlen = imglen;
-			memset(data_buf + readlen, 0xff,
-			       meminfo->oobblock - readlen);
-		}
-
-		/* read page data from input memory buffer */
-		memcpy(data_buf, buffer, readlen);
-		buffer += readlen;
-
-		if (opts->writeoob) {
-			/* read OOB data from input memory block, exit
-			 * on failure */
-			memcpy(oob_buf, buffer, meminfo->oobsize);
-			buffer += meminfo->oobsize;
-
-			/* write OOB data first, as ecc will be placed
-			 * in there*/
-			result = meminfo->write_oob(meminfo,
-						    mtdoffset,
-						    meminfo->oobsize,
-						    &written,
-						    (unsigned char *)
-						    &oob_buf);
-
-			if (result != 0) {
-				printf("\nMTD writeoob failure: %d\n",
-				       result);
-				goto restoreoob;
-			}
-			imglen -= meminfo->oobsize;
-		}
-
-		/* write out the page data */
-		result = meminfo->write(meminfo,
-					mtdoffset,
-					meminfo->oobblock,
-					&written,
-					(unsigned char *) &data_buf);
-
-		if (result != 0) {
-			printf("writing NAND page at offset 0x%lx failed\n",
-			       mtdoffset);
-			goto restoreoob;
-		}
-		imglen -= readlen;
-
-		if (!opts->quiet) {
-			int percent = (int)
-				((unsigned long long)
-				 (opts->length-imglen) * 100
-				 / opts->length);
-			/* output progress message only at whole percent
-			 * steps to reduce the number of messages printed
-			 * on (slow) serial consoles
-			 */
-			if (percent != percent_complete) {
-				printf("\rWriting data at 0x%x "
-				       "-- %3d%% complete.",
-				       mtdoffset, percent);
-				percent_complete = percent;
-			}
-		}
+    int imglen = 0;
+    int pagelen;
+    int baderaseblock;
+    int blockstart = -1;
+    loff_t offs;
+    int readlen;
+    int oobinfochanged = 0;
+    int percent_complete = -1;
+    struct nand_oobinfo old_oobinfo;
+    ulong mtdoffset = opts->offset;
+    ulong erasesize_blockalign;
+    u_char *buffer = opts->buffer;
+    size_t written;
+    int result;
+    int skipfirstblk = opts->skipfirstblk;
+
+    if (opts->pad && opts->writeoob) {
+        printf("Can't pad when oob data is present.\n");
+        return -1;
+    }
+
+    /* set erasesize to specified number of blocks - to match
+     * jffs2 (virtual) block size */
+    if (opts->blockalign == 0) {
+        erasesize_blockalign = meminfo->erasesize;
+    } else {
+        erasesize_blockalign = meminfo->erasesize * opts->blockalign;
+    }
+
+    /* make sure device page sizes are valid */
+    if (!(meminfo->oobsize == 16 && meminfo->oobblock == 512)
+        && !(meminfo->oobsize == 8 && meminfo->oobblock == 256)
+        && !(meminfo->oobsize == 64 && meminfo->oobblock == 2048)) {
+        printf("Unknown flash (not normal NAND)\n");
+        return -1;
+    }
+
+    /* read the current oob info */
+    memcpy(&old_oobinfo, &meminfo->oobinfo, sizeof(old_oobinfo));
+
+    /* write without ecc? */
+    if (opts->noecc) {
+        memcpy(&meminfo->oobinfo, &none_oobinfo,
+               sizeof(meminfo->oobinfo));
+        oobinfochanged = 1;
+    }
+
+    /* autoplace ECC? */
+    if (opts->autoplace && (old_oobinfo.useecc != MTD_NANDECC_AUTOPLACE)) {
+
+        memcpy(&meminfo->oobinfo, &autoplace_oobinfo,
+               sizeof(meminfo->oobinfo));
+        oobinfochanged = 1;
+    }
+
+    /* force OOB layout for jffs2 or yaffs? */
+    if (opts->forcejffs2 || opts->forceyaffs) {
+        struct nand_oobinfo *oobsel =
+            opts->forcejffs2 ? &jffs2_oobinfo : &yaffs_oobinfo;
+
+        if (meminfo->oobsize == 8) {
+            if (opts->forceyaffs) {
+                printf("YAFSS cannot operate on "
+                       "256 Byte page size\n");
+                goto restoreoob;
+            }
+            /* Adjust number of ecc bytes */
+            jffs2_oobinfo.eccbytes = 3;
+        }
+
+        memcpy(&meminfo->oobinfo, oobsel, sizeof(meminfo->oobinfo));
+		oobinfochanged = 1;   /* add by thisway.diy, www.100ask.net */
+    }
+
+    /* get image length */
+    imglen = opts->length;
+    pagelen = meminfo->oobblock
+        + ((opts->writeoob != 0) ? meminfo->oobsize : 0);
+
+    /* check, if file is pagealigned */
+    if ((!opts->pad) && ((imglen % pagelen) != 0)) {
+        printf("Input block length is not page aligned\n");
+        goto restoreoob;
+    }
+
+    /* check, if length fits into device */
+    if (((imglen / pagelen) * meminfo->oobblock)
+         > (meminfo->size - opts->offset)) {
+        printf("Image %d bytes, NAND page %d bytes, "
+               "OOB area %u bytes, device size %u bytes\n",
+               imglen, pagelen, meminfo->oobblock, meminfo->size);
+        printf("Input block does not fit into device\n");
+        goto restoreoob;
+    }
+
+    if (!opts->quiet)
+        printf("\n");
+
+    /* get data from input and write to the device */
+    while (imglen && (mtdoffset < meminfo->size)) {
+
+        WATCHDOG_RESET ();
+
+        /*
+         * new eraseblock, check for bad block(s). Stay in the
+         * loop to be sure if the offset changes because of
+         * a bad block, that the next block that will be
+         * written to is also checked. Thus avoiding errors if
+         * the block(s) after the skipped block(s) is also bad
+         * (number of blocks depending on the blockalign
+         */
+        while (blockstart != (mtdoffset & (~erasesize_blockalign+1))) {
+            blockstart = mtdoffset & (~erasesize_blockalign+1);
+            offs = blockstart;
+            baderaseblock = 0;
+
+            /* check all the blocks in an erase block for
+             * bad blocks */
+            if (!opts->nocheckbadblk) {
+                do {
+                    int ret = meminfo->block_isbad(meminfo, offs);
+
+                    if (ret < 0) {
+                        printf("Bad block check failed\n");
+                        goto restoreoob;
+                    }
+                    if (ret == 1) {
+                        baderaseblock = 1;
+                        if (!opts->quiet)
+                            printf("\rBad block at 0x%lx "
+                                   "in erase block from "
+                                   "0x%x will be skipped\n",
+                                   (long) offs,
+                                   blockstart);
+                    }
+
+                    if (baderaseblock) {
+                        mtdoffset = blockstart
+                            + erasesize_blockalign;
+                    }
+                    offs +=  erasesize_blockalign
+                        / opts->blockalign;
+                } while (offs < blockstart + erasesize_blockalign);
+            }
+        }
+
+        /* skip the first good block when wirte yaffs image, by www.100ask.net */
+        if (skipfirstblk) {
+            mtdoffset += erasesize_blockalign;
+            skipfirstblk = 0;
+            continue;
+        }
+
+        readlen = meminfo->oobblock;
+        if (opts->pad && (imglen < readlen)) {
+            readlen = imglen;
+            memset(data_buf + readlen, 0xff,
+                   meminfo->oobblock - readlen);
+        }
+
+        /* read page data from input memory buffer */
+        memcpy(data_buf, buffer, readlen);
+        buffer += readlen;
+
+        if (opts->writeoob) {
+            /* read OOB data from input memory block, exit
+             * on failure */
+            memcpy(oob_buf, buffer, meminfo->oobsize);
+            buffer += meminfo->oobsize;
+
+            /* write OOB data first, as ecc will be placed
+             * in there*/
+            result = meminfo->write_oob(meminfo,
+                            mtdoffset,
+                            meminfo->oobsize,
+                            &written,
+                            (unsigned char *)
+                            &oob_buf);
+
+            if (result != 0) {
+                printf("\nMTD writeoob failure: %d\n",
+                       result);
+                goto restoreoob;
+            }
+            imglen -= meminfo->oobsize;
+        }
+
+        /* write out the page data */
+        result = meminfo->write(meminfo,
+                    mtdoffset,
+                    meminfo->oobblock,
+                    &written,
+                    (unsigned char *) &data_buf);
+
+        if (result != 0) {
+            printf("writing NAND page at offset 0x%lx failed\n",
+                   mtdoffset);
+            goto restoreoob;
+        }
+        imglen -= readlen;
+
+        if (!opts->quiet) {
+            int percent = (int)
+                ((unsigned long long)
+                 (opts->length-imglen) * 100
+                 / opts->length);
+            /* output progress message only at whole percent
+             * steps to reduce the number of messages printed
+             * on (slow) serial consoles
+             */
+            if (percent != percent_complete) {
+                printf("\rWriting data at 0x%x "
+                       "-- %3d%% complete.",
+                       mtdoffset, percent);
+                percent_complete = percent;
+            }
+        }
 
-		mtdoffset += meminfo->oobblock;
-	}
+        mtdoffset += meminfo->oobblock;
+    }
 
-	if (!opts->quiet)
-		printf("\n");
+    if (!opts->quiet)
+        printf("\n");
 
 restoreoob:
-	if (oobinfochanged) {
-		memcpy(&meminfo->oobinfo, &old_oobinfo,
-		       sizeof(meminfo->oobinfo));
-	}
-
-	if (imglen > 0) {
-		printf("Data did not fit into device, due to bad blocks\n");
-		return -1;
-	}
+    if (oobinfochanged) {
+        memcpy(&meminfo->oobinfo, &old_oobinfo,
+               sizeof(meminfo->oobinfo));
+    }
+
+    if (imglen > 0) {
+        printf("Data did not fit into device, due to bad blocks\n");
+        return -1;
+    }
 
-	/* return happy */
-	return 0;
+    /* return happy */
+    return 0;
 }
 
 /**
  * nand_read_opts: - read image from NAND flash with support for various options
  *
- * @param meminfo	NAND device to erase
- * @param opts		read options (@see struct nand_read_options)
- * @return		0 in case of success
+ * @param meminfo   NAND device to erase
+ * @param opts      read options (@see struct nand_read_options)
+ * @return      0 in case of success
  *
  */
 int nand_read_opts(nand_info_t *meminfo, const nand_read_options_t *opts)
 {
-	int imglen = opts->length;
-	int pagelen;
-	int baderaseblock;
-	int blockstart = -1;
-	int percent_complete = -1;
-	loff_t offs;
-	size_t readlen;
-	ulong mtdoffset = opts->offset;
-	u_char *buffer = opts->buffer;
-	int result;
-
-	/* make sure device page sizes are valid */
-	if (!(meminfo->oobsize == 16 && meminfo->oobblock == 512)
-	    && !(meminfo->oobsize == 8 && meminfo->oobblock == 256)
-	    && !(meminfo->oobsize == 64 && meminfo->oobblock == 2048)) {
-		printf("Unknown flash (not normal NAND)\n");
-		return -1;
-	}
-
-	pagelen = meminfo->oobblock
-		+ ((opts->readoob != 0) ? meminfo->oobsize : 0);
-
-	/* check, if length is not larger than device */
-	if (((imglen / pagelen) * meminfo->oobblock)
-	     > (meminfo->size - opts->offset)) {
-		printf("Image %d bytes, NAND page %d bytes, "
-		       "OOB area %u bytes, device size %u bytes\n",
-		       imglen, pagelen, meminfo->oobblock, meminfo->size);
-		printf("Input block is larger than device\n");
-		return -1;
-	}
-
-	if (!opts->quiet)
-		printf("\n");
-
-	/* get data from input and write to the device */
-	while (imglen && (mtdoffset < meminfo->size)) {
-
-		WATCHDOG_RESET ();
-
-		/*
-		 * new eraseblock, check for bad block(s). Stay in the
-		 * loop to be sure if the offset changes because of
-		 * a bad block, that the next block that will be
-		 * written to is also checked. Thus avoiding errors if
-		 * the block(s) after the skipped block(s) is also bad
-		 * (number of blocks depending on the blockalign
-		 */
-		while (blockstart != (mtdoffset & (~meminfo->erasesize+1))) {
-			blockstart = mtdoffset & (~meminfo->erasesize+1);
-			offs = blockstart;
-			baderaseblock = 0;
-
-			/* check all the blocks in an erase block for
-			 * bad blocks */
-			do {
-				int ret = meminfo->block_isbad(meminfo, offs);
-
-				if (ret < 0) {
-					printf("Bad block check failed\n");
-					return -1;
-				}
-				if (ret == 1) {
-					baderaseblock = 1;
-					if (!opts->quiet)
-						printf("\rBad block at 0x%lx "
-						       "in erase block from "
-						       "0x%x will be skipped\n",
-						       (long) offs,
-						       blockstart);
-				}
-
-				if (baderaseblock) {
-					mtdoffset = blockstart
-						+ meminfo->erasesize;
-				}
-				offs +=	 meminfo->erasesize;
-
-			} while (offs < blockstart + meminfo->erasesize);
-		}
-
-
-		/* read page data to memory buffer */
-		result = meminfo->read(meminfo,
-				       mtdoffset,
-				       meminfo->oobblock,
-				       &readlen,
-				       (unsigned char *) &data_buf);
-
-		if (result != 0) {
-			printf("reading NAND page at offset 0x%lx failed\n",
-			       mtdoffset);
-			return -1;
-		}
-
-		if (imglen < readlen) {
-			readlen = imglen;
-		}
-
-		memcpy(buffer, data_buf, readlen);
-		buffer += readlen;
-		imglen -= readlen;
-
-		if (opts->readoob) {
-			result = meminfo->read_oob(meminfo,
-						   mtdoffset,
-						   meminfo->oobsize,
-						   &readlen,
-						   (unsigned char *)
-						   &oob_buf);
-
-			if (result != 0) {
-				printf("\nMTD readoob failure: %d\n",
-				       result);
-				return -1;
-			}
-
-
-			if (imglen < readlen) {
-				readlen = imglen;
-			}
-
-			memcpy(buffer, oob_buf, readlen);
-
-			buffer += readlen;
-			imglen -= readlen;
-		}
-
-		if (!opts->quiet) {
-			int percent = (int)
-				((unsigned long long)
-				 (opts->length-imglen) * 100
-				 / opts->length);
-			/* output progress message only at whole percent
-			 * steps to reduce the number of messages printed
-			 * on (slow) serial consoles
-			 */
-			if (percent != percent_complete) {
-			if (!opts->quiet)
-				printf("\rReading data from 0x%x "
-				       "-- %3d%% complete.",
-				       mtdoffset, percent);
-				percent_complete = percent;
-			}
-		}
-
-		mtdoffset += meminfo->oobblock;
-	}
-
-	if (!opts->quiet)
-		printf("\n");
-
-	if (imglen > 0) {
-		printf("Could not read entire image due to bad blocks\n");
-		return -1;
-	}
+    int imglen = opts->length;
+    int pagelen;
+    int baderaseblock;
+    int blockstart = -1;
+    int percent_complete = -1;
+    loff_t offs;
+    size_t readlen;
+    ulong mtdoffset = opts->offset;
+    u_char *buffer = opts->buffer;
+    int result;
+    struct nand_oobinfo old_oobinfo;
+    int oobinfochanged = 0;
+
+    /* make sure device page sizes are valid */
+    if (!(meminfo->oobsize == 16 && meminfo->oobblock == 512)
+        && !(meminfo->oobsize == 8 && meminfo->oobblock == 256)
+        && !(meminfo->oobsize == 64 && meminfo->oobblock == 2048)) {
+        printf("Unknown flash (not normal NAND)\n");
+        return -1;
+    }
+
+    pagelen = meminfo->oobblock
+        + ((opts->readoob != 0) ? meminfo->oobsize : 0);
+
+    /* check, if length is not larger than device */
+    if (((imglen / pagelen) * meminfo->oobblock)
+         > (meminfo->size - opts->offset)) {
+        printf("Image %d bytes, NAND page %d bytes, "
+               "OOB area %u bytes, device size %u bytes\n",
+               imglen, pagelen, meminfo->oobblock, meminfo->size);
+        printf("Input block is larger than device\n");
+        return -1;
+    }
+
+    if (!opts->quiet)
+        printf("\n");
+
+    /* read the current oob info */
+    memcpy(&old_oobinfo, &meminfo->oobinfo, sizeof(old_oobinfo));
+
+    /* write without ecc? */
+    if (opts->noecc) {
+        memcpy(&meminfo->oobinfo, &none_oobinfo,
+               sizeof(meminfo->oobinfo));
+        oobinfochanged = 1;
+    }
+
+    /* get data from input and write to the device */
+    while (imglen && (mtdoffset < meminfo->size)) {
+
+        WATCHDOG_RESET ();
+
+        /*
+         * new eraseblock, check for bad block(s). Stay in the
+         * loop to be sure if the offset changes because of
+         * a bad block, that the next block that will be
+         * written to is also checked. Thus avoiding errors if
+         * the block(s) after the skipped block(s) is also bad
+         * (number of blocks depending on the blockalign
+         */
+        while (blockstart != (mtdoffset & (~meminfo->erasesize+1))) {
+            blockstart = mtdoffset & (~meminfo->erasesize+1);
+            offs = blockstart;
+            baderaseblock = 0;
+
+            /* check all the blocks in an erase block for
+             * bad blocks */
+            if (!opts->nocheckbadblk) {
+                do {
+                    int ret = meminfo->block_isbad(meminfo, offs);
+
+                    if (ret < 0) {
+                        printf("Bad block check failed\n");
+                        goto restoreoob;
+                    }
+                    if (ret == 1) {
+                        baderaseblock = 1;
+                        if (!opts->quiet)
+                            printf("\rBad block at 0x%lx "
+                                   "in erase block from "
+                                   "0x%x will be skipped\n",
+                                   (long) offs,
+                                   blockstart);
+                    }
+
+                    if (baderaseblock) {
+                        mtdoffset = blockstart
+                            + meminfo->erasesize;
+                    }
+                    offs +=  meminfo->erasesize;
+
+                } while (offs < blockstart + meminfo->erasesize);
+            }
+        }
+
+
+        /* read page data to memory buffer */
+        result = meminfo->read(meminfo,
+                       mtdoffset,
+                       meminfo->oobblock,
+                       &readlen,
+                       (unsigned char *) &data_buf);
+
+        if (result != 0) {
+            printf("reading NAND page at offset 0x%lx failed\n",
+                   mtdoffset);
+            goto restoreoob;
+        }
+
+        if (imglen < readlen) {
+            readlen = imglen;
+        }
+
+        memcpy(buffer, data_buf, readlen);
+        buffer += readlen;
+        imglen -= readlen;
+
+        if (opts->readoob) {
+            result = meminfo->read_oob(meminfo,
+                           mtdoffset,
+                           meminfo->oobsize,
+                           &readlen,
+                           (unsigned char *)
+                           &oob_buf);
+
+            if (result != 0) {
+                printf("\nMTD readoob failure: %d\n",
+                       result);
+                goto restoreoob;
+            }
+
+
+            if (imglen < readlen) {
+                readlen = imglen;
+            }
+
+            memcpy(buffer, oob_buf, readlen);
+
+            buffer += readlen;
+            imglen -= readlen;
+        }
+
+        if (!opts->quiet) {
+            int percent = (int)
+                ((unsigned long long)
+                 (opts->length-imglen) * 100
+                 / opts->length);
+            /* output progress message only at whole percent
+             * steps to reduce the number of messages printed
+             * on (slow) serial consoles
+             */
+            if (percent != percent_complete) {
+            if (!opts->quiet)
+                printf("\rReading data from 0x%x "
+                       "-- %3d%% complete.",
+                       mtdoffset, percent);
+                percent_complete = percent;
+            }
+        }
 
-	/* return happy */
-	return 0;
+        mtdoffset += meminfo->oobblock;
+    }
+
+    if (!opts->quiet)
+        printf("\n");
+
+restoreoob:
+    if (oobinfochanged) {
+        memcpy(&meminfo->oobinfo, &old_oobinfo,
+               sizeof(meminfo->oobinfo));
+    }
+
+    if (imglen > 0) {
+        printf("Could not read entire image due to bad blocks\n");
+        return -1;
+    }
+
+    /* return happy */
+    return 0;
 }
 
 /******************************************************************************
  * Support for locking / unlocking operations of some NAND devices
  *****************************************************************************/
 
-#define NAND_CMD_LOCK		0x2a
-#define NAND_CMD_LOCK_TIGHT	0x2c
-#define NAND_CMD_UNLOCK1	0x23
-#define NAND_CMD_UNLOCK2	0x24
-#define NAND_CMD_LOCK_STATUS	0x7a
+#define NAND_CMD_LOCK       0x2a
+#define NAND_CMD_LOCK_TIGHT 0x2c
+#define NAND_CMD_UNLOCK1    0x23
+#define NAND_CMD_UNLOCK2    0x24
+#define NAND_CMD_LOCK_STATUS    0x7a
 
 /**
  * nand_lock: Set all pages of NAND flash chip to the LOCK or LOCK-TIGHT
- *	      state
+ *        state
  *
- * @param meminfo	nand mtd instance
- * @param tight		bring device in lock tight mode
+ * @param meminfo   nand mtd instance
+ * @param tight     bring device in lock tight mode
  *
- * @return		0 on success, -1 in case of error
+ * @return      0 on success, -1 in case of error
  *
  * The lock / lock-tight command only applies to the whole chip. To get some
  * parts of the chip lock and others unlocked use the following sequence:
@@ -716,147 +747,147 @@
  */
 int nand_lock(nand_info_t *meminfo, int tight)
 {
-	int ret = 0;
-	int status;
-	struct nand_chip *this = meminfo->priv;
-
-	/* select the NAND device */
-	this->select_chip(meminfo, 0);
-
-	this->cmdfunc(meminfo,
-		      (tight ? NAND_CMD_LOCK_TIGHT : NAND_CMD_LOCK),
-		      -1, -1);
-
-	/* call wait ready function */
-	status = this->waitfunc(meminfo, this, FL_WRITING);
-
-	/* see if device thinks it succeeded */
-	if (status & 0x01) {
-		ret = -1;
-	}
-
-	/* de-select the NAND device */
-	this->select_chip(meminfo, -1);
-	return ret;
+    int ret = 0;
+    int status;
+    struct nand_chip *this = meminfo->priv;
+
+    /* select the NAND device */
+    this->select_chip(meminfo, 0);
+
+    this->cmdfunc(meminfo,
+              (tight ? NAND_CMD_LOCK_TIGHT : NAND_CMD_LOCK),
+              -1, -1);
+
+    /* call wait ready function */
+    status = this->waitfunc(meminfo, this, FL_WRITING);
+
+    /* see if device thinks it succeeded */
+    if (status & 0x01) {
+        ret = -1;
+    }
+
+    /* de-select the NAND device */
+    this->select_chip(meminfo, -1);
+    return ret;
 }
 
 /**
  * nand_get_lock_status: - query current lock state from one page of NAND
- *			   flash
+ *             flash
  *
- * @param meminfo	nand mtd instance
- * @param offset	page address to query (muss be page aligned!)
+ * @param meminfo   nand mtd instance
+ * @param offset    page address to query (muss be page aligned!)
  *
- * @return		-1 in case of error
- *			>0 lock status:
- *			  bitfield with the following combinations:
- *			  NAND_LOCK_STATUS_TIGHT: page in tight state
- *			  NAND_LOCK_STATUS_LOCK:  page locked
- *			  NAND_LOCK_STATUS_UNLOCK: page unlocked
+ * @return      -1 in case of error
+ *          >0 lock status:
+ *            bitfield with the following combinations:
+ *            NAND_LOCK_STATUS_TIGHT: page in tight state
+ *            NAND_LOCK_STATUS_LOCK:  page locked
+ *            NAND_LOCK_STATUS_UNLOCK: page unlocked
  *
  */
 int nand_get_lock_status(nand_info_t *meminfo, ulong offset)
 {
-	int ret = 0;
-	int chipnr;
-	int page;
-	struct nand_chip *this = meminfo->priv;
-
-	/* select the NAND device */
-	chipnr = (int)(offset >> this->chip_shift);
-	this->select_chip(meminfo, chipnr);
-
-
-	if ((offset & (meminfo->oobblock - 1)) != 0) {
-		printf ("nand_get_lock_status: "
-			"Start address must be beginning of "
-			"nand page!\n");
-		ret = -1;
-		goto out;
-	}
-
-	/* check the Lock Status */
-	page = (int)(offset >> this->page_shift);
-	this->cmdfunc(meminfo, NAND_CMD_LOCK_STATUS, -1, page & this->pagemask);
-
-	ret = this->read_byte(meminfo) & (NAND_LOCK_STATUS_TIGHT
-					  | NAND_LOCK_STATUS_LOCK
-					  | NAND_LOCK_STATUS_UNLOCK);
+    int ret = 0;
+    int chipnr;
+    int page;
+    struct nand_chip *this = meminfo->priv;
+
+    /* select the NAND device */
+    chipnr = (int)(offset >> this->chip_shift);
+    this->select_chip(meminfo, chipnr);
+
+
+    if ((offset & (meminfo->oobblock - 1)) != 0) {
+        printf ("nand_get_lock_status: "
+            "Start address must be beginning of "
+            "nand page!\n");
+        ret = -1;
+        goto out;
+    }
+
+    /* check the Lock Status */
+    page = (int)(offset >> this->page_shift);
+    this->cmdfunc(meminfo, NAND_CMD_LOCK_STATUS, -1, page & this->pagemask);
+
+    ret = this->read_byte(meminfo) & (NAND_LOCK_STATUS_TIGHT
+                      | NAND_LOCK_STATUS_LOCK
+                      | NAND_LOCK_STATUS_UNLOCK);
 
  out:
-	/* de-select the NAND device */
-	this->select_chip(meminfo, -1);
-	return ret;
+    /* de-select the NAND device */
+    this->select_chip(meminfo, -1);
+    return ret;
 }
 
 /**
  * nand_unlock: - Unlock area of NAND pages
- *		  only one consecutive area can be unlocked at one time!
+ *        only one consecutive area can be unlocked at one time!
  *
- * @param meminfo	nand mtd instance
- * @param start		start byte address
- * @param length	number of bytes to unlock (must be a multiple of
- *			page size nand->oobblock)
+ * @param meminfo   nand mtd instance
+ * @param start     start byte address
+ * @param length    number of bytes to unlock (must be a multiple of
+ *          page size nand->oobblock)
  *
- * @return		0 on success, -1 in case of error
+ * @return      0 on success, -1 in case of error
  */
 int nand_unlock(nand_info_t *meminfo, ulong start, ulong length)
 {
-	int ret = 0;
-	int chipnr;
-	int status;
-	int page;
-	struct nand_chip *this = meminfo->priv;
-	printf ("nand_unlock: start: %08x, length: %d!\n",
-		(int)start, (int)length);
-
-	/* select the NAND device */
-	chipnr = (int)(start >> this->chip_shift);
-	this->select_chip(meminfo, chipnr);
-
-	/* check the WP bit */
-	this->cmdfunc(meminfo, NAND_CMD_STATUS, -1, -1);
-	if ((this->read_byte(meminfo) & 0x80) == 0) {
-		printf ("nand_unlock: Device is write protected!\n");
-		ret = -1;
-		goto out;
-	}
-
-	if ((start & (meminfo->oobblock - 1)) != 0) {
-		printf ("nand_unlock: Start address must be beginning of "
-			"nand page!\n");
-		ret = -1;
-		goto out;
-	}
-
-	if (length == 0 || (length & (meminfo->oobblock - 1)) != 0) {
-		printf ("nand_unlock: Length must be a multiple of nand page "
-			"size!\n");
-		ret = -1;
-		goto out;
-	}
-
-	/* submit address of first page to unlock */
-	page = (int)(start >> this->page_shift);
-	this->cmdfunc(meminfo, NAND_CMD_UNLOCK1, -1, page & this->pagemask);
-
-	/* submit ADDRESS of LAST page to unlock */
-	page += (int)(length >> this->page_shift) - 1;
-	this->cmdfunc(meminfo, NAND_CMD_UNLOCK2, -1, page & this->pagemask);
-
-	/* call wait ready function */
-	status = this->waitfunc(meminfo, this, FL_WRITING);
-	/* see if device thinks it succeeded */
-	if (status & 0x01) {
-		/* there was an error */
-		ret = -1;
-		goto out;
-	}
+    int ret = 0;
+    int chipnr;
+    int status;
+    int page;
+    struct nand_chip *this = meminfo->priv;
+    printf ("nand_unlock: start: %08x, length: %d!\n",
+        (int)start, (int)length);
+
+    /* select the NAND device */
+    chipnr = (int)(start >> this->chip_shift);
+    this->select_chip(meminfo, chipnr);
+
+    /* check the WP bit */
+    this->cmdfunc(meminfo, NAND_CMD_STATUS, -1, -1);
+    if ((this->read_byte(meminfo) & 0x80) == 0) {
+        printf ("nand_unlock: Device is write protected!\n");
+        ret = -1;
+        goto out;
+    }
+
+    if ((start & (meminfo->oobblock - 1)) != 0) {
+        printf ("nand_unlock: Start address must be beginning of "
+            "nand page!\n");
+        ret = -1;
+        goto out;
+    }
+
+    if (length == 0 || (length & (meminfo->oobblock - 1)) != 0) {
+        printf ("nand_unlock: Length must be a multiple of nand page "
+            "size!\n");
+        ret = -1;
+        goto out;
+    }
+
+    /* submit address of first page to unlock */
+    page = (int)(start >> this->page_shift);
+    this->cmdfunc(meminfo, NAND_CMD_UNLOCK1, -1, page & this->pagemask);
+
+    /* submit ADDRESS of LAST page to unlock */
+    page += (int)(length >> this->page_shift) - 1;
+    this->cmdfunc(meminfo, NAND_CMD_UNLOCK2, -1, page & this->pagemask);
+
+    /* call wait ready function */
+    status = this->waitfunc(meminfo, this, FL_WRITING);
+    /* see if device thinks it succeeded */
+    if (status & 0x01) {
+        /* there was an error */
+        ret = -1;
+        goto out;
+    }
 
  out:
-	/* de-select the NAND device */
-	this->select_chip(meminfo, -1);
-	return ret;
+    /* de-select the NAND device */
+    this->select_chip(meminfo, -1);
+    return ret;
 }
 
 #endif /* (CONFIG_COMMANDS & CFG_CMD_NAND) && !defined(CFG_NAND_LEGACY) */

diff -urN u-boot-1.1.6/include/nand.h u-boot-1.1.6_jz2440/include/nand.h
--- u-boot-1.1.6/include/nand.h	2006-11-02 22:15:01.000000000 +0800
+++ u-boot-1.1.6_jz2440/include/nand.h	2010-11-26 12:54:38.062126185 +0800
@@ -78,6 +78,14 @@
 	int pad;		/* pad to page size */
 	int blockalign;		/* 1|2|4 set multiple of eraseblocks
 				 * to align to */
+    int skipfirstblk;   /* if true, skip the first good block,  
+                         * set true when write the yaffs image, 
+                         * add by www.100ask.net
+                         */                    
+    int nocheckbadblk;  /* if true, don't check bad blockes,
+                         * use them as good blockes
+                         * add by www.100ask.net
+                         */                    
 };
 
 typedef struct nand_write_options nand_write_options_t;
@@ -88,6 +96,11 @@
 	ulong offset;		/* start address in NAND */
 	int quiet;		/* don't display progress messages */
 	int readoob;		/* put oob data in image */
+	int noecc;		/* read without ecc */
+    int nocheckbadblk;  /* if true, don't check bad blockes,
+                         * use them as good blockes
+                         * add by www.100ask.net
+                         */                    
 };
 
 typedef struct nand_read_options nand_read_options_t;


diff -urN u-boot-1.1.6_jz2440/common/cmd_nand.c u-boot-1.1.6_nand_ok/common/cmd_nand.c
--- u-boot-1.1.6_jz2440/common/cmd_nand.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-1.1.6_nand_ok/common/cmd_nand.c	2010-11-26 12:54:38.130318758 +0800
@@ -28,7 +28,7 @@
 
 #ifdef CONFIG_SHOW_BOOT_PROGRESS
 # include <status_led.h>
-# define SHOW_BOOT_PROGRESS(arg)	show_boot_progress(arg)
+# define SHOW_BOOT_PROGRESS(arg)    show_boot_progress(arg)
 #else
 # define SHOW_BOOT_PROGRESS(arg)
 #endif
@@ -42,572 +42,635 @@
 int mtdparts_init(void);
 int id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num);
 int find_dev_and_part(const char *id, struct mtd_device **dev,
-		u8 *part_num, struct part_info **part);
+        u8 *part_num, struct part_info **part);
 #endif
 
 extern nand_info_t nand_info[];       /* info for NAND chips */
 
 static int nand_dump_oob(nand_info_t *nand, ulong off)
 {
-	return 0;
+    return 0;
 }
 
 static int nand_dump(nand_info_t *nand, ulong off)
 {
-	int i;
-	u_char *buf, *p;
+    int i;
+    u_char *buf, *p;
 
-	buf = malloc(nand->oobblock + nand->oobsize);
-	if (!buf) {
-		puts("No memory for page buffer\n");
-		return 1;
-	}
-	off &= ~(nand->oobblock - 1);
-	i = nand_read_raw(nand, buf, off, nand->oobblock, nand->oobsize);
-	if (i < 0) {
-		printf("Error (%d) reading page %08x\n", i, off);
-		free(buf);
-		return 1;
-	}
-	printf("Page %08x dump:\n", off);
-	i = nand->oobblock >> 4; p = buf;
-	while (i--) {
-		printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x"
-			"  %02x %02x %02x %02x %02x %02x %02x %02x\n",
-			p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
-			p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
-		p += 16;
-	}
-	puts("OOB:\n");
-	i = nand->oobsize >> 3;
-	while (i--) {
-		printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
-			p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
-		p += 8;
-	}
-	free(buf);
+    buf = malloc(nand->oobblock + nand->oobsize);
+    if (!buf) {
+        puts("No memory for page buffer\n");
+        return 1;
+    }
+    off &= ~(nand->oobblock - 1);
+    i = nand_read_raw(nand, buf, off, nand->oobblock, nand->oobsize);
+    if (i < 0) {
+        printf("Error (%d) reading page %08x\n", i, off);
+        free(buf);
+        return 1;
+    }
+    printf("Page %08x dump:\n", off);
+    i = nand->oobblock >> 4; p = buf;
+    while (i--) {
+        printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x"
+            "  %02x %02x %02x %02x %02x %02x %02x %02x\n",
+            p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
+            p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+        p += 16;
+    }
+    puts("OOB:\n");
+    i = nand->oobsize >> 3;
+    while (i--) {
+        printf( "\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
+            p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
+        p += 8;
+    }
+    free(buf);
 
-	return 0;
+    return 0;
 }
 
 /* ------------------------------------------------------------------------- */
 
 static inline int str2long(char *p, ulong *num)
 {
-	char *endptr;
+    char *endptr;
 
-	*num = simple_strtoul(p, &endptr, 16);
-	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
+    *num = simple_strtoul(p, &endptr, 16);
+    return (*p != '\0' && *endptr == '\0') ? 1 : 0;
 }
 
 static int
 arg_off_size(int argc, char *argv[], nand_info_t *nand, ulong *off, ulong *size)
 {
-	int idx = nand_curr_device;
+    int idx = nand_curr_device;
 #if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
-	struct mtd_device *dev;
-	struct part_info *part;
-	u8 pnum;
-
-	if (argc >= 1 && !(str2long(argv[0], off))) {
-		if ((mtdparts_init() == 0) &&
-		    (find_dev_and_part(argv[0], &dev, &pnum, &part) == 0)) {
-			if (dev->id->type != MTD_DEV_TYPE_NAND) {
-				puts("not a NAND device\n");
-				return -1;
-			}
-			*off = part->offset;
-			if (argc >= 2) {
-				if (!(str2long(argv[1], size))) {
-					printf("'%s' is not a number\n", argv[1]);
-					return -1;
-				}
-				if (*size > part->size)
-					*size = part->size;
-			} else {
-				*size = part->size;
-			}
-			idx = dev->id->num;
-			*nand = nand_info[idx];
-			goto out;
-		}
-	}
-#endif
-
-	if (argc >= 1) {
-		if (!(str2long(argv[0], off))) {
-			printf("'%s' is not a number\n", argv[0]);
-			return -1;
-		}
-	} else {
-		*off = 0;
-	}
-
-	if (argc >= 2) {
-		if (!(str2long(argv[1], size))) {
-			printf("'%s' is not a number\n", argv[1]);
-			return -1;
-		}
-	} else {
-		*size = nand->size - *off;
-	}
+    struct mtd_device *dev;
+    struct part_info *part;
+    u8 pnum;
+
+    if (argc >= 1 && !(str2long(argv[0], off))) {
+        if ((mtdparts_init() == 0) &&
+            (find_dev_and_part(argv[0], &dev, &pnum, &part) == 0)) {
+            if (dev->id->type != MTD_DEV_TYPE_NAND) {
+                puts("not a NAND device\n");
+                return -1;
+            }
+            *off = part->offset;
+            if (argc >= 2) {
+                if (!(str2long(argv[1], size))) {
+                    printf("'%s' is not a number\n", argv[1]);
+                    return -1;
+                }
+                if (*size > part->size)
+                    *size = part->size;
+            } else {
+                *size = part->size;
+            }
+            idx = dev->id->num;
+            *nand = nand_info[idx];
+            goto out;
+        }
+    }
+#endif
+
+    if (argc >= 1) {
+        if (!(str2long(argv[0], off))) {
+            printf("'%s' is not a number\n", argv[0]);
+            return -1;
+        }
+    } else {
+        *off = 0;
+    }
+
+    if (argc >= 2) {
+        if (!(str2long(argv[1], size))) {
+            printf("'%s' is not a number\n", argv[1]);
+            return -1;
+        }
+    } else {
+        *size = nand->size - *off;
+    }
 
 #if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
 out:
 #endif
-	printf("device %d ", idx);
-	if (*size == nand->size)
-		puts("whole chip\n");
-	else
-		printf("offset 0x%x, size 0x%x\n", *off, *size);
-	return 0;
+    printf("device %d ", idx);
+    if (*size == nand->size)
+        puts("whole chip\n");
+    else
+        printf("offset 0x%x, size 0x%x\n", *off, *size);
+    return 0;
 }
 
 int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 {
-	int i, dev, ret;
-	ulong addr, off, size;
-	char *cmd, *s;
-	nand_info_t *nand;
-	int quiet = 0;
-	const char *quiet_str = getenv("quiet");
-
-	/* at least two arguments please */
-	if (argc < 2)
-		goto usage;
-
-	if (quiet_str)
-		quiet = simple_strtoul(quiet_str, NULL, 0) != 0;
-
-	cmd = argv[1];
-
-	if (strcmp(cmd, "info") == 0) {
-
-		putc('\n');
-		for (i = 0; i < CFG_MAX_NAND_DEVICE; i++) {
-			if (nand_info[i].name)
-				printf("Device %d: %s, sector size %lu KiB\n",
-					i, nand_info[i].name,
-					nand_info[i].erasesize >> 10);
-		}
-		return 0;
-	}
-
-	if (strcmp(cmd, "device") == 0) {
-
-		if (argc < 3) {
-			if ((nand_curr_device < 0) ||
-			    (nand_curr_device >= CFG_MAX_NAND_DEVICE))
-				puts("\nno devices available\n");
-			else
-				printf("\nDevice %d: %s\n", nand_curr_device,
-					nand_info[nand_curr_device].name);
-			return 0;
-		}
-		dev = (int)simple_strtoul(argv[2], NULL, 10);
-		if (dev < 0 || dev >= CFG_MAX_NAND_DEVICE || !nand_info[dev].name) {
-			puts("No such device\n");
-			return 1;
-		}
-		printf("Device %d: %s", dev, nand_info[dev].name);
-		puts("... is now current device\n");
-		nand_curr_device = dev;
+    int i, dev, ret;
+    ulong addr, off, size;
+    char *cmd, *s;
+    nand_info_t *nand;
+    int quiet = 0;
+    const char *quiet_str = getenv("quiet");
+
+    /* at least two arguments please */
+    if (argc < 2)
+        goto usage;
+
+    if (quiet_str)
+        quiet = simple_strtoul(quiet_str, NULL, 0) != 0;
+
+    cmd = argv[1];
+
+    if (strcmp(cmd, "info") == 0) {
+
+        putc('\n');
+        for (i = 0; i < CFG_MAX_NAND_DEVICE; i++) {
+            if (nand_info[i].name)
+                printf("Device %d: %s, sector size %lu KiB\n",
+                    i, nand_info[i].name,
+                    nand_info[i].erasesize >> 10);
+        }
+        return 0;
+    }
+
+    if (strcmp(cmd, "device") == 0) {
+
+        if (argc < 3) {
+            if ((nand_curr_device < 0) ||
+                (nand_curr_device >= CFG_MAX_NAND_DEVICE))
+                puts("\nno devices available\n");
+            else
+                printf("\nDevice %d: %s\n", nand_curr_device,
+                    nand_info[nand_curr_device].name);
+            return 0;
+        }
+        dev = (int)simple_strtoul(argv[2], NULL, 10);
+        if (dev < 0 || dev >= CFG_MAX_NAND_DEVICE || !nand_info[dev].name) {
+            puts("No such device\n");
+            return 1;
+        }
+        printf("Device %d: %s", dev, nand_info[dev].name);
+        puts("... is now current device\n");
+        nand_curr_device = dev;
 
 #ifdef CFG_NAND_SELECT_DEVICE
-		/*
-		 * Select the chip in the board/cpu specific driver
-		 */
-		board_nand_select_device(nand_info[dev].priv, dev);
-#endif
-
-		return 0;
-	}
-
-	if (strcmp(cmd, "bad") != 0 && strcmp(cmd, "erase") != 0 &&
-	    strncmp(cmd, "dump", 4) != 0 &&
-	    strncmp(cmd, "read", 4) != 0 && strncmp(cmd, "write", 5) != 0 &&
-	    strcmp(cmd, "scrub") != 0 && strcmp(cmd, "markbad") != 0 &&
-	    strcmp(cmd, "biterr") != 0 &&
-	    strcmp(cmd, "lock") != 0 && strcmp(cmd, "unlock") != 0 )
-		goto usage;
-
-	/* the following commands operate on the current device */
-	if (nand_curr_device < 0 || nand_curr_device >= CFG_MAX_NAND_DEVICE ||
-	    !nand_info[nand_curr_device].name) {
-		puts("\nno devices available\n");
-		return 1;
-	}
-	nand = &nand_info[nand_curr_device];
-
-	if (strcmp(cmd, "bad") == 0) {
-		printf("\nDevice %d bad blocks:\n", nand_curr_device);
-		for (off = 0; off < nand->size; off += nand->erasesize)
-			if (nand_block_isbad(nand, off))
-				printf("  %08x\n", off);
-		return 0;
-	}
-
-	/*
-	 * Syntax is:
-	 *   0    1     2       3    4
-	 *   nand erase [clean] [off size]
-	 */
-	if (strcmp(cmd, "erase") == 0 || strcmp(cmd, "scrub") == 0) {
-		nand_erase_options_t opts;
-		/* "clean" at index 2 means request to write cleanmarker */
-		int clean = argc > 2 && !strcmp("clean", argv[2]);
-		int o = clean ? 3 : 2;
-		int scrub = !strcmp(cmd, "scrub");
-
-		printf("\nNAND %s: ", scrub ? "scrub" : "erase");
-		/* skip first two or three arguments, look for offset and size */
-		if (arg_off_size(argc - o, argv + o, nand, &off, &size) != 0)
-			return 1;
-
-		memset(&opts, 0, sizeof(opts));
-		opts.offset = off;
-		opts.length = size;
-		opts.jffs2  = clean;
-		opts.quiet  = quiet;
-
-		if (scrub) {
-			puts("Warning: "
-			     "scrub option will erase all factory set "
-			     "bad blocks!\n"
-			     "         "
-			     "There is no reliable way to recover them.\n"
-			     "         "
-			     "Use this command only for testing purposes "
-			     "if you\n"
-			     "         "
-			     "are sure of what you are doing!\n"
-			     "\nReally scrub this NAND flash? <y/N>\n");
-
-			if (getc() == 'y' && getc() == '\r') {
-				opts.scrub = 1;
-			} else {
-				puts("scrub aborted\n");
-				return -1;
-			}
-		}
-		ret = nand_erase_opts(nand, &opts);
-		printf("%s\n", ret ? "ERROR" : "OK");
-
-		return ret == 0 ? 0 : 1;
-	}
-
-	if (strncmp(cmd, "dump", 4) == 0) {
-		if (argc < 3)
-			goto usage;
-
-		s = strchr(cmd, '.');
-		off = (int)simple_strtoul(argv[2], NULL, 16);
-
-		if (s != NULL && strcmp(s, ".oob") == 0)
-			ret = nand_dump_oob(nand, off);
-		else
-			ret = nand_dump(nand, off);
-
-		return ret == 0 ? 1 : 0;
-
-	}
-
-	/* read write */
-	if (strncmp(cmd, "read", 4) == 0 || strncmp(cmd, "write", 5) == 0) {
-		int read;
-
-		if (argc < 4)
-			goto usage;
-
-		addr = (ulong)simple_strtoul(argv[2], NULL, 16);
-
-		read = strncmp(cmd, "read", 4) == 0; /* 1 = read, 0 = write */
-		printf("\nNAND %s: ", read ? "read" : "write");
-		if (arg_off_size(argc - 3, argv + 3, nand, &off, &size) != 0)
-			return 1;
-
-		s = strchr(cmd, '.');
-		if (s != NULL &&
-		    (!strcmp(s, ".jffs2") || !strcmp(s, ".e") || !strcmp(s, ".i"))) {
-			if (read) {
-				/* read */
-				nand_read_options_t opts;
-				memset(&opts, 0, sizeof(opts));
-				opts.buffer	= (u_char*) addr;
-				opts.length	= size;
-				opts.offset	= off;
-				opts.quiet      = quiet;
-				ret = nand_read_opts(nand, &opts);
-			} else {
-				/* write */
-				nand_write_options_t opts;
-				memset(&opts, 0, sizeof(opts));
-				opts.buffer	= (u_char*) addr;
-				opts.length	= size;
-				opts.offset	= off;
-				/* opts.forcejffs2 = 1; */
-				opts.pad	= 1;
-				opts.blockalign = 1;
-				opts.quiet      = quiet;
-				ret = nand_write_opts(nand, &opts);
-			}
-		} else {
-			if (read)
-				ret = nand_read(nand, off, &size, (u_char *)addr);
-			else
-				ret = nand_write(nand, off, &size, (u_char *)addr);
-		}
-
-		printf(" %d bytes %s: %s\n", size,
-		       read ? "read" : "written", ret ? "ERROR" : "OK");
-
-		return ret == 0 ? 0 : 1;
-	}
-
-	if (strcmp(cmd, "markbad") == 0) {
-		addr = (ulong)simple_strtoul(argv[2], NULL, 16);
-
-		int ret = nand->block_markbad(nand, addr);
-		if (ret == 0) {
-			printf("block 0x%08lx successfully marked as bad\n",
-			       (ulong) addr);
-			return 0;
-		} else {
-			printf("block 0x%08lx NOT marked as bad! ERROR %d\n",
-			       (ulong) addr, ret);
-		}
-		return 1;
-	}
-	if (strcmp(cmd, "biterr") == 0) {
-		/* todo */
-		return 1;
-	}
-
-	if (strcmp(cmd, "lock") == 0) {
-		int tight  = 0;
-		int status = 0;
-		if (argc == 3) {
-			if (!strcmp("tight", argv[2]))
-				tight = 1;
-			if (!strcmp("status", argv[2]))
-				status = 1;
-		}
-
-		if (status) {
-			ulong block_start = 0;
-			ulong off;
-			int last_status = -1;
-
-			struct nand_chip *nand_chip = nand->priv;
-			/* check the WP bit */
-			nand_chip->cmdfunc (nand, NAND_CMD_STATUS, -1, -1);
-			printf("device is %swrite protected\n",
-			       (nand_chip->read_byte(nand) & 0x80 ?
-				"NOT " : "" ) );
-
-			for (off = 0; off < nand->size; off += nand->oobblock) {
-				int s = nand_get_lock_status(nand, off);
-
-				/* print message only if status has changed
-				 * or at end of chip
-				 */
-				if (off == nand->size - nand->oobblock
-				    || (s != last_status && off != 0))	{
-
-					printf("%08x - %08x: %8d pages %s%s%s\n",
-					       block_start,
-					       off-1,
-					       (off-block_start)/nand->oobblock,
-					       ((last_status & NAND_LOCK_STATUS_TIGHT) ? "TIGHT " : ""),
-					       ((last_status & NAND_LOCK_STATUS_LOCK) ? "LOCK " : ""),
-					       ((last_status & NAND_LOCK_STATUS_UNLOCK) ? "UNLOCK " : ""));
-				}
-
-				last_status = s;
-		       }
-		} else {
-			if (!nand_lock(nand, tight)) {
-				puts("NAND flash successfully locked\n");
-			} else {
-				puts("Error locking NAND flash\n");
-				return 1;
-			}
-		}
-		return 0;
-	}
-
-	if (strcmp(cmd, "unlock") == 0) {
-		if (arg_off_size(argc - 2, argv + 2, nand, &off, &size) < 0)
-			return 1;
-
-		if (!nand_unlock(nand, off, size)) {
-			puts("NAND flash successfully unlocked\n");
-		} else {
-			puts("Error unlocking NAND flash, "
-			     "write and erase will probably fail\n");
-			return 1;
-		}
-		return 0;
-	}
+        /*
+         * Select the chip in the board/cpu specific driver
+         */
+        board_nand_select_device(nand_info[dev].priv, dev);
+#endif
+
+        return 0;
+    }
+
+    if (strcmp(cmd, "bad") != 0 && strcmp(cmd, "erase") != 0 &&
+        strncmp(cmd, "dump", 4) != 0 &&
+        strncmp(cmd, "read", 4) != 0 && strncmp(cmd, "write", 5) != 0 &&
+        strcmp(cmd, "scrub") != 0 && strcmp(cmd, "markbad") != 0 &&
+        strcmp(cmd, "biterr") != 0 &&
+        strcmp(cmd, "lock") != 0 && strcmp(cmd, "unlock") != 0 )
+        goto usage;
+
+    /* the following commands operate on the current device */
+    if (nand_curr_device < 0 || nand_curr_device >= CFG_MAX_NAND_DEVICE ||
+        !nand_info[nand_curr_device].name) {
+        puts("\nno devices available\n");
+        return 1;
+    }
+    nand = &nand_info[nand_curr_device];
+
+    if (strcmp(cmd, "bad") == 0) {
+        printf("\nDevice %d bad blocks:\n", nand_curr_device);
+        for (off = 0; off < nand->size; off += nand->erasesize)
+            if (nand_block_isbad(nand, off))
+                printf("  %08x\n", off);
+        return 0;
+    }
+
+    /*
+     * Syntax is:
+     *   0    1     2       3    4
+     *   nand erase [clean] [off size]
+     */
+    if (strcmp(cmd, "erase") == 0 || strcmp(cmd, "scrub") == 0) {
+        nand_erase_options_t opts;
+        /* "clean" at index 2 means request to write cleanmarker */
+        int clean = argc > 2 && !strcmp("clean", argv[2]);
+        int o = clean ? 3 : 2;
+        int scrub = !strcmp(cmd, "scrub");
+
+        printf("\nNAND %s: ", scrub ? "scrub" : "erase");
+        /* skip first two or three arguments, look for offset and size */
+        if (arg_off_size(argc - o, argv + o, nand, &off, &size) != 0)
+            return 1;
+
+        memset(&opts, 0, sizeof(opts));
+        opts.offset = off;
+        opts.length = size;
+        opts.jffs2  = clean;
+        opts.quiet  = quiet;
+
+        if (scrub) {
+            puts("Warning: "
+                 "scrub option will erase all factory set "
+                 "bad blocks!\n"
+                 "         "
+                 "There is no reliable way to recover them.\n"
+                 "         "
+                 "Use this command only for testing purposes "
+                 "if you\n"
+                 "         "
+                 "are sure of what you are doing!\n"
+                 "\nReally scrub this NAND flash? <y/N>\n");
+
+            if (getc() == 'y' && getc() == '\r') {
+                opts.scrub = 1;
+            } else {
+                puts("scrub aborted\n");
+                return -1;
+            }
+        }
+        ret = nand_erase_opts(nand, &opts);
+        printf("%s\n", ret ? "ERROR" : "OK");
+
+        return ret == 0 ? 0 : 1;
+    }
+
+    if (strncmp(cmd, "dump", 4) == 0) {
+        if (argc < 3)
+            goto usage;
+
+        s = strchr(cmd, '.');
+        off = (int)simple_strtoul(argv[2], NULL, 16);
+
+        if (s != NULL && strcmp(s, ".oob") == 0)
+            ret = nand_dump_oob(nand, off);
+        else
+            ret = nand_dump(nand, off);
+
+        return ret == 0 ? 1 : 0;
+
+    }
+
+    /* read write */
+    if (strncmp(cmd, "read", 4) == 0 || strncmp(cmd, "write", 5) == 0) {
+        int read;
+
+        if (argc < 4)
+            goto usage;
+
+        addr = (ulong)simple_strtoul(argv[2], NULL, 16);
+
+        read = strncmp(cmd, "read", 4) == 0; /* 1 = read, 0 = write */
+        printf("\nNAND %s: ", read ? "read" : "write");
+        if (arg_off_size(argc - 3, argv + 3, nand, &off, &size) != 0)
+            return 1;
+
+        s = strchr(cmd, '.');
+        if (s != NULL &&
+            (!strcmp(s, ".jffs2") || !strcmp(s, ".e") || !strcmp(s, ".i"))) {
+            if (read) {
+                /* read */
+                nand_read_options_t opts;
+                memset(&opts, 0, sizeof(opts));
+                opts.buffer = (u_char*) addr;
+                opts.length = size;
+                opts.offset = off;
+                opts.quiet      = quiet;
+                ret = nand_read_opts(nand, &opts);
+            } else {
+                /* write */
+                nand_write_options_t opts;
+                memset(&opts, 0, sizeof(opts));
+                opts.buffer = (u_char*) addr;
+                opts.length = size;
+                opts.offset = off;
+                /* opts.forcejffs2 = 1; */
+                opts.pad    = 1;
+                opts.blockalign = 1;
+                opts.quiet      = quiet;
+                ret = nand_write_opts(nand, &opts);
+            }
+        }else if (  s != NULL && !strcmp(s, ".yaffs")){
+            if (read) {
+                /* read */
+                nand_read_options_t opts;
+                memset(&opts, 0, sizeof(opts));
+                opts.buffer = (u_char*) addr;
+                opts.length = size;
+                opts.offset = off;
+                opts.readoob = 1;
+                opts.quiet      = quiet;
+                ret = nand_read_opts(nand, &opts);
+            } else {
+                /* write */
+                nand_write_options_t opts;
+                memset(&opts, 0, sizeof(opts));
+                opts.buffer = (u_char*) addr;
+                opts.length = size;
+                opts.offset = off;
+                /* opts.forceyaffs = 1; */
+                opts.noecc = 1;
+                opts.writeoob = 1;
+                opts.blockalign = 1;
+                opts.quiet      = quiet;
+                opts.skipfirstblk = 1;
+                ret = nand_write_opts(nand, &opts);
+            }
+        }else if (  s != NULL && !strcmp(s, ".raw")){
+            if (read) {
+                /* read */
+                nand_read_options_t opts;
+                memset(&opts, 0, sizeof(opts));
+                opts.buffer = (u_char*) addr;
+                opts.length = size;
+                opts.offset = off;
+                opts.readoob = 0;
+                opts.quiet      = quiet;
+                opts.noecc  = 1;
+                opts.nocheckbadblk = 1;
+                ret = nand_read_opts(nand, &opts);
+            } else {
+                /* write */
+                nand_write_options_t opts;
+                memset(&opts, 0, sizeof(opts));
+                opts.buffer = (u_char*) addr;
+                opts.length = size;
+                opts.offset = off;
+                /* opts.forceyaffs = 1; */
+                opts.noecc = 1;
+                opts.writeoob = 0;
+                opts.blockalign = 1;
+                opts.quiet      = quiet;
+                opts.skipfirstblk = 0;
+                opts.nocheckbadblk = 1;
+                ret = nand_write_opts(nand, &opts);
+            }
+        }        else {
+            if (read)
+                ret = nand_read(nand, off, &size, (u_char *)addr);
+            else
+                ret = nand_write(nand, off, &size, (u_char *)addr);
+        }
+
+        printf(" %d bytes %s: %s\n", size,
+               read ? "read" : "written", ret ? "ERROR" : "OK");
+
+        return ret == 0 ? 0 : 1;
+    }
+
+    if (strcmp(cmd, "markbad") == 0) {
+        addr = (ulong)simple_strtoul(argv[2], NULL, 16);
+
+        int ret = nand->block_markbad(nand, addr);
+        if (ret == 0) {
+            printf("block 0x%08lx successfully marked as bad\n",
+                   (ulong) addr);
+            return 0;
+        } else {
+            printf("block 0x%08lx NOT marked as bad! ERROR %d\n",
+                   (ulong) addr, ret);
+        }
+        return 1;
+    }
+    if (strcmp(cmd, "biterr") == 0) {
+        /* todo */
+        return 1;
+    }
+
+    if (strcmp(cmd, "lock") == 0) {
+        int tight  = 0;
+        int status = 0;
+        if (argc == 3) {
+            if (!strcmp("tight", argv[2]))
+                tight = 1;
+            if (!strcmp("status", argv[2]))
+                status = 1;
+        }
+
+        if (status) {
+            ulong block_start = 0;
+            ulong off;
+            int last_status = -1;
+
+            struct nand_chip *nand_chip = nand->priv;
+            /* check the WP bit */
+            nand_chip->cmdfunc (nand, NAND_CMD_STATUS, -1, -1);
+            printf("device is %swrite protected\n",
+                   (nand_chip->read_byte(nand) & 0x80 ?
+                "NOT " : "" ) );
+
+            for (off = 0; off < nand->size; off += nand->oobblock) {
+                int s = nand_get_lock_status(nand, off);
+
+                /* print message only if status has changed
+                 * or at end of chip
+                 */
+                if (off == nand->size - nand->oobblock
+                    || (s != last_status && off != 0))  {
+
+                    printf("%08x - %08x: %8d pages %s%s%s\n",
+                           block_start,
+                           off-1,
+                           (off-block_start)/nand->oobblock,
+                           ((last_status & NAND_LOCK_STATUS_TIGHT) ? "TIGHT " : ""),
+                           ((last_status & NAND_LOCK_STATUS_LOCK) ? "LOCK " : ""),
+                           ((last_status & NAND_LOCK_STATUS_UNLOCK) ? "UNLOCK " : ""));
+                }
+
+                last_status = s;
+               }
+        } else {
+            if (!nand_lock(nand, tight)) {
+                puts("NAND flash successfully locked\n");
+            } else {
+                puts("Error locking NAND flash\n");
+                return 1;
+            }
+        }
+        return 0;
+    }
+
+    if (strcmp(cmd, "unlock") == 0) {
+        if (arg_off_size(argc - 2, argv + 2, nand, &off, &size) < 0)
+            return 1;
+
+        if (!nand_unlock(nand, off, size)) {
+            puts("NAND flash successfully unlocked\n");
+        } else {
+            puts("Error unlocking NAND flash, "
+                 "write and erase will probably fail\n");
+            return 1;
+        }
+        return 0;
+    }
 
 usage:
-	printf("Usage:\n%s\n", cmdtp->usage);
-	return 1;
+    printf("Usage:\n%s\n", cmdtp->usage);
+    return 1;
 }
 
 U_BOOT_CMD(nand, 5, 1, do_nand,
-	"nand    - NAND sub-system\n",
-	"info                  - show available NAND devices\n"
-	"nand device [dev]     - show or set current device\n"
-	"nand read[.jffs2]     - addr off|partition size\n"
-	"nand write[.jffs2]    - addr off|partiton size - read/write `size' bytes starting\n"
-	"    at offset `off' to/from memory address `addr'\n"
-	"nand erase [clean] [off size] - erase `size' bytes from\n"
-	"    offset `off' (entire device if not specified)\n"
-	"nand bad - show bad blocks\n"
-	"nand dump[.oob] off - dump page\n"
-	"nand scrub - really clean NAND erasing bad blocks (UNSAFE)\n"
-	"nand markbad off - mark bad block at offset (UNSAFE)\n"
-	"nand biterr off - make a bit error at offset (UNSAFE)\n"
-	"nand lock [tight] [status] - bring nand to lock state or display locked pages\n"
-	"nand unlock [offset] [size] - unlock section\n");
+    "nand    - NAND sub-system\n",
+    "info                  - show available NAND devices\n"
+    "nand device [dev]     - show or set current device\n"
+    "nand read[.jffs2]     - addr off|partition size\n"
+    "nand write[.jffs2]    - addr off|partiton size - read/write `size' bytes starting\n"
+    "    at offset `off' to/from memory address `addr'\n"
+    "nand read.yaffs addr off size - read the `size' byte yaffs image starting\n"
+    "    at offset `off' to memory address `addr'\n"
+    "nand write.yaffs addr off size - write the `size' byte yaffs image starting\n"
+    "    at offset `off' from memory address `addr'\n"
+    "nand read.raw addr off size - read the `size' bytes starting\n"
+    "    at offset `off' to memory address `addr', without oob and ecc\n"
+    "nand write.raw addr off size - write the `size' bytes starting\n"
+    "    at offset `off' from memory address `addr', without oob and ecc\n"
+    "nand erase [clean] [off size] - erase `size' bytes from\n"
+    "    offset `off' (entire device if not specified)\n"
+    "nand bad - show bad blocks\n"
+    "nand dump[.oob] off - dump page\n"
+    "nand scrub - really clean NAND erasing bad blocks (UNSAFE)\n"
+    "nand markbad off - mark bad block at offset (UNSAFE)\n"
+    "nand biterr off - make a bit error at offset (UNSAFE)\n"
+    "nand lock [tight] [status] - bring nand to lock state or display locked pages\n"
+    "nand unlock [offset] [size] - unlock section\n");
 
 static int nand_load_image(cmd_tbl_t *cmdtp, nand_info_t *nand,
-			   ulong offset, ulong addr, char *cmd)
+               ulong offset, ulong addr, char *cmd)
 {
-	int r;
-	char *ep;
-	ulong cnt;
-	image_header_t *hdr;
-
-	printf("\nLoading from %s, offset 0x%lx\n", nand->name, offset);
-
-	cnt = nand->oobblock;
-	r = nand_read(nand, offset, &cnt, (u_char *) addr);
-	if (r) {
-		puts("** Read error\n");
-		SHOW_BOOT_PROGRESS(-1);
-		return 1;
-	}
-
-	hdr = (image_header_t *) addr;
-
-	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
-		printf("\n** Bad Magic Number 0x%x **\n", hdr->ih_magic);
-		SHOW_BOOT_PROGRESS(-1);
-		return 1;
-	}
-
-	print_image_hdr(hdr);
-
-	cnt = (ntohl(hdr->ih_size) + sizeof (image_header_t));
-
-	r = nand_read(nand, offset, &cnt, (u_char *) addr);
-	if (r) {
-		puts("** Read error\n");
-		SHOW_BOOT_PROGRESS(-1);
-		return 1;
-	}
-
-	/* Loading ok, update default load address */
-
-	load_addr = addr;
-
-	/* Check if we should attempt an auto-start */
-	if (((ep = getenv("autostart")) != NULL) && (strcmp(ep, "yes") == 0)) {
-		char *local_args[2];
-		extern int do_bootm(cmd_tbl_t *, int, int, char *[]);
-
-		local_args[0] = cmd;
-		local_args[1] = NULL;
-
-		printf("Automatic boot of image at addr 0x%08lx ...\n", addr);
-
-		do_bootm(cmdtp, 0, 1, local_args);
-		return 1;
-	}
-	return 0;
+    int r;
+    char *ep;
+    ulong cnt;
+    image_header_t *hdr;
+
+    printf("\nLoading from %s, offset 0x%lx\n", nand->name, offset);
+
+    cnt = nand->oobblock;
+    r = nand_read(nand, offset, &cnt, (u_char *) addr);
+    if (r) {
+        puts("** Read error\n");
+        SHOW_BOOT_PROGRESS(-1);
+        return 1;
+    }
+
+    hdr = (image_header_t *) addr;
+
+    if (ntohl(hdr->ih_magic) != IH_MAGIC) {
+        printf("\n** Bad Magic Number 0x%x **\n", hdr->ih_magic);
+        SHOW_BOOT_PROGRESS(-1);
+        return 1;
+    }
+
+    print_image_hdr(hdr);
+
+    cnt = (ntohl(hdr->ih_size) + sizeof (image_header_t));
+
+    r = nand_read(nand, offset, &cnt, (u_char *) addr);
+    if (r) {
+        puts("** Read error\n");
+        SHOW_BOOT_PROGRESS(-1);
+        return 1;
+    }
+
+    /* Loading ok, update default load address */
+
+    load_addr = addr;
+
+    /* Check if we should attempt an auto-start */
+    if (((ep = getenv("autostart")) != NULL) && (strcmp(ep, "yes") == 0)) {
+        char *local_args[2];
+        extern int do_bootm(cmd_tbl_t *, int, int, char *[]);
+
+        local_args[0] = cmd;
+        local_args[1] = NULL;
+
+        printf("Automatic boot of image at addr 0x%08lx ...\n", addr);
+
+        do_bootm(cmdtp, 0, 1, local_args);
+        return 1;
+    }
+    return 0;
 }
 
 int do_nandboot(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 {
-	char *boot_device = NULL;
-	int idx;
-	ulong addr, offset = 0;
+    char *boot_device = NULL;
+    int idx;
+    ulong addr, offset = 0;
 #if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
-	struct mtd_device *dev;
-	struct part_info *part;
-	u8 pnum;
-
-	if (argc >= 2) {
-		char *p = (argc == 2) ? argv[1] : argv[2];
-		if (!(str2long(p, &addr)) && (mtdparts_init() == 0) &&
-		    (find_dev_and_part(p, &dev, &pnum, &part) == 0)) {
-			if (dev->id->type != MTD_DEV_TYPE_NAND) {
-				puts("Not a NAND device\n");
-				return 1;
-			}
-			if (argc > 3)
-				goto usage;
-			if (argc == 3)
-				addr = simple_strtoul(argv[2], NULL, 16);
-			else
-				addr = CFG_LOAD_ADDR;
-			return nand_load_image(cmdtp, &nand_info[dev->id->num],
-					       part->offset, addr, argv[0]);
-		}
-	}
-#endif
-
-	switch (argc) {
-	case 1:
-		addr = CFG_LOAD_ADDR;
-		boot_device = getenv("bootdevice");
-		break;
-	case 2:
-		addr = simple_strtoul(argv[1], NULL, 16);
-		boot_device = getenv("bootdevice");
-		break;
-	case 3:
-		addr = simple_strtoul(argv[1], NULL, 16);
-		boot_device = argv[2];
-		break;
-	case 4:
-		addr = simple_strtoul(argv[1], NULL, 16);
-		boot_device = argv[2];
-		offset = simple_strtoul(argv[3], NULL, 16);
-		break;
-	default:
+    struct mtd_device *dev;
+    struct part_info *part;
+    u8 pnum;
+
+    if (argc >= 2) {
+        char *p = (argc == 2) ? argv[1] : argv[2];
+        if (!(str2long(p, &addr)) && (mtdparts_init() == 0) &&
+            (find_dev_and_part(p, &dev, &pnum, &part) == 0)) {
+            if (dev->id->type != MTD_DEV_TYPE_NAND) {
+                puts("Not a NAND device\n");
+                return 1;
+            }
+            if (argc > 3)
+                goto usage;
+            if (argc == 3)
+                addr = simple_strtoul(argv[1], NULL, 16);
+            else
+                addr = CFG_LOAD_ADDR;
+            return nand_load_image(cmdtp, &nand_info[dev->id->num],
+                           part->offset, addr, argv[0]);
+        }
+    }
+#endif
+
+    switch (argc) {
+    case 1:
+        addr = CFG_LOAD_ADDR;
+        boot_device = getenv("bootdevice");
+        break;
+    case 2:
+        addr = simple_strtoul(argv[1], NULL, 16);
+        boot_device = getenv("bootdevice");
+        break;
+    case 3:
+        addr = simple_strtoul(argv[1], NULL, 16);
+        boot_device = argv[2];
+        break;
+    case 4:
+        addr = simple_strtoul(argv[1], NULL, 16);
+        boot_device = argv[2];
+        offset = simple_strtoul(argv[3], NULL, 16);
+        break;
+    default:
 #if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
 usage:
 #endif
-		printf("Usage:\n%s\n", cmdtp->usage);
-		SHOW_BOOT_PROGRESS(-1);
-		return 1;
-	}
-
-	if (!boot_device) {
-		puts("\n** No boot device **\n");
-		SHOW_BOOT_PROGRESS(-1);
-		return 1;
-	}
-
-	idx = simple_strtoul(boot_device, NULL, 16);
-
-	if (idx < 0 || idx >= CFG_MAX_NAND_DEVICE || !nand_info[idx].name) {
-		printf("\n** Device %d not available\n", idx);
-		SHOW_BOOT_PROGRESS(-1);
-		return 1;
-	}
+        printf("Usage:\n%s\n", cmdtp->usage);
+        SHOW_BOOT_PROGRESS(-1);
+        return 1;
+    }
+
+    if (!boot_device) {
+        puts("\n** No boot device **\n");
+        SHOW_BOOT_PROGRESS(-1);
+        return 1;
+    }
+
+    idx = simple_strtoul(boot_device, NULL, 16);
+
+    if (idx < 0 || idx >= CFG_MAX_NAND_DEVICE || !nand_info[idx].name) {
+        printf("\n** Device %d not available\n", idx);
+        SHOW_BOOT_PROGRESS(-1);
+        return 1;
+    }
 
-	return nand_load_image(cmdtp, &nand_info[idx], offset, addr, argv[0]);
+    return nand_load_image(cmdtp, &nand_info[idx], offset, addr, argv[0]);
 }
 
 U_BOOT_CMD(nboot, 4, 1, do_nandboot,
-	"nboot   - boot from NAND device\n",
-	"[partition] | [[[loadAddr] dev] offset]\n");
+    "nboot   - boot from NAND device\n",
+    "[[loadAddr] partition] | [[[loadAddr] dev] offset]\n");
 
-#endif				/* (CONFIG_COMMANDS & CFG_CMD_NAND) */
+#endif              /* (CONFIG_COMMANDS & CFG_CMD_NAND) */
 
 #else /* CFG_NAND_LEGACY */
 /*
@@ -622,7 +685,7 @@
 
 #ifdef CONFIG_SHOW_BOOT_PROGRESS
 # include <status_led.h>
-# define SHOW_BOOT_PROGRESS(arg)	show_boot_progress(arg)
+# define SHOW_BOOT_PROGRESS(arg)    show_boot_progress(arg)
 #else
 # define SHOW_BOOT_PROGRESS(arg)
 #endif
@@ -640,8 +703,8 @@
 
 #define ROUND_DOWN(value,boundary)      ((value) & (~((boundary)-1)))
 
-#undef	NAND_DEBUG
-#undef	PSYCHO_DEBUG
+#undef  NAND_DEBUG
+#undef  PSYCHO_DEBUG
 
 /* ****************** WARNING *********************
  * When ALLOW_ERASE_BAD_DEBUG is non-zero the erase command will
@@ -656,16 +719,16 @@
  * and attempting to program or erase bad blocks can affect
  * the data in _other_ (good) blocks.
  */
-#define	 ALLOW_ERASE_BAD_DEBUG 0
+#define  ALLOW_ERASE_BAD_DEBUG 0
 
 #define CONFIG_MTD_NAND_ECC  /* enable ECC */
 #define CONFIG_MTD_NAND_ECC_JFFS2
 
 /* bits for nand_legacy_rw() `cmd'; or together as needed */
-#define NANDRW_READ	0x01
-#define NANDRW_WRITE	0x00
-#define NANDRW_JFFS2	0x02
-#define NANDRW_JFFS2_SKIP	0x04
+#define NANDRW_READ 0x01
+#define NANDRW_WRITE    0x00
+#define NANDRW_JFFS2    0x02
+#define NANDRW_JFFS2_SKIP   0x04
 
 /*
  * Imports from nand_legacy.c
@@ -673,15 +736,15 @@
 extern struct nand_chip nand_dev_desc[CFG_MAX_NAND_DEVICE];
 extern int curr_device;
 extern int nand_legacy_erase(struct nand_chip *nand, size_t ofs,
-			    size_t len, int clean);
+                size_t len, int clean);
 extern int nand_legacy_rw(struct nand_chip *nand, int cmd, size_t start,
-			 size_t len, size_t *retlen, u_char *buf);
+             size_t len, size_t *retlen, u_char *buf);
 extern void nand_print(struct nand_chip *nand);
 extern void nand_print_bad(struct nand_chip *nand);
 extern int nand_read_oob(struct nand_chip *nand, size_t ofs,
-			       size_t len, size_t *retlen, u_char *buf);
+                   size_t len, size_t *retlen, u_char *buf);
 extern int nand_write_oob(struct nand_chip *nand, size_t ofs,
-				size_t len, size_t *retlen, const u_char *buf);
+                size_t len, size_t *retlen, const u_char *buf);
 
 
 int do_nand (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
@@ -691,294 +754,294 @@
     switch (argc) {
     case 0:
     case 1:
-	printf ("Usage:\n%s\n", cmdtp->usage);
-	return 1;
+    printf ("Usage:\n%s\n", cmdtp->usage);
+    return 1;
     case 2:
-	if (strcmp(argv[1],"info") == 0) {
-		int i;
+    if (strcmp(argv[1],"info") == 0) {
+        int i;
 
-		putc ('\n');
+        putc ('\n');
 
-		for (i=0; i<CFG_MAX_NAND_DEVICE; ++i) {
-			if(nand_dev_desc[i].ChipID == NAND_ChipID_UNKNOWN)
-				continue; /* list only known devices */
-			printf ("Device %d: ", i);
-			nand_print(&nand_dev_desc[i]);
-		}
-		return 0;
-
-	} else if (strcmp(argv[1],"device") == 0) {
-		if ((curr_device < 0) || (curr_device >= CFG_MAX_NAND_DEVICE)) {
-			puts ("\nno devices available\n");
-			return 1;
-		}
-		printf ("\nDevice %d: ", curr_device);
-		nand_print(&nand_dev_desc[curr_device]);
-		return 0;
-
-	} else if (strcmp(argv[1],"bad") == 0) {
-		if ((curr_device < 0) || (curr_device >= CFG_MAX_NAND_DEVICE)) {
-			puts ("\nno devices available\n");
-			return 1;
-		}
-		printf ("\nDevice %d bad blocks:\n", curr_device);
-		nand_print_bad(&nand_dev_desc[curr_device]);
-		return 0;
-
-	}
-	printf ("Usage:\n%s\n", cmdtp->usage);
-	return 1;
-    case 3:
-	if (strcmp(argv[1],"device") == 0) {
-		int dev = (int)simple_strtoul(argv[2], NULL, 10);
+        for (i=0; i<CFG_MAX_NAND_DEVICE; ++i) {
+            if(nand_dev_desc[i].ChipID == NAND_ChipID_UNKNOWN)
+                continue; /* list only known devices */
+            printf ("Device %d: ", i);
+            nand_print(&nand_dev_desc[i]);
+        }
+        return 0;
+
+    } else if (strcmp(argv[1],"device") == 0) {
+        if ((curr_device < 0) || (curr_device >= CFG_MAX_NAND_DEVICE)) {
+            puts ("\nno devices available\n");
+            return 1;
+        }
+        printf ("\nDevice %d: ", curr_device);
+        nand_print(&nand_dev_desc[curr_device]);
+        return 0;
+
+    } else if (strcmp(argv[1],"bad") == 0) {
+        if ((curr_device < 0) || (curr_device >= CFG_MAX_NAND_DEVICE)) {
+            puts ("\nno devices available\n");
+            return 1;
+        }
+        printf ("\nDevice %d bad blocks:\n", curr_device);
+        nand_print_bad(&nand_dev_desc[curr_device]);
+        return 0;
 
-		printf ("\nDevice %d: ", dev);
-		if (dev >= CFG_MAX_NAND_DEVICE) {
-			puts ("unknown device\n");
-			return 1;
-		}
-		nand_print(&nand_dev_desc[dev]);
-		/*nand_print (dev);*/
+    }
+    printf ("Usage:\n%s\n", cmdtp->usage);
+    return 1;
+    case 3:
+    if (strcmp(argv[1],"device") == 0) {
+        int dev = (int)simple_strtoul(argv[2], NULL, 10);
 
-		if (nand_dev_desc[dev].ChipID == NAND_ChipID_UNKNOWN) {
-			return 1;
-		}
+        printf ("\nDevice %d: ", dev);
+        if (dev >= CFG_MAX_NAND_DEVICE) {
+            puts ("unknown device\n");
+            return 1;
+        }
+        nand_print(&nand_dev_desc[dev]);
+        /*nand_print (dev);*/
+
+        if (nand_dev_desc[dev].ChipID == NAND_ChipID_UNKNOWN) {
+            return 1;
+        }
 
-		curr_device = dev;
+        curr_device = dev;
 
-		puts ("... is now current device\n");
+        puts ("... is now current device\n");
 
-		return 0;
-	}
-	else if (strcmp(argv[1],"erase") == 0 && strcmp(argv[2], "clean") == 0) {
-		struct nand_chip* nand = &nand_dev_desc[curr_device];
-		ulong off = 0;
-		ulong size = nand->totlen;
-		int ret;
+        return 0;
+    }
+    else if (strcmp(argv[1],"erase") == 0 && strcmp(argv[2], "clean") == 0) {
+        struct nand_chip* nand = &nand_dev_desc[curr_device];
+        ulong off = 0;
+        ulong size = nand->totlen;
+        int ret;
 
-		printf ("\nNAND erase: device %d offset %ld, size %ld ... ",
-			curr_device, off, size);
+        printf ("\nNAND erase: device %d offset %ld, size %ld ... ",
+            curr_device, off, size);
 
-		ret = nand_legacy_erase (nand, off, size, 1);
+        ret = nand_legacy_erase (nand, off, size, 1);
 
-		printf("%s\n", ret ? "ERROR" : "OK");
+        printf("%s\n", ret ? "ERROR" : "OK");
 
-		return ret;
-	}
+        return ret;
+    }
 
-	printf ("Usage:\n%s\n", cmdtp->usage);
-	return 1;
+    printf ("Usage:\n%s\n", cmdtp->usage);
+    return 1;
     default:
-	/* at least 4 args */
+    /* at least 4 args */
 
-	if (strncmp(argv[1], "read", 4) == 0 ||
-	    strncmp(argv[1], "write", 5) == 0) {
-		ulong addr = simple_strtoul(argv[2], NULL, 16);
-		ulong off  = simple_strtoul(argv[3], NULL, 16);
-		ulong size = simple_strtoul(argv[4], NULL, 16);
-		int cmd    = (strncmp(argv[1], "read", 4) == 0) ?
-				NANDRW_READ : NANDRW_WRITE;
-		int ret, total;
-		char* cmdtail = strchr(argv[1], '.');
-
-		if (cmdtail && !strncmp(cmdtail, ".oob", 2)) {
-			/* read out-of-band data */
-			if (cmd & NANDRW_READ) {
-				ret = nand_read_oob(nand_dev_desc + curr_device,
-						    off, size, (size_t *)&total,
-						    (u_char*)addr);
-			}
-			else {
-				ret = nand_write_oob(nand_dev_desc + curr_device,
-						     off, size, (size_t *)&total,
-						     (u_char*)addr);
-			}
-			return ret;
-		}
-		else if (cmdtail && !strncmp(cmdtail, ".jffs2", 2))
-			cmd |= NANDRW_JFFS2;	/* skip bad blocks */
-		else if (cmdtail && !strncmp(cmdtail, ".jffs2s", 2)) {
-			cmd |= NANDRW_JFFS2;	/* skip bad blocks (on read too) */
-			if (cmd & NANDRW_READ)
-				cmd |= NANDRW_JFFS2_SKIP;	/* skip bad blocks (on read too) */
-		}
+    if (strncmp(argv[1], "read", 4) == 0 ||
+        strncmp(argv[1], "write", 5) == 0) {
+        ulong addr = simple_strtoul(argv[2], NULL, 16);
+        ulong off  = simple_strtoul(argv[3], NULL, 16);
+        ulong size = simple_strtoul(argv[4], NULL, 16);
+        int cmd    = (strncmp(argv[1], "read", 4) == 0) ?
+                NANDRW_READ : NANDRW_WRITE;
+        int ret, total;
+        char* cmdtail = strchr(argv[1], '.');
+
+        if (cmdtail && !strncmp(cmdtail, ".oob", 2)) {
+            /* read out-of-band data */
+            if (cmd & NANDRW_READ) {
+                ret = nand_read_oob(nand_dev_desc + curr_device,
+                            off, size, (size_t *)&total,
+                            (u_char*)addr);
+            }
+            else {
+                ret = nand_write_oob(nand_dev_desc + curr_device,
+                             off, size, (size_t *)&total,
+                             (u_char*)addr);
+            }
+            return ret;
+        }
+        else if (cmdtail && !strncmp(cmdtail, ".jffs2", 2))
+            cmd |= NANDRW_JFFS2;    /* skip bad blocks */
+        else if (cmdtail && !strncmp(cmdtail, ".jffs2s", 2)) {
+            cmd |= NANDRW_JFFS2;    /* skip bad blocks (on read too) */
+            if (cmd & NANDRW_READ)
+                cmd |= NANDRW_JFFS2_SKIP;   /* skip bad blocks (on read too) */
+        }
 #ifdef SXNI855T
-		/* need ".e" same as ".j" for compatibility with older units */
-		else if (cmdtail && !strcmp(cmdtail, ".e"))
-			cmd |= NANDRW_JFFS2;	/* skip bad blocks */
+        /* need ".e" same as ".j" for compatibility with older units */
+        else if (cmdtail && !strcmp(cmdtail, ".e"))
+            cmd |= NANDRW_JFFS2;    /* skip bad blocks */
 #endif
 #ifdef CFG_NAND_SKIP_BAD_DOT_I
-		/* need ".i" same as ".jffs2s" for compatibility with older units (esd) */
-		/* ".i" for image -> read skips bad block (no 0xff) */
-		else if (cmdtail && !strcmp(cmdtail, ".i")) {
-			cmd |= NANDRW_JFFS2;	/* skip bad blocks (on read too) */
-			if (cmd & NANDRW_READ)
-				cmd |= NANDRW_JFFS2_SKIP;	/* skip bad blocks (on read too) */
-		}
+        /* need ".i" same as ".jffs2s" for compatibility with older units (esd) */
+        /* ".i" for image -> read skips bad block (no 0xff) */
+        else if (cmdtail && !strcmp(cmdtail, ".i")) {
+            cmd |= NANDRW_JFFS2;    /* skip bad blocks (on read too) */
+            if (cmd & NANDRW_READ)
+                cmd |= NANDRW_JFFS2_SKIP;   /* skip bad blocks (on read too) */
+        }
 #endif /* CFG_NAND_SKIP_BAD_DOT_I */
-		else if (cmdtail) {
-			printf ("Usage:\n%s\n", cmdtp->usage);
-			return 1;
-		}
-
-		printf ("\nNAND %s: device %d offset %ld, size %ld ...\n",
-			(cmd & NANDRW_READ) ? "read" : "write",
-			curr_device, off, size);
-
-		ret = nand_legacy_rw(nand_dev_desc + curr_device, cmd, off, size,
-			     (size_t *)&total, (u_char*)addr);
-
-		printf (" %d bytes %s: %s\n", total,
-			(cmd & NANDRW_READ) ? "read" : "written",
-			ret ? "ERROR" : "OK");
-
-		return ret;
-	} else if (strcmp(argv[1],"erase") == 0 &&
-		   (argc == 4 || strcmp("clean", argv[2]) == 0)) {
-		int clean = argc == 5;
-		ulong off = simple_strtoul(argv[2 + clean], NULL, 16);
-		ulong size = simple_strtoul(argv[3 + clean], NULL, 16);
-		int ret;
-
-		printf ("\nNAND erase: device %d offset %ld, size %ld ...\n",
-			curr_device, off, size);
-
-		ret = nand_legacy_erase (nand_dev_desc + curr_device,
-					off, size, clean);
-
-		printf("%s\n", ret ? "ERROR" : "OK");
-
-		return ret;
-	} else {
-		printf ("Usage:\n%s\n", cmdtp->usage);
-		rcode = 1;
-	}
+        else if (cmdtail) {
+            printf ("Usage:\n%s\n", cmdtp->usage);
+            return 1;
+        }
+
+        printf ("\nNAND %s: device %d offset %ld, size %ld ...\n",
+            (cmd & NANDRW_READ) ? "read" : "write",
+            curr_device, off, size);
+
+        ret = nand_legacy_rw(nand_dev_desc + curr_device, cmd, off, size,
+                 (size_t *)&total, (u_char*)addr);
+
+        printf (" %d bytes %s: %s\n", total,
+            (cmd & NANDRW_READ) ? "read" : "written",
+            ret ? "ERROR" : "OK");
+
+        return ret;
+    } else if (strcmp(argv[1],"erase") == 0 &&
+           (argc == 4 || strcmp("clean", argv[2]) == 0)) {
+        int clean = argc == 5;
+        ulong off = simple_strtoul(argv[2 + clean], NULL, 16);
+        ulong size = simple_strtoul(argv[3 + clean], NULL, 16);
+        int ret;
+
+        printf ("\nNAND erase: device %d offset %ld, size %ld ...\n",
+            curr_device, off, size);
+
+        ret = nand_legacy_erase (nand_dev_desc + curr_device,
+                    off, size, clean);
+
+        printf("%s\n", ret ? "ERROR" : "OK");
+
+        return ret;
+    } else {
+        printf ("Usage:\n%s\n", cmdtp->usage);
+        rcode = 1;
+    }
 
-	return rcode;
+    return rcode;
     }
 }
 
 U_BOOT_CMD(
-	nand,	5,	1,	do_nand,
-	"nand    - legacy NAND sub-system\n",
-	"info  - show available NAND devices\n"
-	"nand device [dev] - show or set current device\n"
-	"nand read[.jffs2[s]]  addr off size\n"
-	"nand write[.jffs2] addr off size - read/write `size' bytes starting\n"
-	"    at offset `off' to/from memory address `addr'\n"
-	"nand erase [clean] [off size] - erase `size' bytes from\n"
-	"    offset `off' (entire device if not specified)\n"
-	"nand bad - show bad blocks\n"
-	"nand read.oob addr off size - read out-of-band data\n"
-	"nand write.oob addr off size - read out-of-band data\n"
+    nand,   5,  1,  do_nand,
+    "nand    - legacy NAND sub-system\n",
+    "info  - show available NAND devices\n"
+    "nand device [dev] - show or set current device\n"
+    "nand read[.jffs2[s]]  addr off size\n"
+    "nand write[.jffs2] addr off size - read/write `size' bytes starting\n"
+    "    at offset `off' to/from memory address `addr'\n"
+    "nand erase [clean] [off size] - erase `size' bytes from\n"
+    "    offset `off' (entire device if not specified)\n"
+    "nand bad - show bad blocks\n"
+    "nand read.oob addr off size - read out-of-band data\n"
+    "nand write.oob addr off size - read out-of-band data\n"
 );
 
 int do_nandboot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-	char *boot_device = NULL;
-	char *ep;
-	int dev;
-	ulong cnt;
-	ulong addr;
-	ulong offset = 0;
-	image_header_t *hdr;
-	int rcode = 0;
-	switch (argc) {
-	case 1:
-		addr = CFG_LOAD_ADDR;
-		boot_device = getenv ("bootdevice");
-		break;
-	case 2:
-		addr = simple_strtoul(argv[1], NULL, 16);
-		boot_device = getenv ("bootdevice");
-		break;
-	case 3:
-		addr = simple_strtoul(argv[1], NULL, 16);
-		boot_device = argv[2];
-		break;
-	case 4:
-		addr = simple_strtoul(argv[1], NULL, 16);
-		boot_device = argv[2];
-		offset = simple_strtoul(argv[3], NULL, 16);
-		break;
-	default:
-		printf ("Usage:\n%s\n", cmdtp->usage);
-		SHOW_BOOT_PROGRESS (-1);
-		return 1;
-	}
-
-	if (!boot_device) {
-		puts ("\n** No boot device **\n");
-		SHOW_BOOT_PROGRESS (-1);
-		return 1;
-	}
-
-	dev = simple_strtoul(boot_device, &ep, 16);
-
-	if ((dev >= CFG_MAX_NAND_DEVICE) ||
-	    (nand_dev_desc[dev].ChipID == NAND_ChipID_UNKNOWN)) {
-		printf ("\n** Device %d not available\n", dev);
-		SHOW_BOOT_PROGRESS (-1);
-		return 1;
-	}
-
-	printf ("\nLoading from device %d: %s at 0x%lx (offset 0x%lx)\n",
-		dev, nand_dev_desc[dev].name, nand_dev_desc[dev].IO_ADDR,
-		offset);
-
-	if (nand_legacy_rw (nand_dev_desc + dev, NANDRW_READ, offset,
-			SECTORSIZE, NULL, (u_char *)addr)) {
-		printf ("** Read error on %d\n", dev);
-		SHOW_BOOT_PROGRESS (-1);
-		return 1;
-	}
-
-	hdr = (image_header_t *)addr;
-
-	if (ntohl(hdr->ih_magic) == IH_MAGIC) {
-
-		print_image_hdr (hdr);
-
-		cnt = (ntohl(hdr->ih_size) + sizeof(image_header_t));
-		cnt -= SECTORSIZE;
-	} else {
-		printf ("\n** Bad Magic Number 0x%x **\n", ntohl(hdr->ih_magic));
-		SHOW_BOOT_PROGRESS (-1);
-		return 1;
-	}
-
-	if (nand_legacy_rw (nand_dev_desc + dev, NANDRW_READ,
-			offset + SECTORSIZE, cnt, NULL,
-			(u_char *)(addr+SECTORSIZE))) {
-		printf ("** Read error on %d\n", dev);
-		SHOW_BOOT_PROGRESS (-1);
-		return 1;
-	}
-
-	/* Loading ok, update default load address */
-
-	load_addr = addr;
-
-	/* Check if we should attempt an auto-start */
-	if (((ep = getenv("autostart")) != NULL) && (strcmp(ep,"yes") == 0)) {
-		char *local_args[2];
-		extern int do_bootm (cmd_tbl_t *, int, int, char *[]);
-
-		local_args[0] = argv[0];
-		local_args[1] = NULL;
-
-		printf ("Automatic boot of image at addr 0x%08lx ...\n", addr);
-
-		do_bootm (cmdtp, 0, 1, local_args);
-		rcode = 1;
-	}
-	return rcode;
+    char *boot_device = NULL;
+    char *ep;
+    int dev;
+    ulong cnt;
+    ulong addr;
+    ulong offset = 0;
+    image_header_t *hdr;
+    int rcode = 0;
+    switch (argc) {
+    case 1:
+        addr = CFG_LOAD_ADDR;
+        boot_device = getenv ("bootdevice");
+        break;
+    case 2:
+        addr = simple_strtoul(argv[1], NULL, 16);
+        boot_device = getenv ("bootdevice");
+        break;
+    case 3:
+        addr = simple_strtoul(argv[1], NULL, 16);
+        boot_device = argv[2];
+        break;
+    case 4:
+        addr = simple_strtoul(argv[1], NULL, 16);
+        boot_device = argv[2];
+        offset = simple_strtoul(argv[3], NULL, 16);
+        break;
+    default:
+        printf ("Usage:\n%s\n", cmdtp->usage);
+        SHOW_BOOT_PROGRESS (-1);
+        return 1;
+    }
+
+    if (!boot_device) {
+        puts ("\n** No boot device **\n");
+        SHOW_BOOT_PROGRESS (-1);
+        return 1;
+    }
+
+    dev = simple_strtoul(boot_device, &ep, 16);
+
+    if ((dev >= CFG_MAX_NAND_DEVICE) ||
+        (nand_dev_desc[dev].ChipID == NAND_ChipID_UNKNOWN)) {
+        printf ("\n** Device %d not available\n", dev);
+        SHOW_BOOT_PROGRESS (-1);
+        return 1;
+    }
+
+    printf ("\nLoading from device %d: %s at 0x%lx (offset 0x%lx)\n",
+        dev, nand_dev_desc[dev].name, nand_dev_desc[dev].IO_ADDR,
+        offset);
+
+    if (nand_legacy_rw (nand_dev_desc + dev, NANDRW_READ, offset,
+            SECTORSIZE, NULL, (u_char *)addr)) {
+        printf ("** Read error on %d\n", dev);
+        SHOW_BOOT_PROGRESS (-1);
+        return 1;
+    }
+
+    hdr = (image_header_t *)addr;
+
+    if (ntohl(hdr->ih_magic) == IH_MAGIC) {
+
+        print_image_hdr (hdr);
+
+        cnt = (ntohl(hdr->ih_size) + sizeof(image_header_t));
+        cnt -= SECTORSIZE;
+    } else {
+        printf ("\n** Bad Magic Number 0x%x **\n", ntohl(hdr->ih_magic));
+        SHOW_BOOT_PROGRESS (-1);
+        return 1;
+    }
+
+    if (nand_legacy_rw (nand_dev_desc + dev, NANDRW_READ,
+            offset + SECTORSIZE, cnt, NULL,
+            (u_char *)(addr+SECTORSIZE))) {
+        printf ("** Read error on %d\n", dev);
+        SHOW_BOOT_PROGRESS (-1);
+        return 1;
+    }
+
+    /* Loading ok, update default load address */
+
+    load_addr = addr;
+
+    /* Check if we should attempt an auto-start */
+    if (((ep = getenv("autostart")) != NULL) && (strcmp(ep,"yes") == 0)) {
+        char *local_args[2];
+        extern int do_bootm (cmd_tbl_t *, int, int, char *[]);
+
+        local_args[0] = argv[0];
+        local_args[1] = NULL;
+
+        printf ("Automatic boot of image at addr 0x%08lx ...\n", addr);
+
+        do_bootm (cmdtp, 0, 1, local_args);
+        rcode = 1;
+    }
+    return rcode;
 }
 
 U_BOOT_CMD(
-	nboot,	4,	1,	do_nandboot,
-	"nboot   - boot from NAND device\n",
-	"loadAddr dev\n"
+    nboot,  4,  1,  do_nandboot,
+    "nboot   - boot from NAND device\n",
+    "loadAddr dev\n"
 );
 
 #endif /* (CONFIG_COMMANDS & CFG_CMD_NAND) */

